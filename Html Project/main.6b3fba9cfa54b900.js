(self.webpackChunkWebsite_A = self.webpackChunkWebsite_A || []).push([[179], { 118: (Qo, cd, fl) => { "use strict"; function Qe(n) { return "function" == typeof n } function Ee(n) { const e = n(i => { Error.call(i), i.stack = (new Error).stack }); return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e } const Nr = Ee(n => function (e) { n(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((i, r) => `${r + 1}) ${i.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e }); function Dn(n, t) { if (n) { const e = n.indexOf(t); 0 <= e && n.splice(e, 1) } } class ut { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._teardowns = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: e } = this; if (e) if (this._parentage = null, Array.isArray(e)) for (const o of e) o.remove(this); else e.remove(this); const { initialTeardown: i } = this; if (Qe(i)) try { i() } catch (o) { t = o instanceof Nr ? o.errors : [o] } const { _teardowns: r } = this; if (r) { this._teardowns = null; for (const o of r) try { As(o) } catch (s) { t = null != t ? t : [], s instanceof Nr ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new Nr(t) } } add(t) { var e; if (t && t !== this) if (this.closed) As(t); else { if (t instanceof ut) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._teardowns = null !== (e = this._teardowns) && void 0 !== e ? e : []).push(t) } } _hasParent(t) { const { _parentage: e } = this; return e === t || Array.isArray(e) && e.includes(t) } _addParent(t) { const { _parentage: e } = this; this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t } _removeParent(t) { const { _parentage: e } = this; e === t ? this._parentage = null : Array.isArray(e) && Dn(e, t) } remove(t) { const { _teardowns: e } = this; e && Dn(e, t), t instanceof ut && t._removeParent(this) } } ut.EMPTY = (() => { const n = new ut; return n.closed = !0, n })(); const zi = ut.EMPTY; function pl(n) { return n instanceof ut || n && "closed" in n && Qe(n.remove) && Qe(n.add) && Qe(n.unsubscribe) } function As(n) { Qe(n) ? n() : n.unsubscribe() } const Ei = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Lr = { setTimeout(...n) { const { delegate: t } = Lr; return ((null == t ? void 0 : t.setTimeout) || setTimeout)(...n) }, clearTimeout(n) { const { delegate: t } = Lr; return ((null == t ? void 0 : t.clearTimeout) || clearTimeout)(n) }, delegate: void 0 }; function ml(n) { Lr.setTimeout(() => { const { onUnhandledError: t } = Ei; if (!t) throw n; t(n) }) } function Ui() { } const dd = Pe("C", void 0, void 0); function Pe(n, t, e) { return { kind: n, value: t, error: e } } let Jn = null; function Ge(n) { if (Ei.useDeprecatedSynchronousErrorHandling) { const t = !Jn; if (t && (Jn = { errorThrown: !1, error: null }), n(), t) { const { errorThrown: e, error: i } = Jn; if (Jn = null, e) throw i } } else n() } class Is extends ut { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, pl(t) && t.add(this)) : this.destination = Br } static create(t, e, i) { return new sr(t, e, i) } next(t) { this.isStopped ? Ko(Pe("N", t, void 0), this) : this._next(t) } error(t) { this.isStopped ? Ko(Pe("E", void 0, t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Ko(dd, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } class sr extends Is { constructor(t, e, i) { let r; if (super(), Qe(t)) r = t; else if (t) { let o; ({ next: r, error: e, complete: i } = t), this && Ei.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = () => this.unsubscribe()) : o = t, r = null == r ? void 0 : r.bind(o), e = null == e ? void 0 : e.bind(o), i = null == i ? void 0 : i.bind(o) } this.destination = { next: r ? Rs(r) : Ui, error: Rs(null != e ? e : g), complete: i ? Rs(i) : Ui } } } function Rs(n, t) { return (...e) => { try { n(...e) } catch (i) { Ei.useDeprecatedSynchronousErrorHandling ? function (n) { Ei.useDeprecatedSynchronousErrorHandling && Jn && (Jn.errorThrown = !0, Jn.error = n) }(i) : ml(i) } } } function g(n) { throw n } function Ko(n, t) { const { onStoppedNotification: e } = Ei; e && Lr.setTimeout(() => e(n, t)) } const Br = { closed: !0, next: Ui, error: g, complete: Ui }, ar = "function" == typeof Symbol && Symbol.observable || "@@observable"; function $i(n) { return n } let at = (() => { class n { constructor(e) { e && (this._subscribe = e) } lift(e) { const i = new n; return i.source = this, i.operator = e, i } subscribe(e, i, r) { const o = function (n) { return n && n instanceof Is || function (n) { return n && Qe(n.next) && Qe(n.error) && Qe(n.complete) }(n) && pl(n) }(e) ? e : new sr(e, i, r); return Ge(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(e) { try { return this._subscribe(e) } catch (i) { e.error(i) } } forEach(e, i) { return new (i = Os(i))((r, o) => { let s; s = this.subscribe(a => { try { e(a) } catch (l) { o(l), null == s || s.unsubscribe() } }, o, r) }) } _subscribe(e) { var i; return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e) } [ar]() { return this } pipe(...e) { return function (n) { return 0 === n.length ? $i : 1 === n.length ? n[0] : function (e) { return n.reduce((i, r) => r(i), e) } }(e)(this) } toPromise(e) { return new (e = Os(e))((i, r) => { let o; this.subscribe(s => o = s, s => r(s), () => i(o)) }) } } return n.create = t => new n(t), n })(); function Os(n) { var t; return null !== (t = null != n ? n : Ei.Promise) && void 0 !== t ? t : Promise } const Of = Ee(n => function () { n(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let se = (() => { class n extends at { constructor() { super(), this.closed = !1, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(e) { const i = new hd(this, this); return i.operator = e, i } _throwIfClosed() { if (this.closed) throw new Of } next(e) { Ge(() => { if (this._throwIfClosed(), !this.isStopped) { const i = this.observers.slice(); for (const r of i) r.next(e) } }) } error(e) { Ge(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = e; const { observers: i } = this; for (; i.length;)i.shift().error(e) } }) } complete() { Ge(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: e } = this; for (; e.length;)e.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = null } get observed() { var e; return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0 } _trySubscribe(e) { return this._throwIfClosed(), super._trySubscribe(e) } _subscribe(e) { return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e) } _innerSubscribe(e) { const { hasError: i, isStopped: r, observers: o } = this; return i || r ? zi : (o.push(e), new ut(() => Dn(o, e))) } _checkFinalizedStatuses(e) { const { hasError: i, thrownError: r, isStopped: o } = this; i ? e.error(r) : o && e.complete() } asObservable() { const e = new at; return e.source = this, e } } return n.create = (t, e) => new hd(t, e), n })(); class hd extends se { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, t) } error(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, t) } complete() { var t, e; null === (e = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === e || e.call(t) } _subscribe(t) { var e, i; return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)) && void 0 !== i ? i : zi } } function gl(n) { return Qe(null == n ? void 0 : n.lift) } function lt(n) { return t => { if (gl(t)) return t.lift(function (e) { try { return n(e, this) } catch (i) { this.error(i) } }); throw new TypeError("Unable to lift unknown Observable type") } } class wt extends Is { constructor(t, e, i, r, o) { super(t), this.onFinalize = o, this._next = e ? function (s) { try { e(s) } catch (a) { t.error(a) } } : super._next, this._error = r ? function (s) { try { r(s) } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._error, this._complete = i ? function () { try { i() } catch (s) { t.error(s) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; const { closed: e } = this; super.unsubscribe(), !e && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } function Fe(n, t) { return lt((e, i) => { let r = 0; e.subscribe(new wt(i, o => { i.next(n.call(t, o, r++)) })) }) } function Vr(n) { return this instanceof Vr ? (this.v = n, this) : new Vr(n) } function md(n, t, e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r, i = e.apply(n, t || []), o = []; return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function () { return this }, r; function s(y) { i[y] && (r[y] = function (D) { return new Promise(function (M, k) { o.push([y, D, M, k]) > 1 || a(y, D) }) }) } function a(y, D) { try { !function (y) { y.value instanceof Vr ? Promise.resolve(y.value.v).then(d, h) : m(o[0][2], y) }(i[y](D)) } catch (M) { m(o[0][3], M) } } function d(y) { a("next", y) } function h(y) { a("throw", y) } function m(y, D) { y(D), o.shift(), o.length && a(o[0][0], o[0][1]) } } function Xo(n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, t = n[Symbol.asyncIterator]; return t ? t.call(n) : (n = function (n) { var t = "function" == typeof Symbol && Symbol.iterator, e = t && n[t], i = 0; if (e) return e.call(n); if (n && "number" == typeof n.length) return { next: function () { return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(n), e = {}, i("next"), i("throw"), i("return"), e[Symbol.asyncIterator] = function () { return this }, e); function i(o) { e[o] = n[o] && function (s) { return new Promise(function (a, l) { !function (o, s, a, l) { Promise.resolve(l).then(function (d) { o({ value: d, done: a }) }, s) }(a, l, (s = n[o](s)).done, s.value) }) } } } const Fs = n => n && "number" == typeof n.length && "function" != typeof n; function gd(n) { return Qe(null == n ? void 0 : n.then) } function jr(n) { return Qe(n[ar]) } function bo(n) { return Symbol.asyncIterator && Qe(null == n ? void 0 : n[Symbol.asyncIterator]) } function yl(n) { return new TypeError(`You provided ${null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Hn = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"; function wn(n) { return Qe(null == n ? void 0 : n[Hn]) } function Ns(n) { return md(this, arguments, function* () { const e = n.getReader(); try { for (; ;) { const { value: i, done: r } = yield Vr(e.read()); if (r) return yield Vr(void 0); yield yield Vr(i) } } finally { e.releaseLock() } }) } function vd(n) { return Qe(null == n ? void 0 : n.getReader) } function On(n) { if (n instanceof at) return n; if (null != n) { if (jr(n)) return function (n) { return new at(t => { const e = n[ar](); if (Qe(e.subscribe)) return e.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(n); if (Fs(n)) return function (n) { return new at(t => { for (let e = 0; e < n.length && !t.closed; e++)t.next(n[e]); t.complete() }) }(n); if (gd(n)) return function (n) { return new at(t => { n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, ml) }) }(n); if (bo(n)) return bd(n); if (wn(n)) return function (n) { return new at(t => { for (const e of n) if (t.next(e), t.closed) return; t.complete() }) }(n); if (vd(n)) return function (n) { return bd(Ns(n)) }(n) } throw yl(n) } function bd(n) { return new at(t => { (function (n, t) { var e, i, r, o; return function (n, t, e, i) { return new (e || (e = Promise))(function (o, s) { function a(h) { try { d(i.next(h)) } catch (m) { s(m) } } function l(h) { try { d(i.throw(h)) } catch (m) { s(m) } } function d(h) { h.done ? o(h.value) : function (o) { return o instanceof e ? o : new e(function (s) { s(o) }) }(h.value).then(a, l) } d((i = i.apply(n, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (e = Xo(n); !(i = yield e.next()).done;)if (t.next(i.value), t.closed) return } catch (s) { r = { error: s } } finally { try { i && !i.done && (o = e.return) && (yield o.call(e)) } finally { if (r) throw r.error } } t.complete() }) })(n, t).catch(e => t.error(e)) }) } function Gi(n, t, e, i = 0, r = !1) { const o = t.schedule(function () { e(), r ? n.add(this.schedule(null, i)) : this.unsubscribe() }, i); if (n.add(o), !r) return o } function Ft(n, t, e = 1 / 0) { return Qe(t) ? Ft((i, r) => Fe((o, s) => t(i, o, r, s))(On(n(i, r))), e) : ("number" == typeof t && (e = t), lt((i, r) => function (n, t, e, i, r, o, s, a) { const l = []; let d = 0, h = 0, m = !1; const y = () => { m && !l.length && !d && t.complete() }, D = k => d < i ? M(k) : l.push(k), M = k => { d++; let P = !1; On(e(k, h++)).subscribe(new wt(t, H => { t.next(H) }, () => { P = !0 }, void 0, () => { if (P) try { for (d--; l.length && d < i;) { const H = l.shift(); M(H) } y() } catch (H) { t.error(H) } })) }; return n.subscribe(new wt(t, D, () => { m = !0, y() })), () => { } }(i, r, n, e))) } function wo(n = 1 / 0) { return Ft($i, n) } const qi = new at(n => n.complete()); function Dd(n) { return n && Qe(n.schedule) } function dr(n) { return n[n.length - 1] } function zr(n) { return Dd(dr(n)) ? n.pop() : void 0 } function Dl(n, t = 0) { return lt((e, i) => { e.subscribe(new wt(i, r => Gi(i, n, () => i.next(r), t), () => Gi(i, n, () => i.complete(), t), r => Gi(i, n, () => i.error(r), t))) }) } function wd(n, t = 0) { return lt((e, i) => { i.add(n.schedule(() => e.subscribe(i), t)) }) } function wl(n, t) { if (!n) throw new Error("Iterable cannot be null"); return new at(e => { Gi(e, t, () => { const i = n[Symbol.asyncIterator](); Gi(e, t, () => { i.next().then(r => { r.done ? e.complete() : e.next(r.value) }) }, 0, !0) }) }) } function Ut(n, t) { return t ? function (n, t) { if (null != n) { if (jr(n)) return function (n, t) { return On(n).pipe(wd(t), Dl(t)) }(n, t); if (Fs(n)) return function (n, t) { return new at(e => { let i = 0; return t.schedule(function () { i === n.length ? e.complete() : (e.next(n[i++]), e.closed || this.schedule()) }) }) }(n, t); if (gd(n)) return function (n, t) { return On(n).pipe(wd(t), Dl(t)) }(n, t); if (bo(n)) return wl(n, t); if (wn(n)) return function (n, t) { return new at(e => { let i; return Gi(e, t, () => { i = n[Hn](), Gi(e, t, () => { let r, o; try { ({ value: r, done: o } = i.next()) } catch (s) { return void e.error(s) } o ? e.complete() : e.next(r) }, 0, !0) }), () => Qe(null == i ? void 0 : i.return) && i.return() }) }(n, t); if (vd(n)) return function (n, t) { return wl(Ns(n), t) }(n, t) } throw yl(n) }(n, t) : On(n) } function ei(...n) { const t = zr(n), e = function (n, t) { return "number" == typeof dr(n) ? n.pop() : 1 / 0 }(n), i = n; return i.length ? 1 === i.length ? On(i[0]) : wo(e)(Ut(i, t)) : qi } function pn(n) { return n <= 0 ? () => qi : lt((t, e) => { let i = 0; t.subscribe(new wt(e, r => { ++i <= n && (e.next(r), n <= i && e.complete()) })) }) } function Vs(n, t, ...e) { return !0 === t ? (n(), null) : !1 === t ? null : t(...e).pipe(pn(1)).subscribe(() => n()) } function ht(n) { for (let t in n) if (n[t] === ht) return t; throw Error("Could not find renamed property on target object.") } function Hs(n, t) { for (const e in t) t.hasOwnProperty(e) && !n.hasOwnProperty(e) && (n[e] = t[e]) } function De(n) { if ("string" == typeof n) return n; if (Array.isArray(n)) return "[" + n.map(De).join(", ") + "]"; if (null == n) return "" + n; if (n.overriddenName) return `${n.overriddenName}`; if (n.name) return `${n.name}`; const t = n.toString(); if (null == t) return "" + t; const e = t.indexOf("\n"); return -1 === e ? t : t.substring(0, e) } function ur(n, t) { return null == n || "" === n ? null === t ? "" : t : null == t || "" === t ? n : n + " " + t } const js = ht({ __forward_ref__: ht }); function We(n) { return n.__forward_ref__ = We, n.toString = function () { return De(this()) }, n } function He(n) { return zs(n) ? n() : n } function zs(n) { return "function" == typeof n && n.hasOwnProperty(js) && n.__forward_ref__ === We } class mn extends Error { constructor(t, e) { super(function (n, t) { return `${n ? `NG0${n}: ` : ""}${t}` }(t, e)), this.code = t } } function Ae(n) { return "string" == typeof n ? n : null == n ? "" : String(n) } function yt(n) { return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : Ae(n) } function $s(n, t) { const e = t ? ` in ${t}` : ""; throw new mn("201", `No provider for ${yt(n)} found${e}`) } function xn(n, t) { null == n && function (n, t, e, i) { throw new Error(`ASSERTION ERROR: ${n}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${t} <=Actual]`)) }(t, n, null, "!=") } function X(n) { return { token: n.token, providedIn: n.providedIn || null, factory: n.factory, value: void 0 } } function re(n) { return { providers: n.providers || [], imports: n.imports || [] } } function qs(n) { return Ws(n, es) || Ws(n, Ad) } function Ws(n, t) { return n.hasOwnProperty(t) ? n[t] : null } function kl(n) { return n && (n.hasOwnProperty(ts) || n.hasOwnProperty(Yf)) ? n[ts] : null } const es = ht({ \u0275prov: ht }), ts = ht({ \u0275inj: ht }), Ad = ht({ ngInjectableDef: ht }), Yf = ht({ ngInjectorDef: ht }); var Ie = (() => ((Ie = Ie || {})[Ie.Default = 0] = "Default", Ie[Ie.Host = 1] = "Host", Ie[Ie.Self = 2] = "Self", Ie[Ie.SkipSelf = 4] = "SkipSelf", Ie[Ie.Optional = 8] = "Optional", Ie))(); let Ur; function Ti(n) { const t = Ur; return Ur = n, t } function Rd(n, t, e) { const i = qs(n); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & Ie.Optional ? null : void 0 !== t ? t : void $s(De(n), "Injector") } function hr(n) { return { toString: n }.toString() } var c = (() => ((c = c || {})[c.OnPush = 0] = "OnPush", c[c.Default = 1] = "Default", c))(), p = (() => { return (n = p || (p = {}))[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", p; var n })(); const _ = "undefined" != typeof globalThis && globalThis, v = "undefined" != typeof window && window, b = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, x = _ || "undefined" != typeof global && global || v || b, $ = {}, I = [], B = ht({ \u0275cmp: ht }), ce = ht({ \u0275dir: ht }), Me = ht({ \u0275pipe: ht }), de = ht({ \u0275mod: ht }), gt = ht({ \u0275fac: ht }), xt = ht({ __NG_ELEMENT_ID__: ht }); let jn = 0; function ue(n) { return hr(() => { const e = {}, i = { type: n.type, providersResolver: null, decls: n.decls, vars: n.vars, factory: null, template: n.template || null, consts: n.consts || null, ngContentSelectors: n.ngContentSelectors, hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0, hostAttrs: n.hostAttrs || null, contentQueries: n.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: n.exportAs || null, onPush: n.changeDetection === c.OnPush, directiveDefs: null, pipeDefs: null, selectors: n.selectors || I, viewQuery: n.viewQuery || null, features: n.features || null, data: n.data || {}, encapsulation: n.encapsulation || p.Emulated, id: "c", styles: n.styles || I, _: null, setInput: null, schemas: n.schemas || null, tView: null }, r = n.directives, o = n.features, s = n.pipes; return i.id += jn++, i.inputs = Pn(n.inputs, e), i.outputs = Pn(n.outputs), o && o.forEach(a => a(i)), i.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(Mn) : null, i.pipeDefs = s ? () => ("function" == typeof s ? s() : s).map(tt) : null, i }) } function Mn(n) { return ft(n) || function (n) { return n[ce] || null }(n) } function tt(n) { return function (n) { return n[Me] || null }(n) } const Mt = {}; function J(n) { return hr(() => { const t = { type: n.type, bootstrap: n.bootstrap || I, declarations: n.declarations || I, imports: n.imports || I, exports: n.exports || I, transitiveCompileScopes: null, schemas: n.schemas || null, id: n.id || null }; return null != n.id && (Mt[n.id] = n.type), t }) } function Pn(n, t) { if (null == n) return $; const e = {}; for (const i in n) if (n.hasOwnProperty(i)) { let r = n[i], o = r; Array.isArray(r) && (o = r[1], r = r[0]), e[r] = i, t && (t[r] = o) } return e } const z = ue; function ft(n) { return n[B] || null } function Gt(n, t) { const e = n[de] || null; if (!e && !0 === t) throw new Error(`Type ${De(n)} does not have '\u0275mod' property.`); return e } function Lt(n) { return Array.isArray(n) && "object" == typeof n[1] } function $n(n) { return Array.isArray(n) && !0 === n[1] } function Xs(n) { return 0 != (8 & n.flags) } function Zs(n) { return 2 == (2 & n.flags) } function Js(n) { return 1 == (1 & n.flags) } function ni(n) { return null !== n.template } function Wr(n) { return 0 != (512 & n[2]) } function Re(n, t) { return n.hasOwnProperty(gt) ? n[gt] : null } class _t { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function Bt(n) { return n.type.prototype.ngOnChanges && (n.setInput = Gn), gn } function gn() { const n = So(this), t = null == n ? void 0 : n.current; if (t) { const e = n.previous; if (e === $) n.previous = t; else for (let i in t) e[i] = t[i]; n.current = null, this.ngOnChanges(t) } } function Gn(n, t, e, i) { const r = So(n) || function (n, t) { return n[Dt] = t }(n, { previous: $, current: null }), o = r.current || (r.current = {}), s = r.previous, a = this.declaredInputs[e], l = s[a]; o[a] = new _t(l && l.currentValue, t, s === $), n[i] = t } const Dt = "__ngSimpleChanges__"; function So(n) { return n[Dt] || null } const hy = "http://www.w3.org/2000/svg"; let Qf; function Vt(n) { return !!n.listen } const py = { createRenderer: (n, t) => void 0 !== Qf ? Qf : "undefined" != typeof document ? document : void 0 }; function Xt(n) { for (; Array.isArray(n);)n = n[0]; return n } function Ii(n, t) { return Xt(t[n.index]) } function Xf(n, t) { return n.data[t] } function hi(n, t) { const e = t[n]; return Lt(e) ? e : e[0] } function my(n) { return 4 == (4 & n[2]) } function Zf(n) { return 128 == (128 & n[2]) } function To(n, t) { return null == t ? null : n[t] } function gy(n) { n[18] = 0 } function Jf(n, t) { n[5] += t; let e = n, i = n[3]; for (; null !== i && (1 === t && 1 === e[5] || -1 === t && 0 === e[5]);)i[5] += t, e = i, i = i[3] } const Oe = { lFrame: xy(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function _y() { return Oe.bindingsEnabled } function q() { return Oe.lFrame.lView } function st() { return Oe.lFrame.tView } function on() { let n = vy(); for (; null !== n && 64 === n.type;)n = n.parent; return n } function vy() { return Oe.lFrame.currentTNode } function pr(n, t) { const e = Oe.lFrame; e.currentTNode = n, e.isParent = t } function ep() { return Oe.lFrame.isParent } function Vd() { return Oe.isInCheckNoChangesMode } function Hd(n) { Oe.isInCheckNoChangesMode = n } function na() { return Oe.lFrame.bindingIndex++ } function Wk(n, t) { const e = Oe.lFrame; e.bindingIndex = e.bindingRootIndex = n, np(t) } function np(n) { Oe.lFrame.currentDirectiveIndex = n } function ip(n) { const t = Oe.lFrame.currentDirectiveIndex; return -1 === t ? null : n[t] } function Cy() { return Oe.lFrame.currentQueryIndex } function rp(n) { Oe.lFrame.currentQueryIndex = n } function Qk(n) { const t = n[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? n[6] : null } function Dy(n, t, e) { if (e & Ie.SkipSelf) { let r = t, o = n; for (; !(r = r.parent, null !== r || e & Ie.Host || (r = Qk(o), null === r || (o = o[15], 10 & r.type)));); if (null === r) return !1; t = r, n = o } const i = Oe.lFrame = wy(); return i.currentTNode = t, i.lView = n, !0 } function jd(n) { const t = wy(), e = n[1]; Oe.lFrame = t, t.currentTNode = e.firstChild, t.lView = n, t.tView = e, t.contextLView = n, t.bindingIndex = e.bindingStartIndex, t.inI18n = !1 } function wy() { const n = Oe.lFrame, t = null === n ? null : n.child; return null === t ? xy(n) : t } function xy(n) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: n, child: null, inI18n: !1 }; return null !== n && (n.child = t), t } function My() { const n = Oe.lFrame; return Oe.lFrame = n.parent, n.currentTNode = null, n.lView = null, n } const Ey = My; function zd() { const n = My(); n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0 } function Wn() { return Oe.lFrame.selectedIndex } function ko(n) { Oe.lFrame.selectedIndex = n } function Ht() { const n = Oe.lFrame; return Xf(n.tView, n.selectedIndex) } function Pl() { Oe.lFrame.currentNamespace = hy } function Ud(n, t) { for (let e = t.directiveStart, i = t.directiveEnd; e < i; e++) { const o = n.data[e].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: d, ngOnDestroy: h } = o; s && (n.contentHooks || (n.contentHooks = [])).push(-e, s), a && ((n.contentHooks || (n.contentHooks = [])).push(e, a), (n.contentCheckHooks || (n.contentCheckHooks = [])).push(e, a)), l && (n.viewHooks || (n.viewHooks = [])).push(-e, l), d && ((n.viewHooks || (n.viewHooks = [])).push(e, d), (n.viewCheckHooks || (n.viewCheckHooks = [])).push(e, d)), null != h && (n.destroyHooks || (n.destroyHooks = [])).push(e, h) } } function $d(n, t, e) { Ty(n, t, 3, e) } function Gd(n, t, e, i) { (3 & n[2]) === e && Ty(n, t, e, i) } function op(n, t) { let e = n[2]; (3 & e) === t && (e &= 2047, e += 1, n[2] = e) } function Ty(n, t, e, i) { const o = null != i ? i : -1, s = t.length - 1; let a = 0; for (let l = void 0 !== i ? 65535 & n[18] : 0; l < s; l++)if ("number" == typeof t[l + 1]) { if (a = t[l], null != i && a >= i) break } else t[l] < 0 && (n[18] += 65536), (a < o || -1 == o) && (nA(n, e, t, l), n[18] = (4294901760 & n[18]) + l + 2), l++ } function nA(n, t, e, i) { const r = e[i] < 0, o = e[i + 1], a = n[r ? -e[i] : e[i]]; if (r) { if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === t) { n[2] += 2048; try { o.call(a) } finally { } } } else try { o.call(a) } finally { } } class Fl { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function qd(n, t, e) { const i = Vt(n); let r = 0; for (; r < e.length;) { const o = e[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const s = e[r++], a = e[r++], l = e[r++]; i ? n.setAttribute(t, a, l, s) : t.setAttributeNS(s, a, l) } else { const s = o, a = e[++r]; ap(s) ? i && n.setProperty(t, s, a) : i ? n.setAttribute(t, s, a) : t.setAttribute(s, a), r++ } } return r } function ky(n) { return 3 === n || 4 === n || 6 === n } function ap(n) { return 64 === n.charCodeAt(0) } function Wd(n, t) { if (null !== t && 0 !== t.length) if (null === n || 0 === n.length) n = t.slice(); else { let e = -1; for (let i = 0; i < t.length; i++) { const r = t[i]; "number" == typeof r ? e = r : 0 === e || Ay(n, e, r, null, -1 === e || 2 === e ? t[++i] : null) } } return n } function Ay(n, t, e, i, r) { let o = 0, s = n.length; if (-1 === t) s = -1; else for (; o < n.length;) { const a = n[o++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = o - 1; break } } } for (; o < n.length;) { const a = n[o]; if ("number" == typeof a) break; if (a === e) { if (null === i) return void (null !== r && (n[o + 1] = r)); if (i === n[o + 1]) return void (n[o + 2] = r) } o++, null !== i && o++, null !== r && o++ } -1 !== s && (n.splice(s, 0, t), o = s + 1), n.splice(o++, 0, e), null !== i && n.splice(o++, 0, i), null !== r && n.splice(o++, 0, r) } function Iy(n) { return -1 !== n } function ia(n) { return 32767 & n } function ra(n, t) { let e = function (n) { return n >> 16 }(n), i = t; for (; e > 0;)i = i[15], e--; return i } let lp = !0; function Yd(n) { const t = lp; return lp = n, t } let lA = 0; function Ll(n, t) { const e = dp(n, t); if (-1 !== e) return e; const i = t[1]; i.firstCreatePass && (n.injectorIndex = t.length, cp(i.data, n), cp(t, null), cp(i.blueprint, null)); const r = Qd(n, t), o = n.injectorIndex; if (Iy(r)) { const s = ia(r), a = ra(r, t), l = a[1].data; for (let d = 0; d < 8; d++)t[o + d] = a[s + d] | l[s + d] } return t[o + 8] = r, o } function cp(n, t) { n.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function dp(n, t) { return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === t[n.injectorIndex + 8] ? -1 : n.injectorIndex } function Qd(n, t) { if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex; let e = 0, i = null, r = t; for (; null !== r;) { const o = r[1], s = o.type; if (i = 2 === s ? o.declTNode : 1 === s ? r[6] : null, null === i) return -1; if (e++, r = r[15], -1 !== i.injectorIndex) return i.injectorIndex | e << 16 } return -1 } function Kd(n, t, e) { !function (n, t, e) { let i; "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(xt) && (i = e[xt]), null == i && (i = e[xt] = lA++); const r = 255 & i; t.data[n + (r >> 5)] |= 1 << r }(n, t, e) } function Py(n, t, e) { if (e & Ie.Optional) return n; $s(t, "NodeInjector") } function Fy(n, t, e, i) { if (e & Ie.Optional && void 0 === i && (i = null), 0 == (e & (Ie.Self | Ie.Host))) { const r = n[9], o = Ti(void 0); try { return r ? r.get(t, i, e & Ie.Optional) : Rd(t, i, e & Ie.Optional) } finally { Ti(o) } } return Py(i, t, e) } function Ny(n, t, e, i = Ie.Default, r) { if (null !== n) { const o = function (n) { if ("string" == typeof n) return n.charCodeAt(0) || 0; const t = n.hasOwnProperty(xt) ? n[xt] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : uA : t }(e); if ("function" == typeof o) { if (!Dy(t, n, i)) return i & Ie.Host ? Py(r, e, i) : Fy(t, e, i, r); try { const s = o(i); if (null != s || i & Ie.Optional) return s; $s(e) } finally { Ey() } } else if ("number" == typeof o) { let s = null, a = dp(n, t), l = -1, d = i & Ie.Host ? t[16][6] : null; for ((-1 === a || i & Ie.SkipSelf) && (l = -1 === a ? Qd(n, t) : t[a + 8], -1 !== l && Vy(i, !1) ? (s = t[1], a = ia(l), t = ra(l, t)) : a = -1); -1 !== a;) { const h = t[1]; if (By(o, a, h.data)) { const m = hA(a, t, e, s, i, d); if (m !== Ly) return m } l = t[a + 8], -1 !== l && Vy(i, t[1].data[a + 8] === d) && By(o, a, t) ? (s = h, a = ia(l), t = ra(l, t)) : a = -1 } } } return Fy(t, e, i, r) } const Ly = {}; function uA() { return new oa(on(), q()) } function hA(n, t, e, i, r, o) { const s = t[1], a = s.data[n + 8], h = Xd(a, s, e, null == i ? Zs(a) && lp : i != s && 0 != (3 & a.type), r & Ie.Host && o === a); return null !== h ? Bl(t, s, h, a) : Ly } function Xd(n, t, e, i, r) { const o = n.providerIndexes, s = t.data, a = 1048575 & o, l = n.directiveStart, h = o >> 20, y = r ? a + h : n.directiveEnd; for (let D = i ? a : a + h; D < y; D++) { const M = s[D]; if (D < l && e === M || D >= l && M.type === e) return D } if (r) { const D = s[l]; if (D && ni(D) && D.type === e) return l } return null } function Bl(n, t, e, i) { let r = n[e]; const o = t.data; if (function (n) { return n instanceof Fl }(r)) { const s = r; s.resolving && function (n, t) { throw new mn("200", `Circular dependency in DI detected for ${n}`) }(yt(o[e])); const a = Yd(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? Ti(s.injectImpl) : null; Dy(n, i, Ie.Default); try { r = n[e] = s.factory(void 0, o, n, i), t.firstCreatePass && e >= i.directiveStart && function (n, t, e) { const { ngOnChanges: i, ngOnInit: r, ngDoCheck: o } = t.type.prototype; if (i) { const s = Bt(t); (e.preOrderHooks || (e.preOrderHooks = [])).push(n, s), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, s) } r && (e.preOrderHooks || (e.preOrderHooks = [])).push(0 - n, r), o && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n, o), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, o)) }(e, o[e], t) } finally { null !== l && Ti(l), Yd(a), s.resolving = !1, Ey() } } return r } function By(n, t, e) { return !!(e[t + (n >> 5)] & 1 << n) } function Vy(n, t) { return !(n & Ie.Self || n & Ie.Host && t) } class oa { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e, i) { return Ny(this._tNode, this._lView, t, i, e) } } function up(n) { return zs(n) ? () => { const t = up(He(n)); return t && t() } : Re(n) } const aa = "__parameters__"; function ca(n, t, e) { return hr(() => { const i = function (n) { return function (...e) { if (n) { const i = n(...e); for (const r in i) this[r] = i[r] } } }(t); function r(...o) { if (this instanceof r) return i.apply(this, o), this; const s = new r(...o); return a.annotation = s, a; function a(l, d, h) { const m = l.hasOwnProperty(aa) ? l[aa] : Object.defineProperty(l, aa, { value: [] })[aa]; for (; m.length <= h;)m.push(null); return (m[h] = m[h] || []).push(s), l } } return e && (r.prototype = Object.create(e.prototype)), r.prototype.ngMetadataName = n, r.annotationCls = r, r }) } class V { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = X({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const mA = new V("AnalyzeForEntryComponents"); function Ri(n, t) { void 0 === t && (t = n); for (let e = 0; e < n.length; e++) { let i = n[e]; Array.isArray(i) ? (t === n && (t = n.slice(0, e)), Ri(i, t)) : t !== n && t.push(i) } return t } function mr(n, t) { n.forEach(e => Array.isArray(e) ? mr(e, t) : t(e)) } function jy(n, t, e) { t >= n.length ? n.push(e) : n.splice(t, 0, e) } function Zd(n, t) { return t >= n.length - 1 ? n.pop() : n.splice(t, 1)[0] } function fi(n, t, e) { let i = da(n, t); return i >= 0 ? n[1 | i] = e : (i = ~i, function (n, t, e, i) { let r = n.length; if (r == t) n.push(e, i); else if (1 === r) n.push(i, n[0]), n[0] = e; else { for (r--, n.push(n[r - 1], n[r]); r > t;)n[r] = n[r - 2], r--; n[t] = e, n[t + 1] = i } }(n, i, t, e)), i } function pp(n, t) { const e = da(n, t); if (e >= 0) return n[1 | e] } function da(n, t) { return function (n, t, e) { let i = 0, r = n.length >> e; for (; r !== i;) { const o = i + (r - i >> 1), s = n[o << e]; if (t === s) return o << e; s > t ? r = o : i = o + 1 } return ~(r << e) }(n, t, 1) } const zl = {}, gp = "__NG_DI_FLAG__", eu = "ngTempTokenPath", MA = /\n/gm, qy = "__source", SA = ht({ provide: String, useValue: ht }); let Ul; function Wy(n) { const t = Ul; return Ul = n, t } function TA(n, t = Ie.Default) { if (void 0 === Ul) throw new Error("inject() must be called from an injection context"); return null === Ul ? Rd(n, void 0, t) : Ul.get(n, t & Ie.Optional ? null : void 0, t) } function L(n, t = Ie.Default) { return (Ur || TA)(He(n), t) } const tu = L; function _p(n) { const t = []; for (let e = 0; e < n.length; e++) { const i = He(n[e]); if (Array.isArray(i)) { if (0 === i.length) throw new Error("Arguments array must have arguments."); let r, o = Ie.Default; for (let s = 0; s < i.length; s++) { const a = i[s], l = kA(a); "number" == typeof l ? -1 === l ? r = a.token : o |= l : r = a } t.push(L(r, o)) } else t.push(L(i)) } return t } function $l(n, t) { return n[gp] = t, n.prototype[gp] = t, n } function kA(n) { return n[gp] } const Gl = $l(ca("Inject", n => ({ token: n })), -1), an = $l(ca("Optional"), 8), pi = $l(ca("SkipSelf"), 4); const fb = "__ngContext__"; function Nn(n, t) { n[fb] = t } function Sp(n) { const t = function (n) { return n[fb] || null }(n); return t ? Array.isArray(t) ? t : t.lView : null } function kp(n) { return n.ngOriginalError } function MI(n, ...t) { n.error(...t) } class Io { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), i = (n = t) && n.ngErrorLogger || MI; var n; i(this._console, "ERROR", t), e && i(this._console, "ORIGINAL ERROR", e) } _findOriginalError(t) { let e = t && kp(t); for (; e && kp(e);)e = kp(e); return e || null } } const vb = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(x))(); function vr(n) { return n instanceof Function ? n() : n } var gi = (() => ((gi = gi || {})[gi.Important = 1] = "Important", gi[gi.DashCase = 2] = "DashCase", gi))(); function Ip(n, t) { return undefined(n, t) } function Xl(n) { const t = n[3]; return $n(t) ? t[3] : t } function Rp(n) { return wb(n[13]) } function Op(n) { return wb(n[4]) } function wb(n) { for (; null !== n && !$n(n);)n = n[4]; return n } function pa(n, t, e, i, r) { if (null != i) { let o, s = !1; $n(i) ? o = i : Lt(i) && (s = !0, i = i[0]); const a = Xt(i); 0 === n && null !== e ? null == r ? kb(t, e, a) : ss(t, e, a, r || null, !0) : 1 === n && null !== e ? ss(t, e, a, r || null, !0) : 2 === n ? function (n, t, e) { const i = su(n, t); i && function (n, t, e, i) { Vt(n) ? n.removeChild(t, e, i) : t.removeChild(e) }(n, i, t, e) }(t, a, s) : 3 === n && t.destroyNode(a), null != o && function (n, t, e, i, r) { const o = e[7]; o !== Xt(e) && pa(t, n, i, o, r); for (let a = 10; a < e.length; a++) { const l = e[a]; Zl(l[1], l, n, t, i, o) } }(t, n, o, e, r) } } function Fp(n, t, e) { return Vt(n) ? n.createElement(t, e) : null === e ? n.createElement(t) : n.createElementNS(e, t) } function Mb(n, t) { const e = n[9], i = e.indexOf(t), r = t[3]; 1024 & t[2] && (t[2] &= -1025, Jf(r, -1)), e.splice(i, 1) } function Np(n, t) { if (n.length <= 10) return; const e = 10 + t, i = n[e]; if (i) { const r = i[17]; null !== r && r !== n && Mb(r, i), t > 0 && (n[e - 1][4] = i[4]); const o = Zd(n, 10 + t); !function (n, t) { Zl(n, t, t[11], 2, null, null), t[0] = null, t[6] = null }(i[1], i); const s = o[19]; null !== s && s.detachView(o[1]), i[3] = null, i[4] = null, i[2] &= -129 } return i } function Eb(n, t) { if (!(256 & t[2])) { const e = t[11]; Vt(e) && e.destroyNode && Zl(n, t, e, 3, null, null), function (n) { let t = n[13]; if (!t) return Lp(n[1], n); for (; t;) { let e = null; if (Lt(t)) e = t[13]; else { const i = t[10]; i && (e = i) } if (!e) { for (; t && !t[4] && t !== n;)Lt(t) && Lp(t[1], t), t = t[3]; null === t && (t = n), Lt(t) && Lp(t[1], t), e = t && t[4] } t = e } }(t) } } function Lp(n, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function (n, t) { let e; if (null != n && null != (e = n.destroyHooks)) for (let i = 0; i < e.length; i += 2) { const r = t[e[i]]; if (!(r instanceof Fl)) { const o = e[i + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = r[o[s]], l = o[s + 1]; try { l.call(a) } finally { } } else try { o.call(r) } finally { } } } }(n, t), function (n, t) { const e = n.cleanup, i = t[7]; let r = -1; if (null !== e) for (let o = 0; o < e.length - 1; o += 2)if ("string" == typeof e[o]) { const s = e[o + 1], a = "function" == typeof s ? s(t) : Xt(t[s]), l = i[r = e[o + 2]], d = e[o + 3]; "boolean" == typeof d ? a.removeEventListener(e[o], l, d) : d >= 0 ? i[r = d]() : i[r = -d].unsubscribe(), o += 2 } else { const s = i[r = e[o + 1]]; e[o].call(s) } if (null !== i) { for (let o = r + 1; o < i.length; o++)i[o](); t[7] = null } }(n, t), 1 === t[1].type && Vt(t[11]) && t[11].destroy(); const e = t[17]; if (null !== e && $n(t[3])) { e !== t[3] && Mb(e, t); const i = t[19]; null !== i && i.detachView(n) } } } function Sb(n, t, e) { return function (n, t, e) { let i = t; for (; null !== i && 40 & i.type;)i = (t = i).parent; if (null === i) return e[0]; if (2 & i.flags) { const r = n.data[i.directiveStart].encapsulation; if (r === p.None || r === p.Emulated) return null } return Ii(i, e) }(n, t.parent, e) } function ss(n, t, e, i, r) { Vt(n) ? n.insertBefore(t, e, i, r) : t.insertBefore(e, i, r) } function kb(n, t, e) { Vt(n) ? n.appendChild(t, e) : t.appendChild(e) } function Ab(n, t, e, i, r) { null !== i ? ss(n, t, e, i, r) : kb(n, t, e) } function su(n, t) { return Vt(n) ? n.parentNode(t) : t.parentNode } let Ob = function (n, t, e) { return 40 & n.type ? Ii(n, e) : null }; function au(n, t, e, i) { const r = Sb(n, i, t), o = t[11], a = function (n, t, e) { return Ob(n, t, e) }(i.parent || t[6], i, t); if (null != r) if (Array.isArray(e)) for (let l = 0; l < e.length; l++)Ab(o, r, e[l], a, !1); else Ab(o, r, e, a, !1) } function lu(n, t) { if (null !== t) { const e = t.type; if (3 & e) return Ii(t, n); if (4 & e) return Vp(-1, n[t.index]); if (8 & e) { const i = t.child; if (null !== i) return lu(n, i); { const r = n[t.index]; return $n(r) ? Vp(-1, r) : Xt(r) } } if (32 & e) return Ip(t, n)() || Xt(n[t.index]); { const i = Fb(n, t); return null !== i ? Array.isArray(i) ? i[0] : lu(Xl(n[16]), i) : lu(n, t.next) } } return null } function Fb(n, t) { return null !== t ? n[16][6].projection[t.projection] : null } function Vp(n, t) { const e = 10 + n + 1; if (e < t.length) { const i = t[e], r = i[1].firstChild; if (null !== r) return lu(i, r) } return t[7] } function Hp(n, t, e, i, r, o, s) { for (; null != e;) { const a = i[e.index], l = e.type; if (s && 0 === t && (a && Nn(Xt(a), i), e.flags |= 4), 64 != (64 & e.flags)) if (8 & l) Hp(n, t, e.child, i, r, o, !1), pa(t, n, r, a, o); else if (32 & l) { const d = Ip(e, i); let h; for (; h = d();)pa(t, n, r, h, o); pa(t, n, r, a, o) } else 16 & l ? Lb(n, t, i, e, r, o) : pa(t, n, r, a, o); e = s ? e.projectionNext : e.next } } function Zl(n, t, e, i, r, o) { Hp(e, i, n.firstChild, t, r, o, !1) } function Lb(n, t, e, i, r, o) { const s = e[16], l = s[6].projection[i.projection]; if (Array.isArray(l)) for (let d = 0; d < l.length; d++)pa(t, n, r, l[d], o); else Hp(n, t, l, s[3], r, o, !0) } function Bb(n, t, e) { Vt(n) ? n.setAttribute(t, "style", e) : t.style.cssText = e } function jp(n, t, e) { Vt(n) ? "" === e ? n.removeAttribute(t, "class") : n.setAttribute(t, "class", e) : t.className = e } function Vb(n, t, e) { let i = n.length; for (; ;) { const r = n.indexOf(t, e); if (-1 === r) return r; if (0 === r || n.charCodeAt(r - 1) <= 32) { const o = t.length; if (r + o === i || n.charCodeAt(r + o) <= 32) return r } e = r + 1 } } const Hb = "ng-template"; function JI(n, t, e) { let i = 0; for (; i < n.length;) { let r = n[i++]; if (e && "class" === r) { if (r = n[i], -1 !== Vb(r.toLowerCase(), t, 0)) return !0 } else if (1 === r) { for (; i < n.length && "string" == typeof (r = n[i++]);)if (r.toLowerCase() === t) return !0; return !1 } } return !1 } function jb(n) { return 4 === n.type && n.value !== Hb } function eR(n, t, e) { return t === (4 !== n.type || e ? n.value : Hb) } function tR(n, t, e) { let i = 4; const r = n.attrs || [], o = function (n) { for (let t = 0; t < n.length; t++)if (ky(n[t])) return t; return n.length }(r); let s = !1; for (let a = 0; a < t.length; a++) { const l = t[a]; if ("number" != typeof l) { if (!s) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !eR(n, l, e) || "" === l && 1 === t.length) { if (Yi(i)) return !1; s = !0 } } else { const d = 8 & i ? l : t[++a]; if (8 & i && null !== n.attrs) { if (!JI(n.attrs, d, e)) { if (Yi(i)) return !1; s = !0 } continue } const m = nR(8 & i ? "class" : l, r, jb(n), e); if (-1 === m) { if (Yi(i)) return !1; s = !0; continue } if ("" !== d) { let y; y = m > o ? "" : r[m + 1].toLowerCase(); const D = 8 & i ? y : null; if (D && -1 !== Vb(D, d, 0) || 2 & i && d !== y) { if (Yi(i)) return !1; s = !0 } } } } else { if (!s && !Yi(i) && !Yi(l)) return !1; if (s && Yi(l)) continue; s = !1, i = l | 1 & i } } return Yi(i) || s } function Yi(n) { return 0 == (1 & n) } function nR(n, t, e, i) { if (null === t) return -1; let r = 0; if (i || !e) { let o = !1; for (; r < t.length;) { const s = t[r]; if (s === n) return r; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = t[++r]; for (; "string" == typeof a;)a = t[++r]; continue } if (4 === s) break; if (0 === s) { r += 4; continue } } r += o ? 1 : 2 } return -1 } return function (n, t) { let e = n.indexOf(4); if (e > -1) for (e++; e < n.length;) { const i = n[e]; if ("number" == typeof i) return -1; if (i === t) return e; e++ } return -1 }(t, n) } function zb(n, t, e = !1) { for (let i = 0; i < t.length; i++)if (tR(n, t[i], e)) return !0; return !1 } function Ub(n, t) { return n ? ":not(" + t.trim() + ")" : t } function aR(n) { let t = n[0], e = 1, i = 2, r = "", o = !1; for (; e < n.length;) { let s = n[e]; if ("string" == typeof s) if (2 & i) { const a = n[++e]; r += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & i ? r += "." + s : 4 & i && (r += " " + s); else "" !== r && !Yi(s) && (t += Ub(o, r), r = ""), i = s, o = o || !Yi(i); e++ } return "" !== r && (t += Ub(o, r)), t } const Le = {}; function St(n) { $b(st(), q(), Wn() + n, Vd()) } function $b(n, t, e, i) { if (!i) if (3 == (3 & t[2])) { const o = n.preOrderCheckHooks; null !== o && $d(t, o, e) } else { const o = n.preOrderHooks; null !== o && Gd(t, o, 0, e) } ko(e) } function cu(n, t) { return n << 17 | t << 2 } function Qi(n) { return n >> 17 & 32767 } function zp(n) { return 2 | n } function Kr(n) { return (131068 & n) >> 2 } function Up(n, t) { return -131069 & n | t << 2 } function $p(n) { return 1 | n } function t0(n, t) { const e = n.contentQueries; if (null !== e) for (let i = 0; i < e.length; i += 2) { const r = e[i], o = e[i + 1]; if (-1 !== o) { const s = n.data[o]; rp(r), s.contentQueries(2, t[o], o) } } } function Jl(n, t, e, i, r, o, s, a, l, d) { const h = t.blueprint.slice(); return h[0] = r, h[2] = 140 | i, gy(h), h[3] = h[15] = n, h[8] = e, h[10] = s || n && n[10], h[11] = a || n && n[11], h[12] = l || n && n[12] || null, h[9] = d || n && n[9] || null, h[6] = o, h[16] = 2 == t.type ? n[16] : h, h } function ma(n, t, e, i, r) { let o = n.data[t]; if (null === o) o = function (n, t, e, i, r) { const o = vy(), s = ep(), l = n.data[t] = function (n, t, e, i, r, o) { return { type: e, index: i, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: r, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, e, t, i, r); return null === n.firstChild && (n.firstChild = l), null !== o && (s ? null == o.child && null !== l.parent && (o.child = l) : null === o.next && (o.next = l)), l }(n, t, e, i, r), Oe.lFrame.inI18n && (o.flags |= 64); else if (64 & o.type) { o.type = e, o.value = i, o.attrs = r; const s = function () { const n = Oe.lFrame, t = n.currentTNode; return n.isParent ? t : t.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return pr(o, !0), o } function ga(n, t, e, i) { if (0 === e) return -1; const r = t.length; for (let o = 0; o < e; o++)t.push(i), n.blueprint.push(i), n.data.push(null); return r } function ec(n, t, e) { jd(t); try { const i = n.viewQuery; null !== i && lm(1, i, e); const r = n.template; null !== r && n0(n, t, r, 1, e), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && t0(n, t), n.staticViewQueries && lm(2, n.viewQuery, e); const o = n.components; null !== o && function (n, t) { for (let e = 0; e < t.length; e++)UR(n, t[e]) }(t, o) } catch (i) { throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), i } finally { t[2] &= -5, zd() } } function _a(n, t, e, i) { const r = t[2]; if (256 == (256 & r)) return; jd(t); const o = Vd(); try { gy(t), function (n) { Oe.lFrame.bindingIndex = n }(n.bindingStartIndex), null !== e && n0(n, t, e, 2, i); const s = 3 == (3 & r); if (!o) if (s) { const d = n.preOrderCheckHooks; null !== d && $d(t, d, null) } else { const d = n.preOrderHooks; null !== d && Gd(t, d, 0, null), op(t, 0) } if (function (n) { for (let t = Rp(n); null !== t; t = Op(t)) { if (!t[2]) continue; const e = t[9]; for (let i = 0; i < e.length; i++) { const r = e[i], o = r[3]; 0 == (1024 & r[2]) && Jf(o, 1), r[2] |= 1024 } } }(t), function (n) { for (let t = Rp(n); null !== t; t = Op(t))for (let e = 10; e < t.length; e++) { const i = t[e], r = i[1]; Zf(i) && _a(r, i, r.template, i[8]) } }(t), null !== n.contentQueries && t0(n, t), !o) if (s) { const d = n.contentCheckHooks; null !== d && $d(t, d) } else { const d = n.contentHooks; null !== d && Gd(t, d, 1), op(t, 1) } !function (n, t) { const e = n.hostBindingOpCodes; if (null !== e) try { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r < 0) ko(~r); else { const o = r, s = e[++i], a = e[++i]; Wk(s, o), a(2, t[o]) } } } finally { ko(-1) } }(n, t); const a = n.components; null !== a && function (n, t) { for (let e = 0; e < t.length; e++)zR(n, t[e]) }(t, a); const l = n.viewQuery; if (null !== l && lm(2, l, i), !o) if (s) { const d = n.viewCheckHooks; null !== d && $d(t, d) } else { const d = n.viewHooks; null !== d && Gd(t, d, 2), op(t, 2) } !0 === n.firstUpdatePass && (n.firstUpdatePass = !1), o || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, Jf(t[3], -1)) } finally { zd() } } function wR(n, t, e, i) { const r = t[10], o = !Vd(), s = my(t); try { o && !s && r.begin && r.begin(), s && ec(n, t, i), _a(n, t, e, i) } finally { o && !s && r.end && r.end() } } function n0(n, t, e, i, r) { const o = Wn(), s = 2 & i; try { ko(-1), s && t.length > 20 && $b(n, t, 20, Vd()), e(i, r) } finally { ko(o) } } function em(n, t, e) { !_y() || (function (n, t, e, i) { const r = e.directiveStart, o = e.directiveEnd; n.firstCreatePass || Ll(e, t), Nn(i, t); const s = e.initialInputs; for (let a = r; a < o; a++) { const l = n.data[a], d = ni(l); d && LR(t, e, l); const h = Bl(t, n, a, e); Nn(h, t), null !== s && BR(0, a - r, h, l, 0, s), d && (hi(e.index, t)[8] = h) } }(n, t, e, Ii(e, t)), 128 == (128 & e.flags) && function (n, t, e) { const i = e.directiveStart, r = e.directiveEnd, s = e.index, a = Oe.lFrame.currentDirectiveIndex; try { ko(s); for (let l = i; l < r; l++) { const d = n.data[l], h = t[l]; np(l), (null !== d.hostBindings || 0 !== d.hostVars || null !== d.hostAttrs) && h0(d, h) } } finally { ko(-1), np(a) } }(n, t, e)) } function tm(n, t, e = Ii) { const i = t.localNames; if (null !== i) { let r = t.index + 1; for (let o = 0; o < i.length; o += 2) { const s = i[o + 1], a = -1 === s ? e(t, n) : n[s]; n[r++] = a } } } function o0(n) { const t = n.tView; return null === t || t.incompleteFirstPass ? n.tView = hu(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts) : t } function hu(n, t, e, i, r, o, s, a, l, d) { const h = 20 + i, m = h + r, y = function (n, t) { const e = []; for (let i = 0; i < t; i++)e.push(i < n ? null : Le); return e }(h, m), D = "function" == typeof d ? d() : d; return y[1] = { type: n, blueprint: y, template: e, queries: null, viewQuery: a, declTNode: t, data: y.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: m, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: D, incompleteFirstPass: !1 } } function l0(n, t, e, i) { const r = v0(t); null === e ? r.push(i) : (r.push(e), n.firstCreatePass && y0(n).push(i, r.length - 1)) } function c0(n, t, e) { for (let i in n) if (n.hasOwnProperty(i)) { const r = n[i]; (e = null === e ? {} : e).hasOwnProperty(i) ? e[i].push(t, r) : e[i] = [t, r] } return e } function _i(n, t, e, i, r, o, s, a) { const l = Ii(t, e); let h, d = t.inputs; !a && null != d && (h = d[i]) ? (D0(n, e, h, i, r), Zs(t) && function (n, t) { const e = hi(t, n); 16 & e[2] || (e[2] |= 64) }(e, t.index)) : 3 & t.type && (i = function (n) { return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n }(i), r = null != s ? s(r, t.value || "", i) : r, Vt(o) ? o.setProperty(l, i, r) : ap(i) || (l.setProperty ? l.setProperty(i, r) : l[i] = r)) } function nm(n, t, e, i) { let r = !1; if (_y()) { const o = function (n, t, e) { const i = n.directiveRegistry; let r = null; if (i) for (let o = 0; o < i.length; o++) { const s = i[o]; zb(e, s.selectors, !1) && (r || (r = []), Kd(Ll(e, t), n, s.type), ni(s) ? (f0(n, e), r.unshift(s)) : r.push(s)) } return r }(n, t, e), s = null === i ? null : { "": -1 }; if (null !== o) { r = !0, p0(e, n.data.length, o.length); for (let h = 0; h < o.length; h++) { const m = o[h]; m.providersResolver && m.providersResolver(m) } let a = !1, l = !1, d = ga(n, t, o.length, null); for (let h = 0; h < o.length; h++) { const m = o[h]; e.mergedAttrs = Wd(e.mergedAttrs, m.hostAttrs), m0(n, e, t, d, m), NR(d, m, s), null !== m.contentQueries && (e.flags |= 8), (null !== m.hostBindings || null !== m.hostAttrs || 0 !== m.hostVars) && (e.flags |= 128); const y = m.type.prototype; !a && (y.ngOnChanges || y.ngOnInit || y.ngDoCheck) && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e.index), a = !0), !l && (y.ngOnChanges || y.ngDoCheck) && ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e.index), l = !0), d++ } !function (n, t) { const i = t.directiveEnd, r = n.data, o = t.attrs, s = []; let a = null, l = null; for (let d = t.directiveStart; d < i; d++) { const h = r[d], m = h.inputs, y = null === o || jb(t) ? null : VR(m, o); s.push(y), a = c0(m, d, a), l = c0(h.outputs, d, l) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = l }(n, e) } s && function (n, t, e) { if (t) { const i = n.localNames = []; for (let r = 0; r < t.length; r += 2) { const o = e[t[r + 1]]; if (null == o) throw new mn("301", `Export of name '${t[r + 1]}' not found!`); i.push(t[r], o) } } }(e, i, s) } return e.mergedAttrs = Wd(e.mergedAttrs, e.attrs), r } function u0(n, t, e, i, r, o) { const s = o.hostBindings; if (s) { let a = n.hostBindingOpCodes; null === a && (a = n.hostBindingOpCodes = []); const l = ~t.index; (function (n) { let t = n.length; for (; t > 0;) { const e = n[--t]; if ("number" == typeof e && e < 0) return e } return 0 })(a) != l && a.push(l), a.push(i, r, s) } } function h0(n, t) { null !== n.hostBindings && n.hostBindings(1, t) } function f0(n, t) { t.flags |= 2, (n.components || (n.components = [])).push(t.index) } function NR(n, t, e) { if (e) { if (t.exportAs) for (let i = 0; i < t.exportAs.length; i++)e[t.exportAs[i]] = n; ni(t) && (e[""] = n) } } function p0(n, t, e) { n.flags |= 1, n.directiveStart = t, n.directiveEnd = t + e, n.providerIndexes = t } function m0(n, t, e, i, r) { n.data[i] = r; const o = r.factory || (r.factory = Re(r.type)), s = new Fl(o, ni(r), null); n.blueprint[i] = s, e[i] = s, u0(n, t, 0, i, ga(n, e, r.hostVars, Le), r) } function LR(n, t, e) { const i = Ii(t, n), r = o0(e), o = n[10], s = fu(n, Jl(n, r, null, e.onPush ? 64 : 16, i, t, o, o.createRenderer(i, e), null, null)); n[t.index] = s } function yr(n, t, e, i, r, o) { const s = Ii(n, t); !function (n, t, e, i, r, o, s) { if (null == o) Vt(n) ? n.removeAttribute(t, r, e) : t.removeAttribute(r); else { const a = null == s ? Ae(o) : s(o, i || "", r); Vt(n) ? n.setAttribute(t, r, a, e) : e ? t.setAttributeNS(e, r, a) : t.setAttribute(r, a) } }(t[11], s, o, n.value, e, i, r) } function BR(n, t, e, i, r, o) { const s = o[t]; if (null !== s) { const a = i.setInput; for (let l = 0; l < s.length;) { const d = s[l++], h = s[l++], m = s[l++]; null !== a ? i.setInput(e, m, d, h) : e[h] = m } } } function VR(n, t) { let e = null, i = 0; for (; i < t.length;) { const r = t[i]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; n.hasOwnProperty(r) && (null === e && (e = []), e.push(r, n[r], t[i + 1])), i += 2 } else i += 2; else i += 4 } return e } function g0(n, t, e, i) { return new Array(n, !0, !1, t, null, 0, i, e, null, null) } function zR(n, t) { const e = hi(t, n); if (Zf(e)) { const i = e[1]; 80 & e[2] ? _a(i, e, i.template, e[8]) : e[5] > 0 && rm(e) } } function rm(n) { for (let i = Rp(n); null !== i; i = Op(i))for (let r = 10; r < i.length; r++) { const o = i[r]; if (1024 & o[2]) { const s = o[1]; _a(s, o, s.template, o[8]) } else o[5] > 0 && rm(o) } const e = n[1].components; if (null !== e) for (let i = 0; i < e.length; i++) { const r = hi(e[i], n); Zf(r) && r[5] > 0 && rm(r) } } function UR(n, t) { const e = hi(t, n), i = e[1]; (function (n, t) { for (let e = t.length; e < n.blueprint.length; e++)t.push(n.blueprint[e]) })(i, e), ec(i, e, e[8]) } function fu(n, t) { return n[13] ? n[14][4] = t : n[13] = t, n[14] = t, t } function om(n) { for (; n;) { n[2] |= 64; const t = Xl(n); if (Wr(n) && !t) return n; n = t } return null } function am(n, t, e) { const i = t[10]; i.begin && i.begin(); try { _a(n, t, n.template, e) } catch (r) { throw C0(t, r), r } finally { i.end && i.end() } } function _0(n) { !function (n) { for (let t = 0; t < n.components.length; t++) { const e = n.components[t], i = Sp(e), r = i[1]; wR(r, i, r.template, e) } }(n[8]) } function lm(n, t, e) { rp(0), t(n, e) } const YR = (() => Promise.resolve(null))(); function v0(n) { return n[7] || (n[7] = []) } function y0(n) { return n.cleanup || (n.cleanup = []) } function b0(n, t, e) { return (null === n || ni(n)) && (e = function (n) { for (; Array.isArray(n);) { if ("object" == typeof n[1]) return n; n = n[0] } return null }(e[t.index])), e[11] } function C0(n, t) { const e = n[9], i = e ? e.get(Io, null) : null; i && i.handleError(t) } function D0(n, t, e, i, r) { for (let o = 0; o < e.length;) { const s = e[o++], a = e[o++], l = t[s], d = n.data[s]; null !== d.setInput ? d.setInput(l, r, i, a) : l[a] = r } } function pu(n, t, e) { let i = e ? n.styles : null, r = e ? n.classes : null, o = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? o = a : 1 == o ? r = ur(r, a) : 2 == o && (i = ur(i, a + ": " + t[++s] + ";")) } e ? n.styles = i : n.stylesWithoutHost = i, e ? n.classes = r : n.classesWithoutHost = r } const cm = new V("INJECTOR", -1); class w0 { get(t, e = zl) { if (e === zl) { const i = new Error(`NullInjectorError: No provider for ${De(t)}!`); throw i.name = "NullInjectorError", i } return e } } const dm = new V("Set Injector scope."), tc = {}, XR = {}; let um; function x0() { return void 0 === um && (um = new w0), um } function M0(n, t = null, e = null, i) { const r = E0(n, t, e, i); return r._resolveInjectorDefTypes(), r } function E0(n, t = null, e = null, i) { return new ZR(n, e, t || x0(), i) } class ZR { constructor(t, e, i, r = null) { this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const o = []; e && mr(e, a => this.processProvider(a, t, e)), mr([t], a => this.processInjectorType(a, [], o)), this.records.set(cm, va(void 0, this)); const s = this.records.get(dm); this.scope = null != s ? s.value : null, this.source = r || ("object" == typeof t ? null : De(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = zl, i = Ie.Default) { this.assertNotDestroyed(); const r = Wy(this), o = Ti(void 0); try { if (!(i & Ie.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const l = ("function" == typeof (n = t) || "object" == typeof n && n instanceof V) && qs(t); a = l && this.injectableDefInScope(l) ? va(hm(t), tc) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (i & Ie.Self ? x0() : this.parent).get(t, e = i & Ie.Optional && e === zl ? null : e) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[eu] = s[eu] || []).unshift(De(t)), r) throw s; return function (n, t, e, i) { const r = n[eu]; throw t[qy] && r.unshift(t[qy]), n.message = function (n, t, e, i = null) { n = n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1) ? n.substr(2) : n; let r = De(t); if (Array.isArray(t)) r = t.map(De).join(" -> "); else if ("object" == typeof t) { let o = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : De(a))) } r = `{${o.join(", ")}}` } return `${e}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(MA, "\n  ")}` }("\n" + n.message, r, e, i), n.ngTokenPath = r, n[eu] = null, n }(s, t, "R3InjectorError", this.source) } throw s } finally { Ti(o), Wy(r) } var n } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((i, r) => t.push(De(r))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, i) { if (!(t = He(t))) return !1; let r = kl(t); const o = null == r && t.ngModule || void 0, s = void 0 === o ? t : o, a = -1 !== i.indexOf(s); if (void 0 !== o && (r = kl(o)), null == r) return !1; if (null != r.imports && !a) { let h; i.push(s); try { mr(r.imports, m => { this.processInjectorType(m, e, i) && (void 0 === h && (h = []), h.push(m)) }) } finally { } if (void 0 !== h) for (let m = 0; m < h.length; m++) { const { ngModule: y, providers: D } = h[m]; mr(D, M => this.processProvider(M, y, D || I)) } } this.injectorDefTypes.add(s); const l = Re(s) || (() => new s); this.records.set(s, va(l, tc)); const d = r.providers; if (null != d && !a) { const h = t; mr(d, m => this.processProvider(m, h, d)) } return void 0 !== o && void 0 !== t.providers } processProvider(t, e, i) { let r = ya(t = He(t)) ? t : He(t && t.provide); const o = (n = t, T0(n) ? va(void 0, n.useValue) : va(function (n, t, e) { let i; if (ya(n)) { const r = He(n); return Re(r) || hm(r) } if (T0(n)) i = () => He(n.useValue); else if (function (n) { return !(!n || !n.useFactory) }(n)) i = () => n.useFactory(..._p(n.deps || [])); else if (function (n) { return !(!n || !n.useExisting) }(n)) i = () => L(He(n.useExisting)); else { const r = He(n && (n.useClass || n.provide)); if (!function (n) { return !!n.deps }(n)) return Re(r) || hm(r); i = () => new r(..._p(n.deps)) } return i }(n), tc)); var n; if (ya(t) || !0 !== t.multi) this.records.get(r); else { let s = this.records.get(r); s || (s = va(void 0, tc, !0), s.factory = () => _p(s.multi), this.records.set(r, s)), r = t, s.multi.push(t) } this.records.set(r, o) } hydrate(t, e) { return e.value === tc && (e.value = XR, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value; var n } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = He(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function hm(n) { const t = qs(n), e = null !== t ? t.factory : Re(n); if (null !== e) return e; if (n instanceof V) throw new Error(`Token ${De(n)} is missing a \u0275prov definition.`); if (n instanceof Function) return function (n) { const t = n.length; if (t > 0) { const i = function (n, t) { const e = []; for (let i = 0; i < n; i++)e.push(t); return e }(t, "?"); throw new Error(`Can't resolve all parameters for ${De(n)}: (${i.join(", ")}).`) } const e = function (n) { const t = n && (n[es] || n[Ad]); if (t) { const e = function (n) { if (n.hasOwnProperty("name")) return n.name; const t = ("" + n).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(n); return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`), t } return null }(n); return null !== e ? () => e.factory(n) : () => new n }(n); throw new Error("unreachable") } function va(n, t, e = !1) { return { factory: n, value: t, multi: e ? [] : void 0 } } function T0(n) { return null !== n && "object" == typeof n && SA in n } function ya(n) { return "function" == typeof n } let qt = (() => { class n { static create(e, i) { var r; if (Array.isArray(e)) return M0({ name: "" }, i, e, ""); { const o = null !== (r = e.name) && void 0 !== r ? r : ""; return M0({ name: o }, e.parent, e.providers, o) } } } return n.THROW_IF_NOT_FOUND = zl, n.NULL = new w0, n.\u0275prov = X({ token: n, providedIn: "any", factory: () => L(cm) }), n.__NG_ELEMENT_ID__ = -1, n })(); function m1(n, t) { Ud(Sp(n)[1], on()) } function Z(n) { let t = function (n) { return Object.getPrototypeOf(n.prototype).constructor }(n.type), e = !0; const i = [n]; for (; t;) { let r; if (ni(n)) r = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new Error("Directives cannot inherit Components"); r = t.\u0275dir } if (r) { if (e) { i.push(r); const s = n; s.inputs = mm(n.inputs), s.declaredInputs = mm(n.declaredInputs), s.outputs = mm(n.outputs); const a = r.hostBindings; a && y1(n, a); const l = r.viewQuery, d = r.contentQueries; if (l && _1(n, l), d && v1(n, d), Hs(n.inputs, r.inputs), Hs(n.declaredInputs, r.declaredInputs), Hs(n.outputs, r.outputs), ni(r) && r.data.animation) { const h = n.data; h.animation = (h.animation || []).concat(r.data.animation) } } const o = r.features; if (o) for (let s = 0; s < o.length; s++) { const a = o[s]; a && a.ngInherit && a(n), a === Z && (e = !1) } } t = Object.getPrototypeOf(t) } !function (n) { let t = 0, e = null; for (let i = n.length - 1; i >= 0; i--) { const r = n[i]; r.hostVars = t += r.hostVars, r.hostAttrs = Wd(r.hostAttrs, e = Wd(e, r.hostAttrs)) } }(i) } function mm(n) { return n === $ ? {} : n === I ? [] : n } function _1(n, t) { const e = n.viewQuery; n.viewQuery = e ? (i, r) => { t(i, r), e(i, r) } : t } function v1(n, t) { const e = n.contentQueries; n.contentQueries = e ? (i, r, o) => { t(i, r, o), e(i, r, o) } : t } function y1(n, t) { const e = n.hostBindings; n.hostBindings = e ? (i, r) => { t(i, r), e(i, r) } : t } let mu = null; function ba() { if (!mu) { const n = x.Symbol; if (n && n.iterator) mu = n.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (mu = i) } } } return mu } function nc(n) { return !!gm(n) && (Array.isArray(n) || !(n instanceof Map) && ba() in n) } function gm(n) { return null !== n && ("function" == typeof n || "object" == typeof n) } function Ln(n, t, e) { return !Object.is(n[t], e) && (n[t] = e, !0) } function nt(n, t, e, i) { const r = q(); return Ln(r, na(), t) && (st(), yr(Ht(), r, n, t, e, i)), nt } function Zr(n, t, e, i, r, o, s, a) { const l = q(), d = st(), h = n + 20, m = d.firstCreatePass ? function (n, t, e, i, r, o, s, a, l) { const d = t.consts, h = ma(t, n, 4, s || null, To(d, a)); nm(t, e, h, To(d, l)), Ud(t, h); const m = h.tViews = hu(2, h, i, r, o, t.directiveRegistry, t.pipeRegistry, null, t.schemas, d); return null !== t.queries && (t.queries.template(t, h), m.queries = t.queries.embeddedTView(h)), h }(h, d, l, t, e, i, r, o, s) : d.data[h]; pr(m, !1); const y = l[11].createComment(""); au(d, l, y, m), Nn(y, l), fu(l, l[h] = g0(y, l, y, m)), Js(m) && em(d, l, m), null != s && tm(l, m, a) } function w(n, t = Ie.Default) { const e = q(); return null === e ? L(n, t) : Ny(on(), e, He(n), t) } function Ia() { throw new Error("invalid") } function Wt(n, t, e) { const i = q(); return Ln(i, na(), t) && _i(st(), Ht(), i, n, t, i[11], e, !1), Wt } function Cm(n, t, e, i, r) { const s = r ? "class" : "style"; D0(n, e, t.inputs[s], s, i) } function pe(n, t, e, i) { const r = q(), o = st(), s = 20 + n, a = r[11], l = r[s] = Fp(a, t, Oe.lFrame.currentNamespace), d = o.firstCreatePass ? function (n, t, e, i, r, o, s) { const a = t.consts, d = ma(t, n, 2, r, To(a, o)); return nm(t, e, d, To(a, s)), null !== d.attrs && pu(d, d.attrs, !1), null !== d.mergedAttrs && pu(d, d.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, d), d }(s, o, r, 0, t, e, i) : o.data[s]; pr(d, !0); const h = d.mergedAttrs; null !== h && qd(a, l, h); const m = d.classes; null !== m && jp(a, l, m); const y = d.styles; null !== y && Bb(a, l, y), 64 != (64 & d.flags) && au(o, r, l, d), 0 === Oe.lFrame.elementDepthCount && Nn(l, r), Oe.lFrame.elementDepthCount++, Js(d) && (em(o, r, d), function (n, t, e) { if (Xs(t)) { const r = t.directiveEnd; for (let o = t.directiveStart; o < r; o++) { const s = n.data[o]; s.contentQueries && s.contentQueries(1, e[o], o) } } }(o, d, r)), null !== i && tm(r, d) } function me() { let n = on(); ep() ? Oe.lFrame.isParent = !1 : (n = n.parent, pr(n, !1)); const t = n; Oe.lFrame.elementDepthCount--; const e = st(); e.firstCreatePass && (Ud(e, n), Xs(n) && e.queries.elementEnd(n)), null != t.classesWithoutHost && function (n) { return 0 != (16 & n.flags) }(t) && Cm(e, t, q(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function (n) { return 0 != (32 & n.flags) }(t) && Cm(e, t, q(), t.stylesWithoutHost, !1) } function vt(n, t, e, i) { pe(n, t, e, i), me() } function rc(n) { return !!n && "function" == typeof n.then } const Dm = function (n) { return !!n && "function" == typeof n.subscribe }; function wm(n, t) { const e = on(), i = q(), r = st(); return function (n, t, e, i, r, o, s, a) { const l = Js(i), h = n.firstCreatePass && y0(n), m = t[8], y = v0(t); let D = !0; if (3 & i.type || a) { const P = Ii(i, t), H = a ? a(P) : P, F = y.length, W = a ? ie => a(Xt(ie[i.index])) : i.index; if (Vt(e)) { let ie = null; if (!a && l && (ie = function (n, t, e, i) { const r = n.cleanup; if (null != r) for (let o = 0; o < r.length - 1; o += 2) { const s = r[o]; if (s === e && r[o + 1] === i) { const a = t[7], l = r[o + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (o += 2) } return null }(n, t, r, i.index)), null !== ie) (ie.__ngLastListenerFn__ || ie).__ngNextListenerFn__ = o, ie.__ngLastListenerFn__ = o, D = !1; else { o = xm(i, t, m, o, !1); const $e = e.listen(H, r, o); y.push(o, $e), h && h.push(r, W, F, F + 1) } } else o = xm(i, t, m, o, !0), H.addEventListener(r, o, s), y.push(o), h && h.push(r, W, F, s) } else o = xm(i, t, m, o, !1); const M = i.outputs; let k; if (D && null !== M && (k = M[r])) { const P = k.length; if (P) for (let H = 0; H < P; H += 2) { const Tt = t[k[H]][k[H + 1]].subscribe(o), Ot = y.length; y.push(o, Tt), h && h.push(r, i.index, Ot, -(Ot + 1)) } } }(r, i, b0(ip(r.data), e, i), e, n, t, !1), wm } function lC(n, t, e, i) { try { return !1 !== e(i) } catch (r) { return C0(n, r), !1 } } function xm(n, t, e, i, r) { return function o(s) { if (s === Function) return i; const a = 2 & n.flags ? hi(n.index, t) : t; 0 == (32 & t[2]) && om(a); let l = lC(t, 0, i, s), d = o.__ngNextListenerFn__; for (; d;)l = lC(t, 0, d, s) && l, d = d.__ngNextListenerFn__; return r && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function Po(n = 1) { return function (n) { return (Oe.lFrame.contextLView = function (n, t) { for (; n > 0;)t = t[15], n--; return t }(n, Oe.lFrame.contextLView))[8] }(n) } function vC(n, t, e, i, r) { const o = n[e + 1], s = null === t; let a = i ? Qi(o) : Kr(o), l = !1; for (; 0 !== a && (!1 === l || s);) { const h = n[a + 1]; eO(n[a], t) && (l = !0, n[a + 1] = i ? $p(h) : zp(h)), a = i ? Qi(h) : Kr(h) } l && (n[e + 1] = i ? zp(o) : $p(o)) } function eO(n, t) { return null === n || null == t || (Array.isArray(n) ? n[1] : n) === t || !(!Array.isArray(n) || "string" != typeof t) && da(n, t) >= 0 } function Dr(n, t, e) { return Xi(n, t, e, !1), Dr } function jt(n, t) { return Xi(n, t, null, !0), jt } function Xi(n, t, e, i) { const r = q(), o = st(), s = function (n) { const t = Oe.lFrame, e = t.bindingIndex; return t.bindingIndex = t.bindingIndex + n, e }(2); o.firstUpdatePass && function (n, t, e, i) { const r = n.data; if (null === r[e + 1]) { const o = r[Wn()], s = function (n, t) { return t >= n.expandoStartIndex }(n, e); (function (n, t) { return 0 != (n.flags & (t ? 16 : 32)) })(o, i) && null === t && !s && (t = !1), t = function (n, t, e, i) { const r = ip(n); let o = i ? t.residualClasses : t.residualStyles; if (null === r) 0 === (i ? t.classBindings : t.styleBindings) && (e = oc(e = Em(null, n, t, e, i), t.attrs, i), o = null); else { const s = t.directiveStylingLast; if (-1 === s || n[s] !== r) if (e = Em(r, n, t, e, i), null === o) { let l = function (n, t, e) { const i = e ? t.classBindings : t.styleBindings; if (0 !== Kr(i)) return n[Qi(i)] }(n, t, i); void 0 !== l && Array.isArray(l) && (l = Em(null, n, t, l[1], i), l = oc(l, t.attrs, i), function (n, t, e, i) { n[Qi(e ? t.classBindings : t.styleBindings)] = i }(n, t, i, l)) } else o = function (n, t, e) { let i; const r = t.directiveEnd; for (let o = 1 + t.directiveStylingLast; o < r; o++)i = oc(i, n[o].hostAttrs, e); return oc(i, t.attrs, e) }(n, t, i) } return void 0 !== o && (i ? t.residualClasses = o : t.residualStyles = o), e }(r, o, t, i), function (n, t, e, i, r, o) { let s = o ? t.classBindings : t.styleBindings, a = Qi(s), l = Kr(s); n[i] = e; let h, d = !1; if (Array.isArray(e)) { const m = e; h = m[1], (null === h || da(m, h) > 0) && (d = !0) } else h = e; if (r) if (0 !== l) { const y = Qi(n[a + 1]); n[i + 1] = cu(y, a), 0 !== y && (n[y + 1] = Up(n[y + 1], i)), n[a + 1] = function (n, t) { return 131071 & n | t << 17 }(n[a + 1], i) } else n[i + 1] = cu(a, 0), 0 !== a && (n[a + 1] = Up(n[a + 1], i)), a = i; else n[i + 1] = cu(l, 0), 0 === a ? a = i : n[l + 1] = Up(n[l + 1], i), l = i; d && (n[i + 1] = zp(n[i + 1])), vC(n, h, i, !0), vC(n, h, i, !1), function (n, t, e, i, r) { const o = r ? n.residualClasses : n.residualStyles; null != o && "string" == typeof t && da(o, t) >= 0 && (e[i + 1] = $p(e[i + 1])) }(t, h, n, i, o), s = cu(a, l), o ? t.classBindings = s : t.styleBindings = s }(r, o, t, e, s, i) } }(o, n, s, i), t !== Le && Ln(r, s, t) && function (n, t, e, i, r, o, s, a) { if (!(3 & t.type)) return; const l = n.data, d = l[a + 1]; bu(function (n) { return 1 == (1 & n) }(d) ? kC(l, t, e, r, Kr(d), s) : void 0) || (bu(o) || function (n) { return 2 == (2 & n) }(d) && (o = kC(l, null, e, r, a, s)), function (n, t, e, i, r) { const o = Vt(n); if (t) r ? o ? n.addClass(e, i) : e.classList.add(i) : o ? n.removeClass(e, i) : e.classList.remove(i); else { let s = -1 === i.indexOf("-") ? void 0 : gi.DashCase; if (null == r) o ? n.removeStyle(e, i, s) : e.style.removeProperty(i); else { const a = "string" == typeof r && r.endsWith("!important"); a && (r = r.slice(0, -10), s |= gi.Important), o ? n.setStyle(e, i, r, s) : e.style.setProperty(i, r, a ? "important" : "") } } }(i, s, function (n, t) { return Xt(t[n]) }(Wn(), e), r, o)) }(o, o.data[Wn()], r, r[11], n, r[s + 1] = function (n, t) { return null == n || ("string" == typeof t ? n += t : "object" == typeof n && (n = De(function (n) { return n instanceof class { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } ? n.changingThisBreaksApplicationSecurity : n }(n)))), n }(t, e), i, s) } function Em(n, t, e, i, r) { let o = null; const s = e.directiveEnd; let a = e.directiveStylingLast; for (-1 === a ? a = e.directiveStart : a++; a < s && (o = t[a], i = oc(i, o.hostAttrs, r), o !== n);)a++; return null !== n && (e.directiveStylingLast = a), i } function oc(n, t, e) { const i = e ? 1 : 2; let r = -1; if (null !== t) for (let o = 0; o < t.length; o++) { const s = t[o]; "number" == typeof s ? r = s : r === i && (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]), fi(n, s, !!e || t[++o])) } return void 0 === n ? null : n } function kC(n, t, e, i, r, o) { const s = null === t; let a; for (; r > 0;) { const l = n[r], d = Array.isArray(l), h = d ? l[1] : l, m = null === h; let y = e[r + 1]; y === Le && (y = m ? I : void 0); let D = m ? pp(y, i) : h === i ? y : void 0; if (d && !bu(D) && (D = pp(l, i)), bu(D) && (a = D, s)) return a; const M = n[r + 1]; r = s ? Qi(M) : Kr(M) } if (null !== t) { let l = o ? t.residualClasses : t.residualStyles; null != l && (a = pp(l, i)) } return a } function bu(n) { return void 0 !== n } function Mr(n, t = "") { const e = q(), i = st(), r = n + 20, o = i.firstCreatePass ? ma(i, r, 1, t, null) : i.data[r], s = e[r] = function (n, t) { return Vt(n) ? n.createText(t) : n.createTextNode(t) }(e[11], t); au(i, e, s, o), pr(o, !1) } function Jr(n, t, e) { const i = q(); return Ln(i, na(), t) && _i(st(), Ht(), i, n, t, i[11], e, !0), Jr } function Tm(n, t, e) { const i = q(); if (Ln(i, na(), t)) { const o = st(), s = Ht(); _i(o, s, i, n, t, b0(ip(o.data), s, i), e, !0) } return Tm } const ds = void 0; var FO = ["en", [["a", "p"], ["AM", "PM"], ds], [["AM", "PM"], ds, ds], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], ds, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], ds, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", ds, "{1} 'at' {0}", ds], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (n) { const e = Math.floor(Math.abs(n)), i = n.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === i ? 1 : 5 }]; let Oa = {}; function QC(n) { return n in Oa || (Oa[n] = x.ng && x.ng.common && x.ng.common.locales && x.ng.common.locales[n]), Oa[n] } var te = (() => ((te = te || {})[te.LocaleId = 0] = "LocaleId", te[te.DayPeriodsFormat = 1] = "DayPeriodsFormat", te[te.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", te[te.DaysFormat = 3] = "DaysFormat", te[te.DaysStandalone = 4] = "DaysStandalone", te[te.MonthsFormat = 5] = "MonthsFormat", te[te.MonthsStandalone = 6] = "MonthsStandalone", te[te.Eras = 7] = "Eras", te[te.FirstDayOfWeek = 8] = "FirstDayOfWeek", te[te.WeekendRange = 9] = "WeekendRange", te[te.DateFormat = 10] = "DateFormat", te[te.TimeFormat = 11] = "TimeFormat", te[te.DateTimeFormat = 12] = "DateTimeFormat", te[te.NumberSymbols = 13] = "NumberSymbols", te[te.NumberFormats = 14] = "NumberFormats", te[te.CurrencyCode = 15] = "CurrencyCode", te[te.CurrencySymbol = 16] = "CurrencySymbol", te[te.CurrencyName = 17] = "CurrencyName", te[te.Currencies = 18] = "Currencies", te[te.Directionality = 19] = "Directionality", te[te.PluralCase = 20] = "PluralCase", te[te.ExtraData = 21] = "ExtraData", te))(); const Cu = "en-US"; let KC = Cu; class CD { } class LP { resolveComponentFactory(t) { throw function (n) { const t = Error(`No component factory found for ${De(n)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = n, t }(t) } } let Fo = (() => { class n { } return n.NULL = new LP, n })(); function BP() { return Fa(on(), q()) } function Fa(n, t) { return new ke(Ii(n, t)) } let ke = (() => { class n { constructor(e) { this.nativeElement = e } } return n.__NG_ELEMENT_ID__ = BP, n })(); function VP(n) { return n instanceof ke ? n.nativeElement : n } class dc { } let zP = (() => { class n { } return n.\u0275prov = X({ token: n, providedIn: "root", factory: () => null }), n })(); class No { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const UP = new No("13.1.1"), Fm = {}; function Eu(n, t, e, i, r = !1) { for (; null !== e;) { const o = t[e.index]; if (null !== o && i.push(Xt(o)), $n(o)) for (let a = 10; a < o.length; a++) { const l = o[a], d = l[1].firstChild; null !== d && Eu(l[1], l, d, i) } const s = e.type; if (8 & s) Eu(n, t, e.child, i); else if (32 & s) { const a = Ip(e, t); let l; for (; l = a();)i.push(l) } else if (16 & s) { const a = Fb(t, e); if (Array.isArray(a)) i.push(...a); else { const l = Xl(t[16]); Eu(l[1], l, a, i, !0) } } e = r ? e.projectionNext : e.next } return i } class uc { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return Eu(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if ($n(t)) { const e = t[8], i = e ? e.indexOf(this) : -1; i > -1 && (Np(t, i), Zd(e, i)) } this._attachedToViewContainer = !1 } Eb(this._lView[1], this._lView) } onDestroy(t) { l0(this._lView[1], this._lView, null, t) } markForCheck() { om(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { am(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (n, t, e) { Hd(!0); try { am(n, t, e) } finally { Hd(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, Zl(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class $P extends uc { constructor(t) { super(t), this._view = t } detectChanges() { _0(this._view) } checkNoChanges() { !function (n) { Hd(!0); try { _0(n) } finally { Hd(!1) } }(this._view) } get context() { return null } } class wD extends Fo { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = ft(t); return new Nm(e, this.ngModule) } } function xD(n) { const t = []; for (let e in n) n.hasOwnProperty(e) && t.push({ propName: n[e], templateName: e }); return t } const qP = new V("SCHEDULER_TOKEN", { providedIn: "root", factory: () => vb }); class Nm extends CD { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(aR).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return xD(this.componentDef.inputs) } get outputs() { return xD(this.componentDef.outputs) } create(t, e, i, r) { const o = (r = r || this.ngModule) ? function (n, t) { return { get: (e, i, r) => { const o = n.get(e, Fm, r); return o !== Fm || i === Fm ? o : t.get(e, i, r) } } }(t, r.injector) : t, s = o.get(dc, py), a = o.get(zP, null), l = s.createRenderer(null, this.componentDef), d = this.componentDef.selectors[0][0] || "div", h = i ? function (n, t, e) { if (Vt(n)) return n.selectRootElement(t, e === p.ShadowDom); let i = "string" == typeof t ? n.querySelector(t) : t; return i.textContent = "", i }(l, i, this.componentDef.encapsulation) : Fp(s.createRenderer(null, this.componentDef), d, function (n) { const t = n.toLowerCase(); return "svg" === t ? hy : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(d)), m = this.componentDef.onPush ? 576 : 528, y = function (n, t) { return { components: [], scheduler: n || vb, clean: YR, playerHandler: t || null, flags: 0 } }(), D = hu(0, null, null, 1, 0, null, null, null, null, null), M = Jl(null, D, y, m, null, null, s, l, a, o); let k, P; jd(M); try { const H = function (n, t, e, i, r, o) { const s = e[1]; e[20] = n; const l = ma(s, 20, 2, "#host", null), d = l.mergedAttrs = t.hostAttrs; null !== d && (pu(l, d, !0), null !== n && (qd(r, n, d), null !== l.classes && jp(r, n, l.classes), null !== l.styles && Bb(r, n, l.styles))); const h = i.createRenderer(n, t), m = Jl(e, o0(t), null, t.onPush ? 64 : 16, e[20], l, i, h, o || null, null); return s.firstCreatePass && (Kd(Ll(l, e), s, t.type), f0(s, l), p0(l, e.length, 1)), fu(e, m), e[20] = m }(h, this.componentDef, M, s, l); if (h) if (i) qd(l, h, ["ng-version", UP.full]); else { const { attrs: F, classes: W } = function (n) { const t = [], e = []; let i = 1, r = 2; for (; i < n.length;) { let o = n[i]; if ("string" == typeof o) 2 === r ? "" !== o && t.push(o, n[++i]) : 8 === r && e.push(o); else { if (!Yi(r)) break; r = o } i++ } return { attrs: t, classes: e } }(this.componentDef.selectors[0]); F && qd(l, h, F), W && W.length > 0 && jp(l, h, W.join(" ")) } if (P = Xf(D, 20), void 0 !== e) { const F = P.projection = []; for (let W = 0; W < this.ngContentSelectors.length; W++) { const ie = e[W]; F.push(null != ie ? Array.from(ie) : null) } } k = function (n, t, e, i, r) { const o = e[1], s = function (n, t, e) { const i = on(); n.firstCreatePass && (e.providersResolver && e.providersResolver(e), m0(n, i, t, ga(n, t, 1, null), e)); const r = Bl(t, n, i.directiveStart, i); Nn(r, t); const o = Ii(i, t); return o && Nn(o, t), r }(o, e, t); if (i.components.push(s), n[8] = s, r && r.forEach(l => l(s, t)), t.contentQueries) { const l = on(); t.contentQueries(1, s, l.directiveStart) } const a = on(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (ko(a.index), u0(e[1], a, 0, a.directiveStart, a.directiveEnd, t), h0(t, s)), s }(H, this.componentDef, M, y, [m1]), ec(D, M, null) } finally { zd() } return new QP(this.componentType, k, Fa(P, M), M, P) } } class QP extends class { }{ constructor(t, e, i, r, o) { super(), this.location = i, this._rootLView = r, this._tNode = o, this.instance = e, this.hostView = this.changeDetectorRef = new $P(r), this.componentType = t } get injector() { return new oa(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } class to { } class MD { } const Na = new Map; class TD extends to { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new wD(this); const i = Gt(t); this._bootstrapComponents = vr(i.bootstrap), this._r3Injector = E0(t, e, [{ provide: to, useValue: this }, { provide: Fo, useValue: this.componentFactoryResolver }], De(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = qt.THROW_IF_NOT_FOUND, i = Ie.Default) { return t === qt || t === to || t === cm ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Lm extends MD { constructor(t) { super(), this.moduleType = t, null !== Gt(t) && function (n) { const t = new Set; !function e(i) { const r = Gt(i, !0), o = r.id; null !== o && (function (n, t, e) { if (t && t !== e) throw new Error(`Duplicate module registered for ${n} - ${De(t)} vs ${De(t.name)}`) }(o, Na.get(o), i), Na.set(o, i)); const s = vr(r.imports); for (const a of s) t.has(a) || (t.add(a), e(a)) }(n) }(t) } create(t) { return new TD(this.moduleType, t) } } function Bm(n) { return t => { setTimeout(n, void 0, t) } } const we = class extends se { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { var r, o, s; let a = t, l = e || (() => null), d = i; if (t && "object" == typeof t) { const m = t; a = null === (r = m.next) || void 0 === r ? void 0 : r.bind(m), l = null === (o = m.error) || void 0 === o ? void 0 : o.bind(m), d = null === (s = m.complete) || void 0 === s ? void 0 : s.bind(m) } this.__isAsync && (l = Bm(l), a && (a = Bm(a)), d && (d = Bm(d))); const h = super.subscribe({ next: a, error: l, complete: d }); return t instanceof ut && t.add(h), h } }; function mF() { return this._results[ba()]() } class pc { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = ba(), i = pc.prototype; i[e] || (i[e] = mF) } get changes() { return this._changes || (this._changes = new we) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const i = this; i.dirty = !1; const r = Ri(t); (this._changesDetected = !function (n, t, e) { if (n.length !== t.length) return !1; for (let i = 0; i < n.length; i++) { let r = n[i], o = t[i]; if (e && (r = e(r), o = e(o)), o !== r) return !1 } return !0 }(i._results, r, e)) && (i._results = r, i.length = r.length, i.last = r[this.length - 1], i.first = r[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; let cn = (() => { class n { } return n.__NG_ELEMENT_ID__ = vF, n })(); const gF = cn, _F = class extends gF { constructor(t, e, i) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, i = Jl(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); i[17] = this._declarationLView[this._declarationTContainer.index]; const o = this._declarationLView[19]; return null !== o && (i[19] = o.createEmbeddedView(e)), ec(e, i, t), new uc(i) } }; function vF() { return Tu(on(), q()) } function Tu(n, t) { return 4 & n.type ? new _F(t, n, Fa(n, t)) : null } let Zt = (() => { class n { } return n.__NG_ELEMENT_ID__ = yF, n })(); function yF() { return ND(on(), q()) } const bF = Zt, PD = class extends bF { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i } get element() { return Fa(this._hostTNode, this._hostLView) } get injector() { return new oa(this._hostTNode, this._hostLView) } get parentInjector() { const t = Qd(this._hostTNode, this._hostLView); if (Iy(t)) { const e = ra(t, this._hostLView), i = ia(t); return new oa(e[1].data[i + 8], e) } return new oa(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = FD(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, i) { const r = t.createEmbeddedView(e || {}); return this.insert(r, i), r } createComponent(t, e, i, r, o) { const s = t && !("function" == typeof t); let a; if (s) a = e; else { const m = e || {}; a = m.index, i = m.injector, r = m.projectableNodes, o = m.ngModuleRef } const l = s ? t : new Nm(ft(t)), d = i || this.parentInjector; if (!o && null == l.ngModule && d) { const m = d.get(to, null); m && (o = m) } const h = l.create(d, r, void 0, o); return this.insert(h.hostView, a), h } insert(t, e) { const i = t._lView, r = i[1]; if ($n(i[3])) { const h = this.indexOf(t); if (-1 !== h) this.detach(h); else { const m = i[3], y = new PD(m, m[6], m[3]); y.detach(y.indexOf(t)) } } const o = this._adjustIndex(e), s = this._lContainer; !function (n, t, e, i) { const r = 10 + i, o = e.length; i > 0 && (e[r - 1][4] = t), i < o - 10 ? (t[4] = e[r], jy(e, 10 + i, t)) : (e.push(t), t[4] = null), t[3] = e; const s = t[17]; null !== s && e !== s && function (n, t) { const e = n[9]; t[16] !== t[3][3][16] && (n[2] = !0), null === e ? n[9] = [t] : e.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(n), t[2] |= 128 }(r, i, s, o); const a = Vp(o, s), l = i[11], d = su(l, s[7]); return null !== d && function (n, t, e, i, r, o) { i[0] = r, i[6] = t, Zl(n, i, e, 1, r, o) }(r, s[6], l, i, d, a), t.attachToViewContainerRef(), jy(Vm(s), o, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = FD(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), i = Np(this._lContainer, e); i && (Zd(Vm(this._lContainer), e), Eb(i[1], i)) } detach(t) { const e = this._adjustIndex(t, -1), i = Np(this._lContainer, e); return i && null != Zd(Vm(this._lContainer), e) ? new uc(i) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function FD(n) { return n[8] } function Vm(n) { return n[8] || (n[8] = []) } function ND(n, t) { let e; const i = t[n.index]; if ($n(i)) e = i; else { let r; if (8 & n.type) r = Xt(i); else { const o = t[11]; r = o.createComment(""); const s = Ii(n, t); ss(o, su(o, s), r, function (n, t) { return Vt(n) ? n.nextSibling(t) : t.nextSibling }(o, s), !1) } t[n.index] = e = g0(i, t, r, n), fu(t, e) } return new PD(e, n, t) } class Hm { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Hm(this.queryList) } setDirty() { this.queryList.setDirty() } } class jm { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let o = 0; o < i; o++) { const s = e.getByIndex(o); r.push(this.queries[s.indexInDeclarationView].clone()) } return new jm(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== jD(t, e).matches && this.queries[e].setDirty() } } class LD { constructor(t, e, i = null) { this.predicate = t, this.flags = e, this.read = i } } class zm { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const r = null !== e ? e.length : 0, o = this.getByIndex(i).embeddedTView(t, r); o && (o.indexInDeclarationView = i, null !== e ? e.push(o) : e = [o]) } return null !== e ? new zm(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Um { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Um(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { const o = i[r]; this.matchTNodeWithReadOption(t, e, wF(e, o)), this.matchTNodeWithReadOption(t, e, Xd(e, t, o, !1, !1)) } else i === cn ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Xd(e, t, i, !1, !1)) } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const r = this.metadata.read; if (null !== r) if (r === ke || r === Zt || r === cn && 4 & e.type) this.addMatch(e.index, -2); else { const o = Xd(e, t, r, !1, !1); null !== o && this.addMatch(e.index, o) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function wF(n, t) { const e = n.localNames; if (null !== e) for (let i = 0; i < e.length; i += 2)if (e[i] === t) return e[i + 1]; return null } function MF(n, t, e, i) { return -1 === e ? function (n, t) { return 11 & n.type ? Fa(n, t) : 4 & n.type ? Tu(n, t) : null }(t, n) : -2 === e ? function (n, t, e) { return e === ke ? Fa(t, n) : e === cn ? Tu(t, n) : e === Zt ? ND(t, n) : void 0 }(n, t, i) : Bl(n, n[1], e, t) } function BD(n, t, e, i) { const r = t[19].queries[i]; if (null === r.matches) { const o = n.data, s = e.matches, a = []; for (let l = 0; l < s.length; l += 2) { const d = s[l]; a.push(d < 0 ? null : MF(t, o[d], s[l + 1], e.metadata.read)) } r.matches = a } return r.matches } function $m(n, t, e, i) { const r = n.queries.getByIndex(e), o = r.matches; if (null !== o) { const s = BD(n, t, r, e); for (let a = 0; a < o.length; a += 2) { const l = o[a]; if (l > 0) i.push(s[a / 2]); else { const d = o[a + 1], h = t[-l]; for (let m = 10; m < h.length; m++) { const y = h[m]; y[17] === y[3] && $m(y[1], y, d, i) } if (null !== h[9]) { const m = h[9]; for (let y = 0; y < m.length; y++) { const D = m[y]; $m(D[1], D, d, i) } } } } } return i } function ze(n) { const t = q(), e = st(), i = Cy(); rp(i + 1); const r = jD(e, i); if (n.dirty && my(t) === (2 == (2 & r.metadata.flags))) { if (null === r.matches) n.reset([]); else { const o = r.crossesNgTemplate ? $m(e, t, i, []) : BD(e, t, r, i); n.reset(o, VP), n.notifyOnChanges() } return !0 } return !1 } function Jt(n, t, e) { const i = st(); i.firstCreatePass && (function (n, t, e) { null === n.queries && (n.queries = new zm), n.queries.track(new Um(t, e)) }(i, new LD(n, t, e), -1), 2 == (2 & t) && (i.staticViewQueries = !0)), function (n, t, e) { const i = new pc(4 == (4 & e)); l0(n, t, i, i.destroy), null === t[19] && (t[19] = new jm), t[19].queries.push(new Hm(i)) }(i, q(), t) } function jD(n, t) { return n.queries.getByIndex(t) } function Iu(...n) { } const Ru = new V("Application Initializer"); let Ba = (() => { class n { constructor(e) { this.appInits = e, this.resolve = Iu, this.reject = Iu, this.initialized = !1, this.done = !1, this.donePromise = new Promise((i, r) => { this.resolve = i, this.reject = r }) } runInitializers() { if (this.initialized) return; const e = [], i = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let r = 0; r < this.appInits.length; r++) { const o = this.appInits[r](); if (rc(o)) e.push(o); else if (Dm(o)) { const s = new Promise((a, l) => { o.subscribe({ complete: a, error: l }) }); e.push(s) } } Promise.all(e).then(() => { i() }).catch(r => { this.reject(r) }), 0 === e.length && i(), this.initialized = !0 } } return n.\u0275fac = function (e) { return new (e || n)(L(Ru, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const gc = new V("AppId"), WF = { provide: gc, useFactory: function () { return `${Km()}${Km()}${Km()}` }, deps: [] }; function Km() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const rw = new V("Platform Initializer"), Ou = new V("Platform ID"), ow = new V("appBootstrapListener"); let sw = (() => { class n { log(e) { console.log(e) } warn(e) { console.warn(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const no = new V("LocaleId"), aw = new V("DefaultCurrencyCode"); class YF { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } let Pu = (() => { class n { compileModuleSync(e) { return new Lm(e) } compileModuleAsync(e) { return Promise.resolve(this.compileModuleSync(e)) } compileModuleAndAllComponentsSync(e) { const i = this.compileModuleSync(e), o = vr(Gt(e).declarations).reduce((s, a) => { const l = ft(a); return l && s.push(new Nm(l)), s }, []); return new YF(i, o) } compileModuleAndAllComponentsAsync(e) { return Promise.resolve(this.compileModuleAndAllComponentsSync(e)) } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const KF = (() => Promise.resolve(0))(); function Xm(n) { "undefined" == typeof Zone ? KF.then(() => { n && n.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", n) } class Xe { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new we(!1), this.onMicrotaskEmpty = new we(!1), this.onStable = new we(!1), this.onError = new we(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !i && e, r.shouldCoalesceRunChangeDetection = i, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function () { let n = x.requestAnimationFrame, t = x.cancelAnimationFrame; if ("undefined" != typeof Zone && n && t) { const e = n[Zone.__symbol__("OriginalDelegate")]; e && (n = e); const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function (n) { const t = () => { !function (n) { n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(x, () => { n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { n.lastRequestAnimationFrameId = -1, Jm(n), n.isCheckStableRunning = !0, Zm(n), n.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), n.fakeTopEventTask.invoke() }), Jm(n)) }(n) }; n._inner = n._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, i, r, o, s, a) => { try { return lw(n), e.invokeTask(r, o, s, a) } finally { (n.shouldCoalesceEventChangeDetection && "eventTask" === o.type || n.shouldCoalesceRunChangeDetection) && t(), cw(n) } }, onInvoke: (e, i, r, o, s, a, l) => { try { return lw(n), e.invoke(r, o, s, a, l) } finally { n.shouldCoalesceRunChangeDetection && t(), cw(n) } }, onHasTask: (e, i, r, o) => { e.hasTask(r, o), i === r && ("microTask" == o.change ? (n._hasPendingMicrotasks = o.microTask, Jm(n), Zm(n)) : "macroTask" == o.change && (n.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (e, i, r, o) => (e.handleError(r, o), n.runOutsideAngular(() => n.onError.emit(o)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Xe.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Xe.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, r) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + r, t, ZF, Iu, Iu); try { return o.runTask(s, e, i) } finally { o.cancelTask(s) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } } const ZF = {}; function Zm(n) { if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try { n._nesting++, n.onMicrotaskEmpty.emit(null) } finally { if (n._nesting--, !n.hasPendingMicrotasks) try { n.runOutsideAngular(() => n.onStable.emit(null)) } finally { n.isStable = !0 } } } function Jm(n) { n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId) } function lw(n) { n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null)) } function cw(n) { n._nesting--, Zm(n) } class tN { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new we, this.onMicrotaskEmpty = new we, this.onStable = new we, this.onError = new we } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, r) { return t.apply(e, i) } } let eg = (() => { class n { constructor(e) { this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Xe.assertNotInAngularZone(), Xm(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Xm(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, i, r) { let o = -1; i && i > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), e(this._didWork, this.getPendingTasks()) }, i)), this._callbacks.push({ doneCb: e, timeoutId: o, updateCb: r }) } whenStable(e, i, r) { if (r && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, i, r), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(e, i, r) { return [] } } return n.\u0275fac = function (e) { return new (e || n)(L(Xe)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), dw = (() => { class n { constructor() { this._applications = new Map, tg.addToWindow(this) } registerApplication(e, i) { this._applications.set(e, i) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, i = !0) { return tg.findTestabilityInTree(this, e, i) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class nN { addToWindow(t) { } findTestabilityInTree(t, e, i) { return null } } let Ji, tg = new nN; const uw = new V("AllowMultipleToken"); class hw { constructor(t, e) { this.name = t, this.token = e } } function fw(n, t, e = []) { const i = `Platform: ${t}`, r = new V(i); return (o = []) => { let s = pw(); if (!s || s.injector.get(uw, !1)) if (n) n(e.concat(o).concat({ provide: r, useValue: !0 })); else { const a = e.concat(o).concat({ provide: r, useValue: !0 }, { provide: dm, useValue: "platform" }); !function (n) { if (Ji && !Ji.destroyed && !Ji.injector.get(uw, !1)) throw new mn("400", ""); Ji = n.get(mw); const t = n.get(rw, null); t && t.forEach(e => e()) }(qt.create({ providers: a, name: i })) } return function (n) { const t = pw(); if (!t) throw new mn("401", ""); return t }() } } function pw() { return Ji && !Ji.destroyed ? Ji : null } let mw = (() => { class n { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, i) { const a = function (n, t) { let e; return e = "noop" === n ? new tN : ("zone.js" === n ? void 0 : n) || new Xe({ enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), e }(i ? i.ngZone : void 0, { ngZoneEventCoalescing: i && i.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: i && i.ngZoneRunCoalescing || !1 }), l = [{ provide: Xe, useValue: a }]; return a.run(() => { const d = qt.create({ providers: l, parent: this.injector, name: e.moduleType.name }), h = e.create(d), m = h.injector.get(Io, null); if (!m) throw new mn("402", ""); return a.runOutsideAngular(() => { const y = a.onError.subscribe({ next: D => { m.handleError(D) } }); h.onDestroy(() => { ng(this._modules, h), y.unsubscribe() }) }), function (n, t, e) { try { const i = e(); return rc(i) ? i.catch(r => { throw t.runOutsideAngular(() => n.handleError(r)), r }) : i } catch (i) { throw t.runOutsideAngular(() => n.handleError(i)), i } }(m, a, () => { const y = h.injector.get(Ba); return y.runInitializers(), y.donePromise.then(() => (function (n) { xn(n, "Expected localeId to be defined"), "string" == typeof n && (KC = n.toLowerCase().replace(/_/g, "-")) }(h.injector.get(no, Cu) || Cu), this._moduleDoBootstrap(h), h)) }) }) } bootstrapModule(e, i = []) { const r = gw({}, i); return function (n, t, e) { const i = new Lm(e); return Promise.resolve(i) }(0, 0, e).then(o => this.bootstrapModuleFactory(o, r)) } _moduleDoBootstrap(e) { const i = e.injector.get(Va); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => i.bootstrap(r)); else { if (!e.instance.ngDoBootstrap) throw new mn("403", ""); e.instance.ngDoBootstrap(i) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new mn("404", ""); this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return n.\u0275fac = function (e) { return new (e || n)(L(qt)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); function gw(n, t) { return Array.isArray(t) ? t.reduce(gw, n) : Object.assign(Object.assign({}, n), t) } let Va = (() => { class n { constructor(e, i, r, o, s) { this._zone = e, this._injector = i, this._exceptionHandler = r, this._componentFactoryResolver = o, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const a = new at(d => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { d.next(this._stable), d.complete() }) }), l = new at(d => { let h; this._zone.runOutsideAngular(() => { h = this._zone.onStable.subscribe(() => { Xe.assertNotInAngularZone(), Xm(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, d.next(!0)) }) }) }); const m = this._zone.onUnstable.subscribe(() => { Xe.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { d.next(!1) })) }); return () => { h.unsubscribe(), m.unsubscribe() } }); this.isStable = ei(a, l.pipe(function (n = {}) { const { connector: t = (() => new se), resetOnError: e = !0, resetOnComplete: i = !0, resetOnRefCountZero: r = !0 } = n; return o => { let s = null, a = null, l = null, d = 0, h = !1, m = !1; const y = () => { null == a || a.unsubscribe(), a = null }, D = () => { y(), s = l = null, h = m = !1 }, M = () => { const k = s; D(), null == k || k.unsubscribe() }; return lt((k, P) => { d++, !m && !h && y(); const H = l = null != l ? l : t(); P.add(() => { d--, 0 === d && !m && !h && (a = Vs(M, r)) }), H.subscribe(P), s || (s = new sr({ next: F => H.next(F), error: F => { m = !0, y(), a = Vs(D, e, F), H.error(F) }, complete: () => { h = !0, y(), a = Vs(D, i), H.complete() } }), Ut(k).subscribe(s)) })(o) } }())) } bootstrap(e, i) { if (!this._initStatus.done) throw new mn("405", ""); let r; r = e instanceof CD ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(r.componentType); const o = function (n) { return n.isBoundToModule }(r) ? void 0 : this._injector.get(to), a = r.create(qt.NULL, [], i || r.selector, o), l = a.location.nativeElement, d = a.injector.get(eg, null), h = d && a.injector.get(dw); return d && h && h.registerApplication(l, d), a.onDestroy(() => { this.detachView(a.hostView), ng(this.components, a), h && h.unregisterApplication(l) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new mn("101", ""); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e)) } finally { this._runningTick = !1 } } attachView(e) { const i = e; this._views.push(i), i.attachToAppRef(this) } detachView(e) { const i = e; ng(this._views, i), i.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(ow, []).concat(this._bootstrapListeners).forEach(r => r(e)) } ngOnDestroy() { this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return n.\u0275fac = function (e) { return new (e || n)(L(Xe), L(qt), L(Io), L(Fo), L(Ba)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); function ng(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } let vw = !0, _n = (() => { class n { } return n.__NG_ELEMENT_ID__ = fN, n })(); function fN(n) { return function (n, t, e) { if (Zs(n) && !e) { const i = hi(n.index, t); return new uc(i, i) } return 47 & n.type ? new uc(t[16], t) : null }(on(), q(), 16 == (16 & n)) } class Mw { constructor() { } supports(t) { return nc(t) } create(t) { return new bN(t) } } const yN = (n, t) => t; class bN { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || yN } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, i = this._removalsHead, r = 0, o = null; for (; e || i;) { const s = !i || e && e.currentIndex < Sw(i, r, o) ? e : i, a = Sw(s, r, o), l = s.currentIndex; if (s === i) r--, i = i._nextRemoved; else if (e = e._next, null == s.previousIndex) r++; else { o || (o = []); const d = a - r, h = l - r; if (d != h) { for (let y = 0; y < d; y++) { const D = y < o.length ? o[y] : o[y] = 0, M = D + y; h <= M && M < d && (o[y] = D + 1) } o[s.previousIndex] = h - d } } a !== l && t(s, a, l) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !nc(t)) throw new Error(`Error trying to diff '${De(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let r, o, s, e = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)o = t[a], s = this._trackByFn(a, o), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, o, s, a)), Object.is(e.item, o) || this._addIdentityChange(e, o)) : (e = this._mismatch(e, o, s, a), i = !0), e = e._next } else r = 0, function (n, t) { if (Array.isArray(n)) for (let e = 0; e < n.length; e++)t(n[e]); else { const e = n[ba()](); let i; for (; !(i = e.next()).done;)t(i.value) } }(t, a => { s = this._trackByFn(r, a), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, a, s, r)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, s, r), i = !0), e = e._next, r++ }), this.length = r; return this._truncate(e), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, r) { let o; return null === t ? o = this._itTail : (o = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, o, r)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, o, r)) : t = this._addAfter(new CN(e, i), o, r), t } _verifyReinsertion(t, e, i, r) { let o = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== o ? t = this._reinsertAfter(o, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, o = t._nextRemoved; return null === r ? this._removalsHead = o : r._nextRemoved = o, null === o ? this._removalsTail = r : o._prevRemoved = r, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Ew), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Ew), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class CN { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class DN { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup, i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class Ew { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e); i || (i = new DN, this.map.set(e, i)), i.add(t) } get(t, e) { const r = this.map.get(t); return r ? r.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Sw(n, t, e) { const i = n.previousIndex; if (null === i) return i; let r = 0; return e && i < e.length && (r = e[i]), i + t + r } class Tw { constructor() { } supports(t) { return t instanceof Map || gm(t) } create() { return new wN } } class wN { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || gm(t))) throw new Error(`Error trying to diff '${De(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (i, r) => { if (e && e.key === r) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next; else { const o = this._getOrCreateRecordForKey(r, i); e = this._insertBeforeOrAppend(e, o) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let i = e; null !== i; i = i._nextRemoved)i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const r = this._records.get(t); this._maybeAddToChanges(r, e); const o = r._prev, s = r._next; return o && (o._next = s), s && (s._prev = o), r._next = null, r._prev = null, r } const i = new xN(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class xN { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function kw() { return new yi([new Mw]) } let yi = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (null != i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || kw()), deps: [[n, new pi, new an]] } } find(e) { const i = this.factories.find(r => r.supports(e)); if (null != i) return i; throw new Error(`Cannot find a differ supporting object '${e}' of type '${function (n) { return n.name || typeof n }(e)}'`) } } return n.\u0275prov = X({ token: n, providedIn: "root", factory: kw }), n })(); function Aw() { return new Ha([new Tw]) } let Ha = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || Aw()), deps: [[n, new pi, new an]] } } find(e) { const i = this.factories.find(r => r.supports(e)); if (i) return i; throw new Error(`Cannot find a differ supporting object '${e}'`) } } return n.\u0275prov = X({ token: n, providedIn: "root", factory: Aw }), n })(); const EN = [new Tw], TN = new yi([new Mw]), kN = new Ha(EN), AN = fw(null, "core", [{ provide: Ou, useValue: "unknown" }, { provide: mw, deps: [qt] }, { provide: dw, deps: [] }, { provide: sw, deps: [] }]), FN = [{ provide: Va, useClass: Va, deps: [Xe, qt, Io, Fo, Ba] }, { provide: qP, deps: [Xe], useFactory: function (n) { let t = []; return n.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function (e) { t.push(e) } } }, { provide: Ba, useClass: Ba, deps: [[new an, Ru]] }, { provide: Pu, useClass: Pu, deps: [] }, WF, { provide: yi, useFactory: function () { return TN }, deps: [] }, { provide: Ha, useFactory: function () { return kN }, deps: [] }, { provide: no, useFactory: function (n) { return n || "undefined" != typeof $localize && $localize.locale || Cu }, deps: [[new Gl(no), new an, new pi]] }, { provide: aw, useValue: "USD" }]; let LN = (() => { class n { constructor(e) { } } return n.\u0275fac = function (e) { return new (e || n)(L(Va)) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: FN }), n })(), Nu = null; function Er() { return Nu } const Be = new V("DocumentToken"); let hs = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: function () { return L(Iw) }, providedIn: "platform" }), n })(); const zN = new V("Location Initialized"); let Iw = (() => { class n extends hs { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Er().getBaseHref(this._doc) } onPopState(e) { const i = Er().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e) } onHashChange(e) { const i = Er().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, i, r) { Rw() ? this._history.pushState(e, i, r) : this.location.hash = r } replaceState(e, i, r) { Rw() ? this._history.replaceState(e, i, r) : this.location.hash = r } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: function () { return new Iw(L(Be)) }, providedIn: "platform" }), n })(); function Rw() { return !!window.history.pushState } function ag(n, t) { if (0 == n.length) return t; if (0 == t.length) return n; let e = 0; return n.endsWith("/") && e++, t.startsWith("/") && e++, 2 == e ? n + t.substring(1) : 1 == e ? n + t : n + "/" + t } function Ow(n) { const t = n.match(/#|\?|$/), e = t && t.index || n.length; return n.slice(0, e - ("/" === n[e - 1] ? 1 : 0)) + n.slice(e) } function io(n) { return n && "?" !== n[0] ? "?" + n : n } let ja = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: function () { return function (n) { const t = L(Be).location; return new Pw(L(hs), t && t.origin || "") }() }, providedIn: "root" }), n })(); const lg = new V("appBaseHref"); let Pw = (() => { class n extends ja { constructor(e, i) { if (super(), this._platformLocation = e, this._removeListenerFns = [], null == i && (i = this._platformLocation.getBaseHrefFromDOM()), null == i) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = i } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return ag(this._baseHref, e) } path(e = !1) { const i = this._platformLocation.pathname + io(this._platformLocation.search), r = this._platformLocation.hash; return r && e ? `${i}${r}` : i } pushState(e, i, r, o) { const s = this.prepareExternalUrl(r + io(o)); this._platformLocation.pushState(e, i, s) } replaceState(e, i, r, o) { const s = this.prepareExternalUrl(r + io(o)); this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformLocation).historyGo) || void 0 === r || r.call(i, e) } } return n.\u0275fac = function (e) { return new (e || n)(L(hs), L(lg, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), GN = (() => { class n extends ja { constructor(e, i) { super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != i && (this._baseHref = i) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } path(e = !1) { let i = this._platformLocation.hash; return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i } prepareExternalUrl(e) { const i = ag(this._baseHref, e); return i.length > 0 ? "#" + i : i } pushState(e, i, r, o) { let s = this.prepareExternalUrl(r + io(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(e, i, s) } replaceState(e, i, r, o) { let s = this.prepareExternalUrl(r + io(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformLocation).historyGo) || void 0 === r || r.call(i, e) } } return n.\u0275fac = function (e) { return new (e || n)(L(hs), L(lg, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), _c = (() => { class n { constructor(e, i) { this._subject = new we, this._urlChangeListeners = [], this._platformStrategy = e; const r = this._platformStrategy.getBaseHref(); this._platformLocation = i, this._baseHref = Ow(Fw(r)), this._platformStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } path(e = !1) { return this.normalize(this._platformStrategy.path(e)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, i = "") { return this.path() == this.normalize(e + io(i)) } normalize(e) { return n.stripTrailingSlash(function (n, t) { return n && t.startsWith(n) ? t.substring(n.length) : t }(this._baseHref, Fw(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e) } go(e, i = "", r = null) { this._platformStrategy.pushState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + io(i)), r) } replaceState(e, i = "", r = null) { this._platformStrategy.replaceState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + io(i)), r) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformStrategy).historyGo) || void 0 === r || r.call(i, e) } onUrlChange(e) { this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => { this._notifyUrlChangeListeners(i.url, i.state) })) } _notifyUrlChangeListeners(e = "", i) { this._urlChangeListeners.forEach(r => r(e, i)) } subscribe(e, i, r) { return this._subject.subscribe({ next: e, error: i, complete: r }) } } return n.normalizeQueryParams = io, n.joinWithSlash = ag, n.stripTrailingSlash = Ow, n.\u0275fac = function (e) { return new (e || n)(L(ja), L(hs)) }, n.\u0275prov = X({ token: n, factory: function () { return new _c(L(ja), L(hs)) }, providedIn: "root" }), n })(); function Fw(n) { return n.replace(/\/index.html$/, "") } var en = (() => ((en = en || {})[en.Zero = 0] = "Zero", en[en.One = 1] = "One", en[en.Two = 2] = "Two", en[en.Few = 3] = "Few", en[en.Many = 4] = "Many", en[en.Other = 5] = "Other", en))(); const eL = function (n) { return function (n) { const t = function (n) { return n.toLowerCase().replace(/_/g, "-") }(n); let e = QC(t); if (e) return e; const i = t.split("-")[0]; if (e = QC(i), e) return e; if ("en" === i) return FO; throw new Error(`Missing locale data for the locale "${n}".`) }(n)[te.PluralCase] }; class qu { } let kL = (() => { class n extends qu { constructor(e) { super(), this.locale = e } getPluralCategory(e, i) { switch (eL(i || this.locale)(e)) { case en.Zero: return "zero"; case en.One: return "one"; case en.Two: return "two"; case en.Few: return "few"; case en.Many: return "many"; default: return "other" } } } return n.\u0275fac = function (e) { return new (e || n)(L(no)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class _g { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let Wu = (() => { class n { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(e) { this._ngSwitch = e, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(e) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(e) } _matchCase(e) { const i = e == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || i, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), i } _updateDefaultCases(e) { if (this._defaultViews && e !== this._defaultUsed) { this._defaultUsed = e; for (let i = 0; i < this._defaultViews.length; i++)this._defaultViews[i].enforceState(e) } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275dir = z({ type: n, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), n })(), Ww = (() => { class n { constructor(e, i, r) { this.ngSwitch = r, r._addCase(), this._view = new _g(e, i) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return n.\u0275fac = function (e) { return new (e || n)(w(Zt), w(cn), w(Wu, 9)) }, n.\u0275dir = z({ type: n, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), n })(), un = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [{ provide: qu, useClass: kL }] }), n })(); const Xw = "browser"; let dB = (() => { class n { } return n.\u0275prov = X({ token: n, providedIn: "root", factory: () => new uB(L(Be), window) }), n })(); class uB { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (n, t) { const e = n.getElementById(t) || n.getElementsByName(t)[0]; if (e) return e; if ("function" == typeof n.createTreeWalker && n.body && (n.body.createShadowRoot || n.body.attachShadow)) { const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT); let r = i.currentNode; for (; r;) { const o = r.shadowRoot; if (o) { const s = o.getElementById(t) || o.querySelector(`[name="${t}"]`); if (s) return s } r = i.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), i = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, o = this.offset(); this.window.scrollTo(i - o[0], r - o[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = Zw(this.window.history) || Zw(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function Zw(n) { return Object.getOwnPropertyDescriptor(n, "scrollRestoration") } class bg extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var n; n = new bg, Nu || (Nu = n) } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (bc = bc || document.querySelector("base"), bc ? bc.getAttribute("href") : null); return null == e ? null : function (n) { Yu = Yu || document.createElement("a"), Yu.setAttribute("href", n); const t = Yu.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(e) } resetBaseElement() { bc = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return function (n, t) { t = encodeURIComponent(t); for (const e of n.split(";")) { const i = e.indexOf("="), [r, o] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]; if (r.trim() === t) return decodeURIComponent(o) } return null }(document.cookie, t) } } let Yu, bc = null; const Jw = new V("TRANSITION_ID"), vB = [{ provide: Ru, useFactory: function (n, t, e) { return () => { e.get(Ba).donePromise.then(() => { const i = Er(), r = t.querySelectorAll(`style[ng-transition="${n}"]`); for (let o = 0; o < r.length; o++)i.remove(r[o]) }) } }, deps: [Jw, Be, qt], multi: !0 }]; class Cg { static init() { var n; n = new Cg, tg = n } addToWindow(t) { x.getAngularTestability = (i, r = !0) => { const o = t.findTestabilityInTree(i, r); if (null == o) throw new Error("Could not find testability for element."); return o }, x.getAllAngularTestabilities = () => t.getAllTestabilities(), x.getAllAngularRootElements = () => t.getAllRootElements(), x.frameworkStabilizers || (x.frameworkStabilizers = []), x.frameworkStabilizers.push(i => { const r = x.getAllAngularTestabilities(); let o = r.length, s = !1; const a = function (l) { s = s || l, o--, 0 == o && i(s) }; r.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(t, e, i) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : i ? Er().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let yB = (() => { class n { build() { return new XMLHttpRequest } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const Qu = new V("EventManagerPlugins"); let Ku = (() => { class n { constructor(e, i) { this._zone = i, this._eventNameToPlugin = new Map, e.forEach(r => r.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, i, r) { return this._findPluginFor(i).addEventListener(e, i, r) } addGlobalEventListener(e, i, r) { return this._findPluginFor(i).addGlobalEventListener(e, i, r) } getZone() { return this._zone } _findPluginFor(e) { const i = this._eventNameToPlugin.get(e); if (i) return i; const r = this._plugins; for (let o = 0; o < r.length; o++) { const s = r[o]; if (s.supports(e)) return this._eventNameToPlugin.set(e, s), s } throw new Error(`No event manager plugin found for event ${e}`) } } return n.\u0275fac = function (e) { return new (e || n)(L(Qu), L(Xe)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class ex { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const r = Er().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, i) } } let tx = (() => { class n { constructor() { this._stylesSet = new Set } addStyles(e) { const i = new Set; e.forEach(r => { this._stylesSet.has(r) || (this._stylesSet.add(r), i.add(r)) }), this.onStylesAdded(i) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), Cc = (() => { class n extends tx { constructor(e) { super(), this._doc = e, this._hostNodes = new Map, this._hostNodes.set(e.head, []) } _addStylesToHost(e, i, r) { e.forEach(o => { const s = this._doc.createElement("style"); s.textContent = o, r.push(i.appendChild(s)) }) } addHost(e) { const i = []; this._addStylesToHost(this._stylesSet, e, i), this._hostNodes.set(e, i) } removeHost(e) { const i = this._hostNodes.get(e); i && i.forEach(nx), this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach((i, r) => { this._addStylesToHost(e, r, i) }) } ngOnDestroy() { this._hostNodes.forEach(e => e.forEach(nx)) } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); function nx(n) { Er().remove(n) } const Dg = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, wg = /%COMP%/g; function Xu(n, t, e) { for (let i = 0; i < t.length; i++) { let r = t[i]; Array.isArray(r) ? Xu(n, r, e) : (r = r.replace(wg, n), e.push(r)) } return e } function ox(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === n(t) && (t.preventDefault(), t.returnValue = !1) } } let Zu = (() => { class n { constructor(e, i, r) { this.eventManager = e, this.sharedStylesHost = i, this.appId = r, this.rendererByCompId = new Map, this.defaultRenderer = new xg(e) } createRenderer(e, i) { if (!e || !i) return this.defaultRenderer; switch (i.encapsulation) { case p.Emulated: { let r = this.rendererByCompId.get(i.id); return r || (r = new MB(this.eventManager, this.sharedStylesHost, i, this.appId), this.rendererByCompId.set(i.id, r)), r.applyToHost(e), r } case 1: case p.ShadowDom: return new EB(this.eventManager, this.sharedStylesHost, e, i); default: if (!this.rendererByCompId.has(i.id)) { const r = Xu(i.id, i.styles, []); this.sharedStylesHost.addStyles(r), this.rendererByCompId.set(i.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return n.\u0275fac = function (e) { return new (e || n)(L(Ku), L(Cc), L(gc)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class xg { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, e) { return e ? document.createElementNS(Dg[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, i) { t && t.insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, r) { if (r) { e = r + ":" + e; const o = Dg[r]; o ? t.setAttributeNS(o, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const r = Dg[i]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, r) { r & (gi.DashCase | gi.Important) ? t.style.setProperty(e, i, r & gi.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & gi.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, ox(i)) : this.eventManager.addEventListener(t, e, ox(i)) } } class MB extends xg { constructor(t, e, i, r) { super(t), this.component = i; const o = Xu(r + "-" + i.id, i.styles, []); e.addStyles(o), this.contentAttr = "_ngcontent-%COMP%".replace(wg, r + "-" + i.id), this.hostAttr = "_nghost-%COMP%".replace(wg, r + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class EB extends xg { constructor(t, e, i, r) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const o = Xu(r.id, r.styles, []); for (let s = 0; s < o.length; s++) { const a = document.createElement("style"); a.textContent = o[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let SB = (() => { class n extends ex { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, i, r) { return e.addEventListener(i, r, !1), () => this.removeEventListener(e, i, r) } removeEventListener(e, i, r) { return e.removeEventListener(i, r) } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const ax = ["alt", "control", "meta", "shift"], kB = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, lx = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, AB = { alt: n => n.altKey, control: n => n.ctrlKey, meta: n => n.metaKey, shift: n => n.shiftKey }; let IB = (() => { class n extends ex { constructor(e) { super(e) } supports(e) { return null != n.parseEventName(e) } addEventListener(e, i, r) { const o = n.parseEventName(i), s = n.eventCallback(o.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Er().onAndCancel(e, o.domEventName, s)) } static parseEventName(e) { const i = e.toLowerCase().split("."), r = i.shift(); if (0 === i.length || "keydown" !== r && "keyup" !== r) return null; const o = n._normalizeKey(i.pop()); let s = ""; if (ax.forEach(l => { const d = i.indexOf(l); d > -1 && (i.splice(d, 1), s += l + ".") }), s += o, 0 != i.length || 0 === o.length) return null; const a = {}; return a.domEventName = r, a.fullKey = s, a } static getEventFullKey(e) { let i = "", r = function (n) { let t = n.key; if (null == t) { if (t = n.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === n.location && lx.hasOwnProperty(t) && (t = lx[t])) } return kB[t] || t }(e); return r = r.toLowerCase(), " " === r ? r = "space" : "." === r && (r = "dot"), ax.forEach(o => { o != r && AB[o](e) && (i += o + ".") }), i += r, i } static eventCallback(e, i, r) { return o => { n.getEventFullKey(o) === e && r.runGuarded(() => i(o)) } } static _normalizeKey(e) { return "esc" === e ? "escape" : e } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const NB = fw(AN, "browser", [{ provide: Ou, useValue: Xw }, { provide: rw, useValue: function () { bg.makeCurrent(), Cg.init() }, multi: !0 }, { provide: Be, useFactory: function () { return n = document, Qf = n, document; var n }, deps: [] }]), LB = [{ provide: dm, useValue: "root" }, { provide: Io, useFactory: function () { return new Io }, deps: [] }, { provide: Qu, useClass: SB, multi: !0, deps: [Be, Xe, Ou] }, { provide: Qu, useClass: IB, multi: !0, deps: [Be] }, { provide: Zu, useClass: Zu, deps: [Ku, Cc, gc] }, { provide: dc, useExisting: Zu }, { provide: tx, useExisting: Cc }, { provide: Cc, useClass: Cc, deps: [Be] }, { provide: eg, useClass: eg, deps: [Xe] }, { provide: Ku, useClass: Ku, deps: [Qu, Xe] }, { provide: class { }, useClass: yB, deps: [] }]; let cx = (() => { class n { constructor(e) { if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: n, providers: [{ provide: gc, useValue: e.appId }, { provide: Jw, useExisting: gc }, vB] } } } return n.\u0275fac = function (e) { return new (e || n)(L(n, 12)) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: LB, imports: [un, LN] }), n })(); function ge(...n) { return Ut(n, zr(n)) } "undefined" != typeof window && window; class ri extends se { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return !e.closed && t.next(this._value), e } getValue() { const { hasError: t, thrownError: e, _value: i } = this; if (t) throw e; return this._throwIfClosed(), i } next(t) { super.next(this._value = t) } } const { isArray: YB } = Array, { getPrototypeOf: QB, prototype: KB, keys: XB } = Object; const { isArray: JB } = Array; function Sg(n) { return Fe(t => function (n, t) { return JB(t) ? n(...t) : n(t) }(n, t)) } function tV(...n) { const t = zr(n), e = function (n) { return Qe(dr(n)) ? n.pop() : void 0 }(n), { args: i, keys: r } = function (n) { if (1 === n.length) { const t = n[0]; if (YB(t)) return { args: t, keys: null }; if (function (n) { return n && "object" == typeof n && QB(n) === KB }(t)) { const e = XB(t); return { args: e.map(i => t[i]), keys: e } } } return { args: n, keys: null } }(n); if (0 === i.length) return Ut([], t); const o = new at(function (n, t, e = $i) { return i => { mx(t, () => { const { length: r } = n, o = new Array(r); let s = r, a = r; for (let l = 0; l < r; l++)mx(t, () => { const d = Ut(n[l], t); let h = !1; d.subscribe(new wt(i, m => { o[l] = m, h || (h = !0, a--), a || i.next(e(o.slice())) }, () => { --s || i.complete() })) }, i) }, i) } }(i, t, r ? s => function (n, t) { return n.reduce((e, i, r) => (e[i] = t[r], e), {}) }(r, s) : $i)); return e ? o.pipe(Sg(e)) : o } function mx(n, t, e) { n ? Gi(e, n, t) : t() } const Ju = Ee(n => function () { n(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function eh(...n) { return wo(1)(Ut(n, zr(n))) } function th(n) { return new at(t => { On(n()).subscribe(t) }) } function gx() { return lt((n, t) => { let e = null; n._refCount++; const i = new wt(t, void 0, void 0, void 0, () => { if (!n || n._refCount <= 0 || 0 < --n._refCount) return void (e = null); const r = n._connection, o = e; e = null, r && (!o || r === o) && r.unsubscribe(), t.unsubscribe() }); n.subscribe(i), i.closed || (e = n.connect()) }) } class rV extends at { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, gl(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, null == t || t.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new ut; const e = this.getSubject(); t.add(this.source.subscribe(new wt(e, void 0, () => { this._teardown(), e.complete() }, i => { this._teardown(), e.error(i) }, () => this._teardown()))), t.closed && (this._connection = null, t = ut.EMPTY) } return t } refCount() { return gx()(this) } } function oo(n, t) { return lt((e, i) => { let r = null, o = 0, s = !1; const a = () => s && !r && i.complete(); e.subscribe(new wt(i, l => { null == r || r.unsubscribe(); let d = 0; const h = o++; On(n(l, h)).subscribe(r = new wt(i, m => i.next(t ? t(l, m, h, d++) : m), () => { r = null, a() })) }, () => { s = !0, a() })) }) } function Dc(...n) { const t = zr(n); return lt((e, i) => { (t ? eh(n, e, t) : eh(n, e)).subscribe(i) }) } function oV(n, t, e, i, r) { return (o, s) => { let a = e, l = t, d = 0; o.subscribe(new wt(s, h => { const m = d++; l = a ? n(l, h, m) : (a = !0, h), i && s.next(l) }, r && (() => { a && s.next(l), s.complete() }))) } } function _x(n, t) { return lt(oV(n, t, arguments.length >= 2, !0)) } function An(n, t) { return lt((e, i) => { let r = 0; e.subscribe(new wt(i, o => n.call(t, o, r++) && i.next(o))) }) } function so(n) { return lt((t, e) => { let o, i = null, r = !1; i = t.subscribe(new wt(e, void 0, void 0, s => { o = On(n(s, so(n)(t))), i ? (i.unsubscribe(), i = null, o.subscribe(e)) : r = !0 })), r && (i.unsubscribe(), i = null, o.subscribe(e)) }) } function za(n, t) { return Qe(t) ? Ft(n, t, 1) : Ft(n, 1) } function Tg(n) { return n <= 0 ? () => qi : lt((t, e) => { let i = []; t.subscribe(new wt(e, r => { i.push(r), n < i.length && i.shift() }, () => { for (const r of i) e.next(r); e.complete() }, void 0, () => { i = null })) }) } function vx(n = sV) { return lt((t, e) => { let i = !1; t.subscribe(new wt(e, r => { i = !0, e.next(r) }, () => i ? e.complete() : e.error(n()))) }) } function sV() { return new Ju } function yx(n) { return lt((t, e) => { let i = !1; t.subscribe(new wt(e, r => { i = !0, e.next(r) }, () => { i || e.next(n), e.complete() })) }) } function Ua(n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? An((r, o) => n(r, o, i)) : $i, pn(1), e ? yx(t) : vx(() => new Ju)) } function vn(n, t, e) { const i = Qe(n) || t || e ? { next: n, error: t, complete: e } : n; return i ? lt((r, o) => { var s; null === (s = i.subscribe) || void 0 === s || s.call(i); let a = !0; r.subscribe(new wt(o, l => { var d; null === (d = i.next) || void 0 === d || d.call(i, l), o.next(l) }, () => { var l; a = !1, null === (l = i.complete) || void 0 === l || l.call(i), o.complete() }, l => { var d; a = !1, null === (d = i.error) || void 0 === d || d.call(i, l), o.error(l) }, () => { var l, d; a && (null === (l = i.unsubscribe) || void 0 === l || l.call(i)), null === (d = i.finalize) || void 0 === d || d.call(i) })) }) : $i } class ao { constructor(t, e) { this.id = t, this.url = e } } class kg extends ao { constructor(t, e, i = "imperative", r = null) { super(t, e), this.navigationTrigger = i, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class wc extends ao { constructor(t, e, i) { super(t, e), this.urlAfterRedirects = i } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Cx extends ao { constructor(t, e, i) { super(t, e), this.reason = i } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class lV extends ao { constructor(t, e, i) { super(t, e), this.error = i } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class cV extends ao { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class dV extends ao { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class uV extends ao { constructor(t, e, i, r, o) { super(t, e), this.urlAfterRedirects = i, this.state = r, this.shouldActivate = o } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class hV extends ao { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class fV extends ao { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Dx { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class wx { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class pV { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class mV { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class gV { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class _V { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class xx { constructor(t, e, i) { this.routerEvent = t, this.position = e, this.anchor = i } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const Ze = "primary"; class vV { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function $a(n) { return new vV(n) } const Mx = "ngNavigationCancelingError"; function Ag(n) { const t = Error("NavigationCancelingError: " + n); return t[Mx] = !0, t } function bV(n, t, e) { const i = e.path.split("/"); if (i.length > n.length || "full" === e.pathMatch && (t.hasChildren() || i.length < n.length)) return null; const r = {}; for (let o = 0; o < i.length; o++) { const s = i[o], a = n[o]; if (s.startsWith(":")) r[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: n.slice(0, i.length), posParams: r } } function Sr(n, t) { const e = n ? Object.keys(n) : void 0, i = t ? Object.keys(t) : void 0; if (!e || !i || e.length != i.length) return !1; let r; for (let o = 0; o < e.length; o++)if (r = e[o], !Ex(n[r], t[r])) return !1; return !0 } function Ex(n, t) { if (Array.isArray(n) && Array.isArray(t)) { if (n.length !== t.length) return !1; const e = [...n].sort(), i = [...t].sort(); return e.every((r, o) => i[o] === r) } return n === t } function Sx(n) { return Array.prototype.concat.apply([], n) } function Tx(n) { return n.length > 0 ? n[n.length - 1] : null } function In(n, t) { for (const e in n) n.hasOwnProperty(e) && t(n[e], e) } function Tr(n) { return Dm(n) ? n : rc(n) ? Ut(Promise.resolve(n)) : ge(n) } const wV = { exact: function Ix(n, t, e) { if (!ps(n.segments, t.segments) || !nh(n.segments, t.segments, e) || n.numberOfChildren !== t.numberOfChildren) return !1; for (const i in t.children) if (!n.children[i] || !Ix(n.children[i], t.children[i], e)) return !1; return !0 }, subset: Rx }, kx = { exact: function (n, t) { return Sr(n, t) }, subset: function (n, t) { return Object.keys(t).length <= Object.keys(n).length && Object.keys(t).every(e => Ex(n[e], t[e])) }, ignored: () => !0 }; function Ax(n, t, e) { return wV[e.paths](n.root, t.root, e.matrixParams) && kx[e.queryParams](n.queryParams, t.queryParams) && !("exact" === e.fragment && n.fragment !== t.fragment) } function Rx(n, t, e) { return Ox(n, t, t.segments, e) } function Ox(n, t, e, i) { if (n.segments.length > e.length) { const r = n.segments.slice(0, e.length); return !(!ps(r, e) || t.hasChildren() || !nh(r, e, i)) } if (n.segments.length === e.length) { if (!ps(n.segments, e) || !nh(n.segments, e, i)) return !1; for (const r in t.children) if (!n.children[r] || !Rx(n.children[r], t.children[r], i)) return !1; return !0 } { const r = e.slice(0, n.segments.length), o = e.slice(n.segments.length); return !!(ps(n.segments, r) && nh(n.segments, r, i) && n.children[Ze]) && Ox(n.children[Ze], t, o, i) } } function nh(n, t, e) { return t.every((i, r) => kx[e](n[r].parameters, i.parameters)) } class fs { constructor(t, e, i) { this.root = t, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = $a(this.queryParams)), this._queryParamMap } toString() { return TV.serialize(this) } } class it { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, In(e, (i, r) => i.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return ih(this) } } class xc { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = $a(this.parameters)), this._parameterMap } toString() { return Bx(this) } } function ps(n, t) { return n.length === t.length && n.every((e, i) => e.path === t[i].path) } class Px { } class Fx { parse(t) { const e = new LV(t); return new fs(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { const e = `/${Mc(t.root, !0)}`, i = function (n) { const t = Object.keys(n).map(e => { const i = n[e]; return Array.isArray(i) ? i.map(r => `${rh(e)}=${rh(r)}`).join("&") : `${rh(e)}=${rh(i)}` }).filter(e => !!e); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); var n; return `${e}${i}${"string" == typeof t.fragment ? `#${n = t.fragment, encodeURI(n)}` : ""}` } } const TV = new Fx; function ih(n) { return n.segments.map(t => Bx(t)).join("/") } function Mc(n, t) { if (!n.hasChildren()) return ih(n); if (t) { const e = n.children[Ze] ? Mc(n.children[Ze], !1) : "", i = []; return In(n.children, (r, o) => { o !== Ze && i.push(`${o}:${Mc(r, !1)}`) }), i.length > 0 ? `${e}(${i.join("//")})` : e } { const e = function (n, t) { let e = []; return In(n.children, (i, r) => { r === Ze && (e = e.concat(t(i, r))) }), In(n.children, (i, r) => { r !== Ze && (e = e.concat(t(i, r))) }), e }(n, (i, r) => r === Ze ? [Mc(n.children[Ze], !1)] : [`${r}:${Mc(i, !1)}`]); return 1 === Object.keys(n.children).length && null != n.children[Ze] ? `${ih(n)}/${e[0]}` : `${ih(n)}/(${e.join("//")})` } } function Nx(n) { return encodeURIComponent(n).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function rh(n) { return Nx(n).replace(/%3B/gi, ";") } function Ig(n) { return Nx(n).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function oh(n) { return decodeURIComponent(n) } function Lx(n) { return oh(n.replace(/\+/g, "%20")) } function Bx(n) { return `${Ig(n.path)}${function (n) { return Object.keys(n).map(t => `;${Ig(t)}=${Ig(n[t])}`).join("") }(n.parameters)}` } const RV = /^[^\/()?;=#]+/; function sh(n) { const t = n.match(RV); return t ? t[0] : "" } const OV = /^[^=?&#]+/, FV = /^[^&#]+/; class LV { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new it([], {}) : new it([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i[Ze] = new it(t, e)), i } parseSegment() { const t = sh(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new xc(oh(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = sh(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const r = sh(this.remaining); r && (i = r, this.capture(i)) } t[oh(e)] = oh(i) } parseQueryParam(t) { const e = function (n) { const t = n.match(OV); return t ? t[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const s = function (n) { const t = n.match(FV); return t ? t[0] : "" }(this.remaining); s && (i = s, this.capture(i)) } const r = Lx(e), o = Lx(i); if (t.hasOwnProperty(r)) { let s = t[r]; Array.isArray(s) || (s = [s], t[r] = s), s.push(o) } else t[r] = o } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = sh(this.remaining), r = this.remaining[i.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let o; i.indexOf(":") > -1 ? (o = i.substr(0, i.indexOf(":")), this.capture(o), this.capture(":")) : t && (o = Ze); const s = this.parseChildren(); e[o] = 1 === Object.keys(s).length ? s[Ze] : new it([], s), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Vx { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Rg(t, this._root); return e ? e.children.map(i => i.value) : [] } firstChild(t) { const e = Rg(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Og(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(r => r.value).filter(r => r !== t) } pathFromRoot(t) { return Og(t, this._root).map(e => e.value) } } function Rg(n, t) { if (n === t.value) return t; for (const e of t.children) { const i = Rg(n, e); if (i) return i } return null } function Og(n, t) { if (n === t.value) return [t]; for (const e of t.children) { const i = Og(n, e); if (i.length) return i.unshift(t), i } return [] } class lo { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Ga(n) { const t = {}; return n && n.children.forEach(e => t[e.value.outlet] = e), t } class Hx extends Vx { constructor(t, e) { super(t), this.snapshot = e, Pg(this, t) } toString() { return this.snapshot.toString() } } function jx(n, t) { const e = function (n, t) { const s = new ah([], {}, {}, "", {}, Ze, t, null, n.root, -1, {}); return new Ux("", new lo(s, [])) }(n, t), i = new ri([new xc("", {})]), r = new ri({}), o = new ri({}), s = new ri({}), a = new ri(""), l = new qa(i, r, s, a, o, Ze, t, e.root); return l.snapshot = e.root, new Hx(new lo(l, []), e) } class qa { constructor(t, e, i, r, o, s, a, l) { this.url = t, this.params = e, this.queryParams = i, this.fragment = r, this.data = o, this.outlet = s, this.component = a, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(Fe(t => $a(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(Fe(t => $a(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function zx(n, t = "emptyOnly") { const e = n.pathFromRoot; let i = 0; if ("always" !== t) for (i = e.length - 1; i >= 1;) { const r = e[i], o = e[i - 1]; if (r.routeConfig && "" === r.routeConfig.path) i--; else { if (o.component) break; i-- } } return function (n) { return n.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(e.slice(i)) } class ah { constructor(t, e, i, r, o, s, a, l, d, h, m) { this.url = t, this.params = e, this.queryParams = i, this.fragment = r, this.data = o, this.outlet = s, this.component = a, this.routeConfig = l, this._urlSegment = d, this._lastPathIndex = h, this._resolve = m } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = $a(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = $a(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(i => i.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Ux extends Vx { constructor(t, e) { super(e), this.url = t, Pg(this, e) } toString() { return $x(this._root) } } function Pg(n, t) { t.value._routerState = n, t.children.forEach(e => Pg(n, e)) } function $x(n) { const t = n.children.length > 0 ? ` { ${n.children.map($x).join(", ")} } ` : ""; return `${n.value}${t}` } function Fg(n) { if (n.snapshot) { const t = n.snapshot, e = n._futureSnapshot; n.snapshot = e, Sr(t.queryParams, e.queryParams) || n.queryParams.next(e.queryParams), t.fragment !== e.fragment && n.fragment.next(e.fragment), Sr(t.params, e.params) || n.params.next(e.params), function (n, t) { if (n.length !== t.length) return !1; for (let e = 0; e < n.length; ++e)if (!Sr(n[e], t[e])) return !1; return !0 }(t.url, e.url) || n.url.next(e.url), Sr(t.data, e.data) || n.data.next(e.data) } else n.snapshot = n._futureSnapshot, n.data.next(n._futureSnapshot.data) } function Ng(n, t) { const e = Sr(n.params, t.params) && function (n, t) { return ps(n, t) && n.every((e, i) => Sr(e.parameters, t[i].parameters)) }(n.url, t.url); return e && !(!n.parent != !t.parent) && (!n.parent || Ng(n.parent, t.parent)) } function Ec(n, t, e) { if (e && n.shouldReuseRoute(t.value, e.value.snapshot)) { const i = e.value; i._futureSnapshot = t.value; const r = function (n, t, e) { return t.children.map(i => { for (const r of e.children) if (n.shouldReuseRoute(i.value, r.value.snapshot)) return Ec(n, i, r); return Ec(n, i) }) }(n, t, e); return new lo(i, r) } { if (n.shouldAttach(t.value)) { const o = n.retrieve(t.value); if (null !== o) { const s = o.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => Ec(n, a)), s } } const i = function (n) { return new qa(new ri(n.url), new ri(n.params), new ri(n.queryParams), new ri(n.fragment), new ri(n.data), n.outlet, n.component, n) }(t.value), r = t.children.map(o => Ec(n, o)); return new lo(i, r) } } function lh(n) { return "object" == typeof n && null != n && !n.outlets && !n.segmentPath } function Sc(n) { return "object" == typeof n && null != n && n.outlets } function Lg(n, t, e, i, r) { let o = {}; return i && In(i, (s, a) => { o[a] = Array.isArray(s) ? s.map(l => `${l}`) : `${s}` }), new fs(e.root === n ? t : Gx(e.root, n, t), o, r) } function Gx(n, t, e) { const i = {}; return In(n.children, (r, o) => { i[o] = r === t ? e : Gx(r, t, e) }), new it(n.segments, i) } class qx { constructor(t, e, i) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && lh(i[0])) throw new Error("Root segment cannot have matrix parameters"); const r = i.find(Sc); if (r && r !== Tx(i)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Bg { constructor(t, e, i) { this.segmentGroup = t, this.processChildren = e, this.index = i } } function Wx(n, t, e) { if (n || (n = new it([], {})), 0 === n.segments.length && n.hasChildren()) return ch(n, t, e); const i = function (n, t, e) { let i = 0, r = t; const o = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; r < n.segments.length;) { if (i >= e.length) return o; const s = n.segments[r], a = e[i]; if (Sc(a)) break; const l = `${a}`, d = i < e.length - 1 ? e[i + 1] : null; if (r > 0 && void 0 === l) break; if (l && d && "object" == typeof d && void 0 === d.outlets) { if (!Qx(l, d, s)) return o; i += 2 } else { if (!Qx(l, {}, s)) return o; i++ } r++ } return { match: !0, pathIndex: r, commandIndex: i } }(n, t, e), r = e.slice(i.commandIndex); if (i.match && i.pathIndex < n.segments.length) { const o = new it(n.segments.slice(0, i.pathIndex), {}); return o.children[Ze] = new it(n.segments.slice(i.pathIndex), n.children), ch(o, 0, r) } return i.match && 0 === r.length ? new it(n.segments, {}) : i.match && !n.hasChildren() ? Vg(n, t, e) : i.match ? ch(n, 0, r) : Vg(n, t, e) } function ch(n, t, e) { if (0 === e.length) return new it(n.segments, {}); { const i = function (n) { return Sc(n[0]) ? n[0].outlets : { [Ze]: n } }(e), r = {}; return In(i, (o, s) => { "string" == typeof o && (o = [o]), null !== o && (r[s] = Wx(n.children[s], t, o)) }), In(n.children, (o, s) => { void 0 === i[s] && (r[s] = o) }), new it(n.segments, r) } } function Vg(n, t, e) { const i = n.segments.slice(0, t); let r = 0; for (; r < e.length;) { const o = e[r]; if (Sc(o)) { const l = QV(o.outlets); return new it(i, l) } if (0 === r && lh(e[0])) { i.push(new xc(n.segments[t].path, Yx(e[0]))), r++; continue } const s = Sc(o) ? o.outlets[Ze] : `${o}`, a = r < e.length - 1 ? e[r + 1] : null; s && a && lh(a) ? (i.push(new xc(s, Yx(a))), r += 2) : (i.push(new xc(s, {})), r++) } return new it(i, {}) } function QV(n) { const t = {}; return In(n, (e, i) => { "string" == typeof e && (e = [e]), null !== e && (t[i] = Vg(new it([], {}), 0, e)) }), t } function Yx(n) { const t = {}; return In(n, (e, i) => t[i] = `${e}`), t } function Qx(n, t, e) { return n == e.path && Sr(t, e.parameters) } class XV { constructor(t, e, i, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = r } activate(t) { const e = this.futureState._root, i = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, i, t), Fg(this.futureState.root), this.activateChildRoutes(e, i, t) } deactivateChildRoutes(t, e, i) { const r = Ga(e); t.children.forEach(o => { const s = o.value.outlet; this.deactivateRoutes(o, r[s], i), delete r[s] }), In(r, (o, s) => { this.deactivateRouteAndItsChildren(o, i) }) } deactivateRoutes(t, e, i) { const r = t.value, o = e ? e.value : null; if (r === o) if (r.component) { const s = i.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, i); else o && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(t, e) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const i = e.getContext(t.value.outlet), r = i && t.value.component ? i.children : e, o = Ga(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], r); if (i && i.outlet) { const s = i.outlet.detach(), a = i.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, e) { const i = e.getContext(t.value.outlet), r = i && t.value.component ? i.children : e, o = Ga(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], r); i && i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated(), i.attachRef = null, i.resolver = null, i.route = null) } activateChildRoutes(t, e, i) { const r = Ga(e); t.children.forEach(o => { this.activateRoutes(o, r[o.value.outlet], i), this.forwardEvent(new _V(o.value.snapshot)) }), t.children.length && this.forwardEvent(new mV(t.value.snapshot)) } activateRoutes(t, e, i) { const r = t.value, o = e ? e.value : null; if (Fg(r), r === o) if (r.component) { const s = i.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, i); else if (r.component) { const s = i.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const a = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Fg(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = function (n) { for (let t = n.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig; if (e && e.component) return null } return null }(r.snapshot), l = a ? a.module.componentFactoryResolver : null; s.attachRef = null, s.route = r, s.resolver = l, s.outlet && s.outlet.activateWith(r, l), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, i) } } class Hg { constructor(t, e) { this.routes = t, this.module = e } } function Bo(n) { return "function" == typeof n } function ms(n) { return n instanceof fs } const Tc = Symbol("INITIAL_VALUE"); function kc() { return oo(n => tV(n.map(t => t.pipe(pn(1), Dc(Tc)))).pipe(_x((t, e) => { let i = !1; return e.reduce((r, o, s) => r !== Tc ? r : (o === Tc && (i = !0), i || !1 !== o && s !== e.length - 1 && !ms(o) ? r : o), t) }, Tc), An(t => t !== Tc), Fe(t => ms(t) ? t : !0 === t), pn(1))) } class o2 { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Ac, this.attachRef = null } } class Ac { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const i = this.getOrCreateContext(t); i.outlet = e, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null, e.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new o2, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } let Kx = (() => { class n { constructor(e, i, r, o, s) { this.parentContexts = e, this.location = i, this.resolver = r, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new we, this.deactivateEvents = new we, this.attachEvents = new we, this.detachEvents = new we, this.name = o || Ze, e.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const e = this.parentContexts.getContext(this.name); e && e.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e } attach(e, i) { this.activated = e, this._activatedRoute = i, this.location.insert(e.hostView), this.attachEvents.emit(e.instance) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, i) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = e; const s = (i = i || this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component), a = this.parentContexts.getOrCreateContext(this.name).children, l = new s2(e, a, this.location.injector); this.activated = this.location.createComponent(s, this.location.length, l), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return n.\u0275fac = function (e) { return new (e || n)(w(Ac), w(Zt), w(Fo), function (n) { return function (n, t) { if ("class" === t) return n.classes; if ("style" === t) return n.styles; const e = n.attrs; if (e) { const i = e.length; let r = 0; for (; r < i;) { const o = e[r]; if (ky(o)) break; if (0 === o) r += 2; else if ("number" == typeof o) for (r++; r < i && "string" == typeof e[r];)r++; else { if (o === t) return e[r + 1]; r += 2 } } } return null }(on(), n) }("name"), w(_n)) }, n.\u0275dir = z({ type: n, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), n })(); class s2 { constructor(t, e, i) { this.route = t, this.childContexts = e, this.parent = i } get(t, e) { return t === qa ? this.route : t === Ac ? this.childContexts : this.parent.get(t, e) } } let Xx = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275cmp = ue({ type: n, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (e, i) { 1 & e && vt(0, "router-outlet") }, directives: [Kx], encapsulation: 2 }), n })(); function Zx(n, t = "") { for (let e = 0; e < n.length; e++) { const i = n[e]; a2(i, l2(t, i)) } } function a2(n, t) { n.children && Zx(n.children, t) } function l2(n, t) { return t ? n || t.path ? n && !t.path ? `${n}/` : !n && t.path ? t.path : `${n}/${t.path}` : "" : n } function jg(n) { const t = n.children && n.children.map(jg), e = t ? Object.assign(Object.assign({}, n), { children: t }) : Object.assign({}, n); return !e.component && (t || e.loadChildren) && e.outlet && e.outlet !== Ze && (e.component = Xx), e } function Ni(n) { return n.outlet || Ze } function Jx(n, t) { const e = n.filter(i => Ni(i) === t); return e.push(...n.filter(i => Ni(i) !== t)), e } const eM = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function dh(n, t, e) { var i; if ("" === t.path) return "full" === t.pathMatch && (n.hasChildren() || e.length > 0) ? Object.assign({}, eM) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || bV)(e, n, t); if (!o) return Object.assign({}, eM); const s = {}; In(o.posParams, (l, d) => { s[d] = l.path }); const a = o.consumed.length > 0 ? Object.assign(Object.assign({}, s), o.consumed[o.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: o.consumed, lastChild: o.consumed.length, parameters: a, positionalParamSegments: null !== (i = o.posParams) && void 0 !== i ? i : {} } } function uh(n, t, e, i, r = "corrected") { if (e.length > 0 && function (n, t, e) { return e.some(i => hh(n, t, i) && Ni(i) !== Ze) }(n, e, i)) { const s = new it(t, function (n, t, e, i) { const r = {}; r[Ze] = i, i._sourceSegment = n, i._segmentIndexShift = t.length; for (const o of e) if ("" === o.path && Ni(o) !== Ze) { const s = new it([], {}); s._sourceSegment = n, s._segmentIndexShift = t.length, r[Ni(o)] = s } return r }(n, t, i, new it(e, n.children))); return s._sourceSegment = n, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === e.length && function (n, t, e) { return e.some(i => hh(n, t, i)) }(n, e, i)) { const s = new it(n.segments, function (n, t, e, i, r, o) { const s = {}; for (const a of i) if (hh(n, e, a) && !r[Ni(a)]) { const l = new it([], {}); l._sourceSegment = n, l._segmentIndexShift = "legacy" === o ? n.segments.length : t.length, s[Ni(a)] = l } return Object.assign(Object.assign({}, r), s) }(n, t, e, i, n.children, r)); return s._sourceSegment = n, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: e } } const o = new it(n.segments, n.children); return o._sourceSegment = n, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: e } } function hh(n, t, e) { return (!(n.hasChildren() || t.length > 0) || "full" !== e.pathMatch) && "" === e.path } function tM(n, t, e, i) { return !!(Ni(n) === i || i !== Ze && hh(t, e, n)) && ("**" === n.path || dh(t, n, e).matched) } function nM(n, t, e) { return 0 === t.length && !n.children[e] } class Ic { constructor(t) { this.segmentGroup = t || null } } class iM { constructor(t) { this.urlTree = t } } function fh(n) { return new at(t => t.error(new Ic(n))) } function rM(n) { return new at(t => t.error(new iM(n))) } function f2(n) { return new at(t => t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${n}'`))) } class g2 { constructor(t, e, i, r, o) { this.configLoader = e, this.urlSerializer = i, this.urlTree = r, this.config = o, this.allowRedirects = !0, this.ngModule = t.get(to) } apply() { const t = uh(this.urlTree.root, [], [], this.config).segmentGroup, e = new it(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, Ze).pipe(Fe(o => this.createUrlTree(zg(o), this.urlTree.queryParams, this.urlTree.fragment))).pipe(so(o => { if (o instanceof iM) return this.allowRedirects = !1, this.match(o.urlTree); throw o instanceof Ic ? this.noMatchError(o) : o })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, Ze).pipe(Fe(r => this.createUrlTree(zg(r), t.queryParams, t.fragment))).pipe(so(r => { throw r instanceof Ic ? this.noMatchError(r) : r })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, i) { const r = t.segments.length > 0 ? new it([], { [Ze]: t }) : t; return new fs(r, e, i) } expandSegmentGroup(t, e, i, r) { return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(Fe(o => new it([], o))) : this.expandSegment(t, i, e, i.segments, r, !0) } expandChildren(t, e, i) { const r = []; for (const o of Object.keys(i.children)) "primary" === o ? r.unshift(o) : r.push(o); return Ut(r).pipe(za(o => { const s = i.children[o], a = Jx(e, o); return this.expandSegmentGroup(t, a, s, o).pipe(Fe(l => ({ segment: l, outlet: o }))) }), _x((o, s) => (o[s.outlet] = s.segment, o), {}), function (n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? An((r, o) => n(r, o, i)) : $i, Tg(1), e ? yx(t) : vx(() => new Ju)) }()) } expandSegment(t, e, i, r, o, s) { return Ut(i).pipe(za(a => this.expandSegmentAgainstRoute(t, e, i, a, r, o, s).pipe(so(d => { if (d instanceof Ic) return ge(null); throw d }))), Ua(a => !!a), so((a, l) => { if (a instanceof Ju || "EmptyError" === a.name) { if (nM(e, r, o)) return ge(new it([], {})); throw new Ic(e) } throw a })) } expandSegmentAgainstRoute(t, e, i, r, o, s, a) { return tM(r, e, o, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, o, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) : fh(e) : fh(e) } expandSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, r, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, r) { const o = this.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? rM(o) : this.lineralizeSegments(i, o).pipe(Ft(s => { const a = new it(s, {}); return this.expandSegment(t, a, e, s, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) { const { matched: a, consumedSegments: l, lastChild: d, positionalParamSegments: h } = dh(e, r, o); if (!a) return fh(e); const m = this.applyRedirectCommands(l, r.redirectTo, h); return r.redirectTo.startsWith("/") ? rM(m) : this.lineralizeSegments(r, m).pipe(Ft(y => this.expandSegment(t, e, i, y.concat(o.slice(d)), s, !1))) } matchSegmentAgainstRoute(t, e, i, r, o) { if ("**" === i.path) return i.loadChildren ? (i._loadedConfig ? ge(i._loadedConfig) : this.configLoader.load(t.injector, i)).pipe(Fe(y => (i._loadedConfig = y, new it(r, {})))) : ge(new it(r, {})); const { matched: s, consumedSegments: a, lastChild: l } = dh(e, i, r); if (!s) return fh(e); const d = r.slice(l); return this.getChildConfig(t, i, r).pipe(Ft(m => { const y = m.module, D = m.routes, { segmentGroup: M, slicedSegments: k } = uh(e, a, d, D), P = new it(M.segments, M.children); if (0 === k.length && P.hasChildren()) return this.expandChildren(y, D, P).pipe(Fe(ie => new it(a, ie))); if (0 === D.length && 0 === k.length) return ge(new it(a, {})); const H = Ni(i) === o; return this.expandSegment(y, P, D, k, H ? Ze : o, !0).pipe(Fe(W => new it(a.concat(W.segments), W.children))) })) } getChildConfig(t, e, i) { return e.children ? ge(new Hg(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? ge(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, i).pipe(Ft(r => { return r ? this.configLoader.load(t.injector, e).pipe(Fe(o => (e._loadedConfig = o, o))) : (n = e, new at(t => t.error(Ag(`Cannot load children because the guard of the route "path: '${n.path}'" returned false`)))); var n })) : ge(new Hg([], t)) } runCanLoadGuards(t, e, i) { const r = e.canLoad; return r && 0 !== r.length ? ge(r.map(s => { const a = t.get(s); let l; if ((n = a) && Bo(n.canLoad)) l = a.canLoad(e, i); else { if (!Bo(a)) throw new Error("Invalid CanLoad guard"); l = a(e, i) } var n; return Tr(l) })).pipe(kc(), vn(s => { if (!ms(s)) return; const a = Ag(`Redirecting to "${this.urlSerializer.serialize(s)}"`); throw a.url = s, a }), Fe(s => !0 === s)) : ge(!0) } lineralizeSegments(t, e) { let i = [], r = e.root; for (; ;) { if (i = i.concat(r.segments), 0 === r.numberOfChildren) return ge(i); if (r.numberOfChildren > 1 || !r.children[Ze]) return f2(t.redirectTo); r = r.children[Ze] } } applyRedirectCommands(t, e, i) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i) } applyRedirectCreatreUrlTree(t, e, i, r) { const o = this.createSegmentGroup(t, e.root, i, r); return new fs(o, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const i = {}; return In(t, (r, o) => { if ("string" == typeof r && r.startsWith(":")) { const a = r.substring(1); i[o] = e[a] } else i[o] = r }), i } createSegmentGroup(t, e, i, r) { const o = this.createSegments(t, e.segments, i, r); let s = {}; return In(e.children, (a, l) => { s[l] = this.createSegmentGroup(t, a, i, r) }), new it(o, s) } createSegments(t, e, i, r) { return e.map(o => o.path.startsWith(":") ? this.findPosParam(t, o, r) : this.findOrReturn(o, i)) } findPosParam(t, e, i) { const r = i[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let i = 0; for (const r of e) { if (r.path === t.path) return e.splice(i), r; i++ } return t } } function zg(n) { const t = {}; for (const i of Object.keys(n.children)) { const o = zg(n.children[i]); (o.segments.length > 0 || o.hasChildren()) && (t[i] = o) } return function (n) { if (1 === n.numberOfChildren && n.children[Ze]) { const t = n.children[Ze]; return new it(n.segments.concat(t.segments), t.children) } return n }(new it(n.segments, t)) } class oM { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class ph { constructor(t, e) { this.component = t, this.route = e } } function y2(n, t, e) { const i = n._root; return Rc(i, t ? t._root : null, e, [i.value]) } function mh(n, t, e) { const i = function (n) { if (!n) return null; for (let t = n.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig } return null }(t); return (i ? i.module.injector : e).get(n) } function Rc(n, t, e, i, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = Ga(t); return n.children.forEach(s => { (function (n, t, e, i, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = n.value, s = t ? t.value : null, a = e ? e.getContext(n.value.outlet) : null; if (s && o.routeConfig === s.routeConfig) { const l = function (n, t, e) { if ("function" == typeof e) return e(n, t); switch (e) { case "pathParamsChange": return !ps(n.url, t.url); case "pathParamsOrQueryParamsChange": return !ps(n.url, t.url) || !Sr(n.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Ng(n, t) || !Sr(n.queryParams, t.queryParams); default: return !Ng(n, t) } }(s, o, o.routeConfig.runGuardsAndResolvers); l ? r.canActivateChecks.push(new oM(i)) : (o.data = s.data, o._resolvedData = s._resolvedData), Rc(n, t, o.component ? a ? a.children : null : e, i, r), l && a && a.outlet && a.outlet.isActivated && r.canDeactivateChecks.push(new ph(a.outlet.component, s)) } else s && Oc(t, a, r), r.canActivateChecks.push(new oM(i)), Rc(n, null, o.component ? a ? a.children : null : e, i, r) })(s, o[s.value.outlet], e, i.concat([s.value]), r), delete o[s.value.outlet] }), In(o, (s, a) => Oc(s, e.getContext(a), r)), r } function Oc(n, t, e) { const i = Ga(n), r = n.value; In(i, (o, s) => { Oc(o, r.component ? t ? t.children.getContext(s) : null : t, e) }), e.canDeactivateChecks.push(new ph(r.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, r)) } class R2 { } function sM(n) { return new at(t => t.error(n)) } class P2 { constructor(t, e, i, r, o, s) { this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = r, this.paramsInheritanceStrategy = o, this.relativeLinkResolution = s } recognize() { const t = uh(this.urlTree.root, [], [], this.config.filter(s => void 0 === s.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, Ze); if (null === e) return null; const i = new ah([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, Ze, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new lo(i, e), o = new Ux(this.url, r); return this.inheritParamsAndData(o._root), o } inheritParamsAndData(t) { const e = t.value, i = zx(e, this.paramsInheritanceStrategy); e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(r => this.inheritParamsAndData(r)) } processSegmentGroup(t, e, i) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i) } processChildren(t, e) { const i = []; for (const o of Object.keys(e.children)) { const s = e.children[o], a = Jx(t, o), l = this.processSegmentGroup(a, s, o); if (null === l) return null; i.push(...l) } const r = aM(i); return r.sort((t, e) => t.value.outlet === Ze ? -1 : e.value.outlet === Ze ? 1 : t.value.outlet.localeCompare(e.value.outlet)), r } processSegment(t, e, i, r) { for (const o of t) { const s = this.processSegmentAgainstRoute(o, e, i, r); if (null !== s) return s } return nM(e, i, r) ? [] : null } processSegmentAgainstRoute(t, e, i, r) { if (t.redirectTo || !tM(t, e, i, r)) return null; let o, s = [], a = []; if ("**" === t.path) { const D = i.length > 0 ? Tx(i).parameters : {}; o = new ah(i, D, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, dM(t), Ni(t), t.component, t, lM(e), cM(e) + i.length, uM(t)) } else { const D = dh(e, t, i); if (!D.matched) return null; s = D.consumedSegments, a = i.slice(D.lastChild), o = new ah(s, D.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, dM(t), Ni(t), t.component, t, lM(e), cM(e) + s.length, uM(t)) } const l = (n = t).children ? n.children : n.loadChildren ? n._loadedConfig.routes : [], { segmentGroup: d, slicedSegments: h } = uh(e, s, a, l.filter(D => void 0 === D.redirectTo), this.relativeLinkResolution); var n; if (0 === h.length && d.hasChildren()) { const D = this.processChildren(l, d); return null === D ? null : [new lo(o, D)] } if (0 === l.length && 0 === h.length) return [new lo(o, [])]; const m = Ni(t) === r, y = this.processSegment(l, d, h, m ? Ze : r); return null === y ? null : [new lo(o, y)] } } function L2(n) { const t = n.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function aM(n) { const t = [], e = new Set; for (const i of n) { if (!L2(i)) { t.push(i); continue } const r = t.find(o => i.value.routeConfig === o.value.routeConfig); void 0 !== r ? (r.children.push(...i.children), e.add(r)) : t.push(i) } for (const i of e) { const r = aM(i.children); t.push(new lo(i.value, r)) } return t.filter(i => !e.has(i)) } function lM(n) { let t = n; for (; t._sourceSegment;)t = t._sourceSegment; return t } function cM(n) { let t = n, e = t._segmentIndexShift ? t._segmentIndexShift : 0; for (; t._sourceSegment;)t = t._sourceSegment, e += t._segmentIndexShift ? t._segmentIndexShift : 0; return e - 1 } function dM(n) { return n.data || {} } function uM(n) { return n.resolve || {} } function Ug(n) { return oo(t => { const e = n(t); return e ? Ut(e).pipe(Fe(() => t)) : ge(t) }) } class G2 extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const $g = new V("ROUTES"); class hM { constructor(t, e, i, r) { this.injector = t, this.compiler = e, this.onLoadStartListener = i, this.onLoadEndListener = r } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const r = this.loadModuleFactory(e.loadChildren).pipe(Fe(o => { this.onLoadEndListener && this.onLoadEndListener(e); const s = o.create(t); return new Hg(Sx(s.injector.get($g, void 0, Ie.Self | Ie.Optional)).map(jg), s) }), so(o => { throw e._loader$ = void 0, o })); return e._loader$ = new rV(r, () => new se).pipe(gx()), e._loader$ } loadModuleFactory(t) { return Tr(t()).pipe(Ft(e => e instanceof MD ? ge(e) : Ut(this.compiler.compileModuleAsync(e)))) } } class W2 { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Y2(n) { throw n } function Q2(n, t, e) { return t.parse("/") } function fM(n, t) { return ge(null) } const K2 = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, X2 = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let oi = (() => { class n { constructor(e, i, r, o, s, a, l) { this.rootComponentType = e, this.urlSerializer = i, this.rootContexts = r, this.location = o, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new se, this.errorHandler = Y2, this.malformedUriErrorHandler = Q2, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: fM, afterPreactivation: fM }, this.urlHandlingStrategy = new W2, this.routeReuseStrategy = new G2, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = s.get(to), this.console = s.get(sw); const m = s.get(Xe); this.isNgZoneEnabled = m instanceof Xe && Xe.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = new fs(new it([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new hM(s, a, y => this.triggerEvent(new Dx(y)), y => this.triggerEvent(new wx(y))), this.routerState = jx(this.currentUrlTree, this.rootComponentType), this.transitions = new ri({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var e; return null === (e = this.location.getState()) || void 0 === e ? void 0 : e.\u0275routerPageId } setupNavigations(e) { const i = this.events; return e.pipe(An(r => 0 !== r.id), Fe(r => Object.assign(Object.assign({}, r), { extractedUrl: this.urlHandlingStrategy.extract(r.rawUrl) })), oo(r => { let o = !1, s = !1; return ge(r).pipe(vn(a => { this.currentNavigation = { id: a.id, initialUrl: a.currentRawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), oo(a => { const l = this.browserUrlTree.toString(), d = !this.navigated || a.extractedUrl.toString() !== l || l !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || d) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return gh(a.source) && (this.browserUrlTree = a.extractedUrl), ge(a).pipe(oo(m => { const y = this.transitions.getValue(); return i.next(new kg(m.id, this.serializeUrl(m.extractedUrl), m.source, m.restoredState)), y !== this.transitions.getValue() ? qi : Promise.resolve(m) }), function (n, t, e, i) { return oo(r => function (n, t, e, i, r) { return new g2(n, t, e, i, r).apply() }(n, t, e, r.extractedUrl, i).pipe(Fe(o => Object.assign(Object.assign({}, r), { urlAfterRedirects: o })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), vn(m => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: m.urlAfterRedirects }) }), function (n, t, e, i, r) { return Ft(o => function (n, t, e, i, r = "emptyOnly", o = "legacy") { try { const s = new P2(n, t, e, i, r, o).recognize(); return null === s ? sM(new R2) : ge(s) } catch (s) { return sM(s) } }(n, t, o.urlAfterRedirects, e(o.urlAfterRedirects), i, r).pipe(Fe(s => Object.assign(Object.assign({}, o), { targetSnapshot: s })))) }(this.rootComponentType, this.config, m => this.serializeUrl(m), this.paramsInheritanceStrategy, this.relativeLinkResolution), vn(m => { if ("eager" === this.urlUpdateStrategy) { if (!m.extras.skipLocationChange) { const D = this.urlHandlingStrategy.merge(m.urlAfterRedirects, m.rawUrl); this.setBrowserUrl(D, m) } this.browserUrlTree = m.urlAfterRedirects } const y = new cV(m.id, this.serializeUrl(m.extractedUrl), this.serializeUrl(m.urlAfterRedirects), m.targetSnapshot); i.next(y) })); if (d && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: y, extractedUrl: D, source: M, restoredState: k, extras: P } = a, H = new kg(y, this.serializeUrl(D), M, k); i.next(H); const F = jx(D, this.rootComponentType).snapshot; return ge(Object.assign(Object.assign({}, a), { targetSnapshot: F, urlAfterRedirects: D, extras: Object.assign(Object.assign({}, P), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = a.rawUrl, a.resolve(null), qi }), Ug(a => { const { targetSnapshot: l, id: d, extractedUrl: h, rawUrl: m, extras: { skipLocationChange: y, replaceUrl: D } } = a; return this.hooks.beforePreactivation(l, { navigationId: d, appliedUrlTree: h, rawUrlTree: m, skipLocationChange: !!y, replaceUrl: !!D }) }), vn(a => { const l = new dV(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(l) }), Fe(a => Object.assign(Object.assign({}, a), { guards: y2(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function (n, t) { return Ft(e => { const { targetSnapshot: i, currentSnapshot: r, guards: { canActivateChecks: o, canDeactivateChecks: s } } = e; return 0 === s.length && 0 === o.length ? ge(Object.assign(Object.assign({}, e), { guardsResult: !0 })) : function (n, t, e, i) { return Ut(n).pipe(Ft(r => function (n, t, e, i, r) { const o = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return o && 0 !== o.length ? ge(o.map(a => { const l = mh(a, t, r); let d; if (function (n) { return n && Bo(n.canDeactivate) }(l)) d = Tr(l.canDeactivate(n, t, e, i)); else { if (!Bo(l)) throw new Error("Invalid CanDeactivate guard"); d = Tr(l(n, t, e, i)) } return d.pipe(Ua()) })).pipe(kc()) : ge(!0) }(r.component, r.route, e, t, i)), Ua(r => !0 !== r, !0)) }(s, i, r, n).pipe(Ft(a => a && function (n) { return "boolean" == typeof n }(a) ? function (n, t, e, i) { return Ut(t).pipe(za(r => eh(function (n, t) { return null !== n && t && t(new pV(n)), ge(!0) }(r.route.parent, i), function (n, t) { return null !== n && t && t(new gV(n)), ge(!0) }(r.route, i), function (n, t, e) { const i = t[t.length - 1], o = t.slice(0, t.length - 1).reverse().map(s => function (n) { const t = n.routeConfig ? n.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: n, guards: t } : null }(s)).filter(s => null !== s).map(s => th(() => ge(s.guards.map(l => { const d = mh(l, s.node, e); let h; if (function (n) { return n && Bo(n.canActivateChild) }(d)) h = Tr(d.canActivateChild(i, n)); else { if (!Bo(d)) throw new Error("Invalid CanActivateChild guard"); h = Tr(d(i, n)) } return h.pipe(Ua()) })).pipe(kc()))); return ge(o).pipe(kc()) }(n, r.path, e), function (n, t, e) { const i = t.routeConfig ? t.routeConfig.canActivate : null; if (!i || 0 === i.length) return ge(!0); const r = i.map(o => th(() => { const s = mh(o, t, e); let a; if (function (n) { return n && Bo(n.canActivate) }(s)) a = Tr(s.canActivate(t, n)); else { if (!Bo(s)) throw new Error("Invalid CanActivate guard"); a = Tr(s(t, n)) } return a.pipe(Ua()) })); return ge(r).pipe(kc()) }(n, r.route, e))), Ua(r => !0 !== r, !0)) }(i, o, n, t) : ge(a)), Fe(a => Object.assign(Object.assign({}, e), { guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), vn(a => { if (ms(a.guardsResult)) { const d = Ag(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw d.url = a.guardsResult, d } const l = new uV(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(l) }), An(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), Ug(a => { if (a.guards.canActivateChecks.length) return ge(a).pipe(vn(l => { const d = new hV(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(d) }), oo(l => { let d = !1; return ge(l).pipe(function (n, t) { return Ft(e => { const { targetSnapshot: i, guards: { canActivateChecks: r } } = e; if (!r.length) return ge(e); let o = 0; return Ut(r).pipe(za(s => function (n, t, e, i) { return function (n, t, e, i) { const r = Object.keys(n); if (0 === r.length) return ge({}); const o = {}; return Ut(r).pipe(Ft(s => function (n, t, e, i) { const r = mh(n, t, i); return Tr(r.resolve ? r.resolve(t, e) : r(t, e)) }(n[s], t, e, i).pipe(vn(a => { o[s] = a }))), Tg(1), Ft(() => Object.keys(o).length === r.length ? ge(o) : qi)) }(n._resolve, n, t, i).pipe(Fe(o => (n._resolvedData = o, n.data = Object.assign(Object.assign({}, n.data), zx(n, e).resolve), null))) }(s.route, i, n, t)), vn(() => o++), Tg(1), Ft(s => o === r.length ? ge(e) : qi)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), vn({ next: () => d = !0, complete: () => { d || (this.restoreHistory(l), this.cancelNavigationTransition(l, "At least one route resolver didn't emit any value.")) } })) }), vn(l => { const d = new fV(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(d) })) }), Ug(a => { const { targetSnapshot: l, id: d, extractedUrl: h, rawUrl: m, extras: { skipLocationChange: y, replaceUrl: D } } = a; return this.hooks.afterPreactivation(l, { navigationId: d, appliedUrlTree: h, rawUrlTree: m, skipLocationChange: !!y, replaceUrl: !!D }) }), Fe(a => { const l = function (n, t, e) { const i = Ec(n, t._root, e ? e._root : void 0); return new Hx(i, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return Object.assign(Object.assign({}, a), { targetRouterState: l }) }), vn(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((n, t, e) => Fe(i => (new XV(t, i.targetRouterState, i.currentRouterState, e).activate(n), i)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), vn({ next() { o = !0 }, complete() { o = !0 } }), function (n) { return lt((t, e) => { try { t.subscribe(e) } finally { e.add(n) } }) }(() => { var a; o || s || this.cancelNavigationTransition(r, `Navigation ID ${r.id} is not equal to the current navigation id ${this.navigationId}`), (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id) === r.id && (this.currentNavigation = null) }), so(a => { if (s = !0, function (n) { return n && n[Mx] }(a)) { const l = ms(a.url); l || (this.navigated = !0, this.restoreHistory(r, !0)); const d = new Cx(r.id, this.serializeUrl(r.extractedUrl), a.message); i.next(d), l ? setTimeout(() => { const h = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), m = { skipLocationChange: r.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || gh(r.source) }; this.scheduleNavigation(h, "imperative", null, m, { resolve: r.resolve, reject: r.reject, promise: r.promise }) }, 0) : r.resolve(!1) } else { this.restoreHistory(r, !0); const l = new lV(r.id, this.serializeUrl(r.extractedUrl), a); i.next(l); try { r.resolve(this.errorHandler(a)) } catch (d) { r.reject(d) } } return qi })) })) } resetRootComponentType(e) { this.rootComponentType = e, this.routerState.root.component = this.rootComponentType } setTransition(e) { this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), e)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { const i = "popstate" === e.type ? "popstate" : "hashchange"; "popstate" === i && setTimeout(() => { var r; const o = { replaceUrl: !0 }, s = (null === (r = e.state) || void 0 === r ? void 0 : r.navigationId) ? e.state : null; if (s) { const l = Object.assign({}, s); delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (o.state = l) } const a = this.parseUrl(e.url); this.scheduleNavigation(a, i, s, o) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(e) { this.events.next(e) } resetConfig(e) { Zx(e), this.config = e.map(jg), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(e, i = {}) { const { relativeTo: r, queryParams: o, fragment: s, queryParamsHandling: a, preserveFragment: l } = i, d = r || this.routerState.root, h = l ? this.currentUrlTree.fragment : s; let m = null; switch (a) { case "merge": m = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), o); break; case "preserve": m = this.currentUrlTree.queryParams; break; default: m = o || null }return null !== m && (m = this.removeEmptyProps(m)), function (n, t, e, i, r) { if (0 === e.length) return Lg(t.root, t.root, t, i, r); const o = function (n) { if ("string" == typeof n[0] && 1 === n.length && "/" === n[0]) return new qx(!0, 0, n); let t = 0, e = !1; const i = n.reduce((r, o, s) => { if ("object" == typeof o && null != o) { if (o.outlets) { const a = {}; return In(o.outlets, (l, d) => { a[d] = "string" == typeof l ? l.split("/") : l }), [...r, { outlets: a }] } if (o.segmentPath) return [...r, o.segmentPath] } return "string" != typeof o ? [...r, o] : 0 === s ? (o.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? e = !0 : ".." === a ? t++ : "" != a && r.push(a)) }), r) : [...r, o] }, []); return new qx(e, t, i) }(e); if (o.toRoot()) return Lg(t.root, new it([], {}), t, i, r); const s = function (n, t, e) { if (n.isAbsolute) return new Bg(t.root, !0, 0); if (-1 === e.snapshot._lastPathIndex) { const o = e.snapshot._urlSegment; return new Bg(o, o === t.root, 0) } const i = lh(n.commands[0]) ? 0 : 1; return function (n, t, e) { let i = n, r = t, o = e; for (; o > r;) { if (o -= r, i = i.parent, !i) throw new Error("Invalid number of '../'"); r = i.segments.length } return new Bg(i, !1, r - o) }(e.snapshot._urlSegment, e.snapshot._lastPathIndex + i, n.numberOfDoubleDots) }(o, t, n), a = s.processChildren ? ch(s.segmentGroup, s.index, o.commands) : Wx(s.segmentGroup, s.index, o.commands); return Lg(s.segmentGroup, a, t, i, r) }(d, this.currentUrlTree, e, m, null != h ? h : null) } navigateByUrl(e, i = { skipLocationChange: !1 }) { const r = ms(e) ? e : this.parseUrl(e), o = this.urlHandlingStrategy.merge(r, this.rawUrlTree); return this.scheduleNavigation(o, "imperative", null, i) } navigate(e, i = { skipLocationChange: !1 }) { return function (n) { for (let t = 0; t < n.length; t++) { const e = n[t]; if (null == e) throw new Error(`The requested path contains ${e} segment at index ${t}`) } }(e), this.navigateByUrl(this.createUrlTree(e, i), i) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let i; try { i = this.urlSerializer.parse(e) } catch (r) { i = this.malformedUriErrorHandler(r, this.urlSerializer, e) } return i } isActive(e, i) { let r; if (r = !0 === i ? Object.assign({}, K2) : !1 === i ? Object.assign({}, X2) : i, ms(e)) return Ax(this.currentUrlTree, e, r); const o = this.parseUrl(e); return Ax(this.currentUrlTree, o, r) } removeEmptyProps(e) { return Object.keys(e).reduce((i, r) => { const o = e[r]; return null != o && (i[r] = o), i }, {}) } processNavigations() { this.navigations.subscribe(e => { this.navigated = !0, this.lastSuccessfulId = e.id, this.currentPageId = e.targetPageId, this.events.next(new wc(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, e.resolve(!0) }, e => { this.console.warn(`Unhandled Navigation Error: ${e}`) }) } scheduleNavigation(e, i, r, o, s) { var a, l, d; if (this.disposed) return Promise.resolve(!1); const h = this.transitions.value, m = gh(i) && h && !gh(h.source), y = h.rawUrl.toString() === e.toString(), D = h.id === (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id); if (m && y && D) return Promise.resolve(!0); let k, P, H; s ? (k = s.resolve, P = s.reject, H = s.promise) : H = new Promise((ie, $e) => { k = ie, P = $e }); const F = ++this.navigationId; let W; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (r = this.location.getState()), W = r && r.\u0275routerPageId ? r.\u0275routerPageId : o.replaceUrl || o.skipLocationChange ? null !== (l = this.browserPageId) && void 0 !== l ? l : 0 : (null !== (d = this.browserPageId) && void 0 !== d ? d : 0) + 1) : W = 0, this.setTransition({ id: F, targetPageId: W, source: i, restoredState: r, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: e, extras: o, resolve: k, reject: P, promise: H, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), H.catch(ie => Promise.reject(ie)) } setBrowserUrl(e, i) { const r = this.urlSerializer.serialize(e), o = Object.assign(Object.assign({}, i.extras.state), this.generateNgRouterState(i.id, i.targetPageId)); this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl ? this.location.replaceState(r, "", o) : this.location.go(r, "", o) } restoreHistory(e, i = !1) { var r, o; if ("computed" === this.canceledNavigationResolution) { const s = this.currentPageId - e.targetPageId; "popstate" !== e.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (r = this.currentNavigation) || void 0 === r ? void 0 : r.finalUrl) || 0 === s ? this.currentUrlTree === (null === (o = this.currentNavigation) || void 0 === o ? void 0 : o.finalUrl) && 0 === s && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(s) } else "replace" === this.canceledNavigationResolution && (i && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(e, i) { const r = new Cx(e.id, this.serializeUrl(e.extractedUrl), i); this.triggerEvent(r), e.resolve(!1) } generateNgRouterState(e, i) { return "computed" === this.canceledNavigationResolution ? { navigationId: e, \u0275routerPageId: i } : { navigationId: e } } } return n.\u0275fac = function (e) { Ia() }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); function gh(n) { return "imperative" !== n } class pM { } class mM { preload(t, e) { return ge(null) } } let gM = (() => { class n { constructor(e, i, r, o) { this.router = e, this.injector = r, this.preloadingStrategy = o, this.loader = new hM(r, i, l => e.triggerEvent(new Dx(l)), l => e.triggerEvent(new wx(l))) } setUpPreloading() { this.subscription = this.router.events.pipe(An(e => e instanceof wc), za(() => this.preload())).subscribe(() => { }) } preload() { const e = this.injector.get(to); return this.processRoutes(e, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, i) { const r = []; for (const o of i) if (o.loadChildren && !o.canLoad && o._loadedConfig) { const s = o._loadedConfig; r.push(this.processRoutes(s.module, s.routes)) } else o.loadChildren && !o.canLoad ? r.push(this.preloadConfig(e, o)) : o.children && r.push(this.processRoutes(e, o.children)); return Ut(r).pipe(wo(), Fe(o => { })) } preloadConfig(e, i) { return this.preloadingStrategy.preload(i, () => (i._loadedConfig ? ge(i._loadedConfig) : this.loader.load(e.injector, i)).pipe(Ft(o => (i._loadedConfig = o, this.processRoutes(o.module, o.routes))))) } } return n.\u0275fac = function (e) { return new (e || n)(L(oi), L(Pu), L(qt), L(pM)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), Wg = (() => { class n { constructor(e, i, r = {}) { this.router = e, this.viewportScroller = i, this.options = r, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, r.scrollPositionRestoration = r.scrollPositionRestoration || "disabled", r.anchorScrolling = r.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(e => { e instanceof kg ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof wc && (this.lastId = e.id, this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(e => { e instanceof xx && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, i) { this.router.triggerEvent(new xx(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, i)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return n.\u0275fac = function (e) { Ia() }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const gs = new V("ROUTER_CONFIGURATION"), _M = new V("ROUTER_FORROOT_GUARD"), nH = [_c, { provide: Px, useClass: Fx }, { provide: oi, useFactory: function (n, t, e, i, r, o, s = {}, a, l) { const d = new oi(null, n, t, e, i, r, Sx(o)); return a && (d.urlHandlingStrategy = a), l && (d.routeReuseStrategy = l), function (n, t) { n.errorHandler && (t.errorHandler = n.errorHandler), n.malformedUriErrorHandler && (t.malformedUriErrorHandler = n.malformedUriErrorHandler), n.onSameUrlNavigation && (t.onSameUrlNavigation = n.onSameUrlNavigation), n.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = n.paramsInheritanceStrategy), n.relativeLinkResolution && (t.relativeLinkResolution = n.relativeLinkResolution), n.urlUpdateStrategy && (t.urlUpdateStrategy = n.urlUpdateStrategy), n.canceledNavigationResolution && (t.canceledNavigationResolution = n.canceledNavigationResolution) }(s, d), s.enableTracing && d.events.subscribe(h => { var m, y; null === (m = console.group) || void 0 === m || m.call(console, `Router Event: ${h.constructor.name}`), console.log(h.toString()), console.log(h), null === (y = console.groupEnd) || void 0 === y || y.call(console) }), d }, deps: [Px, Ac, _c, qt, Pu, $g, gs, [class { }, new an], [class { }, new an]] }, Ac, { provide: qa, useFactory: function (n) { return n.routerState.root }, deps: [oi] }, gM, mM, class { preload(t, e) { return e().pipe(so(() => ge(null))) } }, { provide: gs, useValue: { enableTracing: !1 } }]; function iH() { return new hw("Router", oi) } let vM = (() => { class n { constructor(e, i) { } static forRoot(e, i) { return { ngModule: n, providers: [nH, yM(e), { provide: _M, useFactory: sH, deps: [[oi, new an, new pi]] }, { provide: gs, useValue: i || {} }, { provide: ja, useFactory: oH, deps: [hs, [new Gl(lg), new an], gs] }, { provide: Wg, useFactory: rH, deps: [oi, dB, gs] }, { provide: pM, useExisting: i && i.preloadingStrategy ? i.preloadingStrategy : mM }, { provide: hw, multi: !0, useFactory: iH }, [Yg, { provide: Ru, multi: !0, useFactory: dH, deps: [Yg] }, { provide: bM, useFactory: uH, deps: [Yg] }, { provide: ow, multi: !0, useExisting: bM }]] } } static forChild(e) { return { ngModule: n, providers: [yM(e)] } } } return n.\u0275fac = function (e) { return new (e || n)(L(_M, 8), L(oi, 8)) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(); function rH(n, t, e) { return e.scrollOffset && t.setOffset(e.scrollOffset), new Wg(n, t, e) } function oH(n, t, e = {}) { return e.useHash ? new GN(n, t) : new Pw(n, t) } function sH(n) { return "guarded" } function yM(n) { return [{ provide: mA, multi: !0, useValue: n }, { provide: $g, multi: !0, useValue: n }] } let Yg = (() => { class n { constructor(e) { this.injector = e, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new se } appInitializer() { return this.injector.get(zN, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let i = null; const r = new Promise(a => i = a), o = this.injector.get(oi), s = this.injector.get(gs); return "disabled" === s.initialNavigation ? (o.setUpLocationChangeListener(), i(!0)) : "enabled" === s.initialNavigation || "enabledBlocking" === s.initialNavigation ? (o.hooks.afterPreactivation = () => this.initNavigation ? ge(null) : (this.initNavigation = !0, i(!0), this.resultOfPreactivationDone), o.initialNavigation()) : i(!0), r }) } bootstrapListener(e) { const i = this.injector.get(gs), r = this.injector.get(gM), o = this.injector.get(Wg), s = this.injector.get(oi), a = this.injector.get(Va); e === a.components[0] && (("enabledNonBlocking" === i.initialNavigation || void 0 === i.initialNavigation) && s.initialNavigation(), r.setUpPreloading(), o.init(), s.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return n.\u0275fac = function (e) { return new (e || n)(L(qt)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); function dH(n) { return n.appInitializer.bind(n) } function uH(n) { return n.bootstrapListener.bind(n) } const bM = new V("Router Initializer"), fH = []; let pH = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[vM.forRoot(fH, { relativeLinkResolution: "legacy" })], vM] }), n })(); var CM = fl(259); let gH = (() => { class n { constructor(e) { this.router = e, this.value = "Clear me" } ngOnInit() { (class { static scriptRegister() { CM.getScript("assets/js/vendor/jquery-3.5.1.min.js"), CM.getScript("assets/js/vendor/bootstrap.bundle.min.js") } }).scriptRegister() } } return n.\u0275fac = function (e) { return new (e || n)(w(oi)) }, n.\u0275cmp = ue({ type: n, selectors: [["app-root"]], decls: 23, vars: 0, consts: [[1, "container"], [1, "row"], [1, "logo", 2, "margin-top", "3%", "text-align", "center"], ["href", "https://jilaba.com"], ["id", "img", "src", "assets/images/new-jilaba-logo.png", "alt", "logo", "width", "20%"], [1, "col-md-6"], [1, "main"], [1, "login-box"], [1, "login-form"], ["src", "assets/images/staff-img.png", "usemap", "#image_map", "width", "100%"], ["name", "image_map"], ["alt", "Exam Portal", "title", "Exam Portal", "href", "https://jilaba.net/examportaladmin/", "coords", "83,34,182,122", "shape", "rect"], ["method", "POST"], ["href", "https://jilaba.net/exam/", "role", "button", 1, "button-33"], ["src", "assets/images/student-img.png", "alt", "student Login", "width", "100%"]], template: function (e, i) { 1 & e && (pe(0, "div", 0), pe(1, "div", 1), pe(2, "div", 2), pe(3, "a", 3), vt(4, "img", 4), me(), me(), pe(5, "div", 5), pe(6, "div", 6), pe(7, "div", 7), pe(8, "div", 8), vt(9, "img", 9), pe(10, "map", 10), vt(11, "area", 11), me(), vt(12, "br"), vt(13, "br"), vt(14, "br"), me(), me(), me(), me(), pe(15, "div", 5), pe(16, "div", 6), pe(17, "div", 7), pe(18, "div", 8), pe(19, "form", 12), pe(20, "a", 13), Mr(21, "Student Login"), me(), me(), vt(22, "img", 14), me(), me(), me(), me(), me(), me()) }, styles: ['@import"https://fonts.googleapis.com/css2?family=Quicksand:wght@500;600&display=swap";body[_ngcontent-%COMP%]{background-image:linear-gradient(to right,#b46d6d,#3a5ecbde)!important;background-image:url(/assets/Images/bg.png);background-size:cover;background-repeat:no-repeat;background-attachment:fixed}.main[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:80vh;width:100%}.login-box[_ngcontent-%COMP%]{border-radius:16px;background:rgb(207,245,248);box-shadow:0 8px 32px #00000038;height:auto;width:450px}.text-login[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#fff;text-align:center;font-family:Quicksand,sans-serif;font-weight:600;font-size:30px}.text-login[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{text-align:center;font-family:Quicksand,sans-serif;color:#d4d4d4}.text-login[_ngcontent-%COMP%]{text-align:center}form[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center}.login-form[_ngcontent-%COMP%]{margin-top:30px;margin-bottom:30px}.form-control[_ngcontent-%COMP%]{margin-top:20px;width:350px;font-family:Quicksand,sans-serif;text-align:center;color:#fff;height:40px;border:#00000033 1px solid;font-size:20px;border-radius:15px;background-color:#a5a5a524}.form-control[_ngcontent-%COMP%]::placeholder{text-align:center;font-size:18px;font-family:Quicksand,sans-serif;color:#c4c4c4}.form-control[_ngcontent-%COMP%]:focus{outline:none}.form-enter[_ngcontent-%COMP%]{margin-top:20px;width:200px;font-weight:700;height:45px;border-radius:10px;background:white;font-family:Quicksand,sans-serif;border:transparent 1px solid}hr[_ngcontent-%COMP%]{width:70%;margin-top:40px}.social-login[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#fff;font-family:Quicksand,sans-serif;text-align:center;text-transform:capitalize}.social-links[_ngcontent-%COMP%]{display:flex;justify-content:space-evenly;align-items:center}.fab[_ngcontent-%COMP%]{color:#fff;border-radius:20px;font-size:40px;width:50px;height:50px}.button-33[_ngcontent-%COMP%]{background-color:#c2fbd7;border-radius:100px;box-shadow:#2cbb6333 0 -25px 18px -14px inset,#2cbb6326 0 1px 2px,#2cbb6326 0 2px 4px,#2cbb6326 0 4px 8px,#2cbb6326 0 8px 16px,#2cbb6326 0 16px 32px;color:green;cursor:pointer;display:inline-block;font-family:CerebriSans-Regular,-apple-system,system-ui,Roboto,sans-serif;padding:7px 20px;text-align:center;text-decoration:none;transition:all .25s;border:0;font-size:26px;user-select:none;-webkit-user-select:none;touch-action:manipulation}.button-33[_ngcontent-%COMP%]:hover{box-shadow:#2cbb6359 0 -25px 18px -14px inset,#2cbb6340 0 1px 2px,#2cbb6340 0 2px 4px,#2cbb6340 0 4px 8px,#2cbb6340 0 8px 16px,#2cbb6340 0 16px 32px;transform:scale(1.05) rotate(-1deg)}.class[_ngcontent-%COMP%]{width:20%}@media only screen and (max-width: 992px){.class[_ngcontent-%COMP%], #img[_ngcontent-%COMP%]{width:70%}}'] }), n })(); class DM { } const co = "*"; function Rt(n, t) { return { type: 7, name: n, definitions: t, options: {} } } function rt(n, t = null) { return { type: 4, styles: t, timings: n } } function wM(n, t = null) { return { type: 2, steps: n, options: t } } function ne(n) { return { type: 6, styles: n, offset: null } } function je(n, t, e) { return { type: 0, name: n, styles: t, options: e } } function Je(n, t, e = null) { return { type: 1, expr: n, animation: t, options: e } } function EM(n) { Promise.resolve(null).then(n) } class Ya { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { EM(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class SM { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, i = 0, r = 0; const o = this.players.length; 0 == o ? EM(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++e == o && this._onFinish() }), s.onDestroy(() => { ++i == o && this._onDestroy() }), s.onStart(() => { ++r == o && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(i => { const r = i.totalTime ? Math.min(1, e / i.totalTime) : 1; i.setPosition(r) }) } getPosition() { const t = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } function TM() { return "undefined" != typeof window && void 0 !== window.document } function Kg() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function Vo(n) { switch (n.length) { case 0: return new Ya; case 1: return n[0]; default: return new SM(n) } } function kM(n, t, e, i, r = {}, o = {}) { const s = [], a = []; let l = -1, d = null; if (i.forEach(h => { const m = h.offset, y = m == l, D = y && d || {}; Object.keys(h).forEach(M => { let k = M, P = h[M]; if ("offset" !== M) switch (k = t.normalizePropertyName(k, s), P) { case "!": P = r[M]; break; case co: P = o[M]; break; default: P = t.normalizeStyleValue(M, k, P, s) }D[k] = P }), y || a.push(D), d = D, l = m }), s.length) { const h = "\n - "; throw new Error(`Unable to animate due to the following errors:${h}${s.join(h)}`) } return a } function Xg(n, t, e, i) { switch (t) { case "start": n.onStart(() => i(e && Zg(e, "start", n))); break; case "done": n.onDone(() => i(e && Zg(e, "done", n))); break; case "destroy": n.onDestroy(() => i(e && Zg(e, "destroy", n))) } } function Zg(n, t, e) { const i = e.totalTime, o = Jg(n.element, n.triggerName, n.fromState, n.toState, t || n.phaseName, null == i ? n.totalTime : i, !!e.disabled), s = n._data; return null != s && (o._data = s), o } function Jg(n, t, e, i, r = "", o = 0, s) { return { element: n, triggerName: t, fromState: e, toState: i, phaseName: r, totalTime: o, disabled: !!s } } function bi(n, t, e) { let i; return n instanceof Map ? (i = n.get(t), i || n.set(t, i = e)) : (i = n[t], i || (i = n[t] = e)), i } function AM(n) { const t = n.indexOf(":"); return [n.substring(1, t), n.substr(t + 1)] } let e_ = (n, t) => !1, IM = (n, t, e) => []; (Kg() || "undefined" != typeof Element) && (e_ = TM() ? (n, t) => { for (; t && t !== document.documentElement;) { if (t === n) return !0; t = t.parentNode || t.host } return !1 } : (n, t) => n.contains(t), IM = (n, t, e) => { let i = []; if (e) { const r = n.querySelectorAll(t); for (let o = 0; o < r.length; o++)i.push(r[o]) } else { const r = n.querySelector(t); r && i.push(r) } return i }); let vs = null, RM = !1; function t_(n) { vs || (vs = ("undefined" != typeof document ? document.body : null) || {}, RM = !!vs.style && "WebkitAppearance" in vs.style); let t = !0; return vs.style && !function (n) { return "ebkit" == n.substring(1, 6) }(n) && (t = n in vs.style, !t && RM && (t = "Webkit" + n.charAt(0).toUpperCase() + n.substr(1) in vs.style)), t } const n_ = e_, i_ = IM; function OM(n) { const t = {}; return Object.keys(n).forEach(e => { const i = e.replace(/([a-z])([A-Z])/g, "$1-$2"); t[i] = n[e] }), t } let PM = (() => { class n { validateStyleProperty(e) { return t_(e) } matchesElement(e, i) { return !1 } containsElement(e, i) { return n_(e, i) } query(e, i, r) { return i_(e, i, r) } computeStyle(e, i, r) { return r || "" } animate(e, i, r, o, s, a = [], l) { return new Ya(r, o) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), r_ = (() => { class n { } return n.NOOP = new PM, n })(); const o_ = "ng-enter", _h = "ng-leave", vh = "ng-trigger", yh = ".ng-trigger", NM = "ng-animating", s_ = ".ng-animating"; function ys(n) { if ("number" == typeof n) return n; const t = n.match(/^(-?[\.\d]+)(m?s)/); return !t || t.length < 2 ? 0 : a_(parseFloat(t[1]), t[2]) } function a_(n, t) { return "s" === t ? 1e3 * n : n } function bh(n, t, e) { return n.hasOwnProperty("duration") ? n : function (n, t, e) { let r, o = 0, s = ""; if ("string" == typeof n) { const a = n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return t.push(`The provided timing value "${n}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = a_(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (o = a_(parseFloat(l), a[4])); const d = a[5]; d && (s = d) } else r = n; if (!e) { let a = !1, l = t.length; r < 0 && (t.push("Duration values below 0 are not allowed for this animation step."), a = !0), o < 0 && (t.push("Delay values below 0 are not allowed for this animation step."), a = !0), a && t.splice(l, 0, `The provided timing value "${n}" is invalid.`) } return { duration: r, delay: o, easing: s } }(n, t, e) } function Qa(n, t = {}) { return Object.keys(n).forEach(e => { t[e] = n[e] }), t } function Ho(n, t, e = {}) { if (t) for (let i in n) e[i] = n[i]; else Qa(n, e); return e } function BM(n, t, e) { return e ? t + ":" + e + ";" : "" } function VM(n) { let t = ""; for (let e = 0; e < n.style.length; e++) { const i = n.style.item(e); t += BM(0, i, n.style.getPropertyValue(i)) } for (const e in n.style) n.style.hasOwnProperty(e) && !e.startsWith("_") && (t += BM(0, MH(e), n.style[e])); n.setAttribute("style", t) } function kr(n, t, e) { n.style && (Object.keys(t).forEach(i => { const r = c_(i); e && !e.hasOwnProperty(i) && (e[i] = n.style[r]), n.style[r] = t[i] }), Kg() && VM(n)) } function bs(n, t) { n.style && (Object.keys(t).forEach(e => { const i = c_(e); n.style[i] = "" }), Kg() && VM(n)) } function Pc(n) { return Array.isArray(n) ? 1 == n.length ? n[0] : wM(n) : n } const l_ = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function HM(n) { let t = []; if ("string" == typeof n) { let e; for (; e = l_.exec(n);)t.push(e[1]); l_.lastIndex = 0 } return t } function Ch(n, t, e) { const i = n.toString(), r = i.replace(l_, (o, s) => { let a = t[s]; return t.hasOwnProperty(s) || (e.push(`Please provide a value for the animation param ${s}`), a = ""), a.toString() }); return r == i ? n : r } function Dh(n) { const t = []; let e = n.next(); for (; !e.done;)t.push(e.value), e = n.next(); return t } const xH = /-+([a-z0-9])/g; function c_(n) { return n.replace(xH, (...t) => t[1].toUpperCase()) } function MH(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function jM(n, t) { return 0 === n || 0 === t } function zM(n, t, e) { const i = Object.keys(e); if (i.length && t.length) { let o = t[0], s = []; if (i.forEach(a => { o.hasOwnProperty(a) || s.push(a), o[a] = e[a] }), s.length) for (var r = 1; r < t.length; r++) { let a = t[r]; s.forEach(function (l) { a[l] = d_(n, l) }) } } return t } function Ci(n, t, e) { switch (t.type) { case 7: return n.visitTrigger(t, e); case 0: return n.visitState(t, e); case 1: return n.visitTransition(t, e); case 2: return n.visitSequence(t, e); case 3: return n.visitGroup(t, e); case 4: return n.visitAnimate(t, e); case 5: return n.visitKeyframes(t, e); case 6: return n.visitStyle(t, e); case 8: return n.visitReference(t, e); case 9: return n.visitAnimateChild(t, e); case 10: return n.visitAnimateRef(t, e); case 11: return n.visitQuery(t, e); case 12: return n.visitStagger(t, e); default: throw new Error(`Unable to resolve animation metadata node #${t.type}`) } } function d_(n, t) { return window.getComputedStyle(n)[t] } function EH(n, t) { const e = []; return "string" == typeof n ? n.split(/\s*,\s*/).forEach(i => function (n, t, e) { if (":" == n[0]) { const l = function (n, t) { switch (n) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (e, i) => parseFloat(i) > parseFloat(e); case ":decrement": return (e, i) => parseFloat(i) < parseFloat(e); default: return t.push(`The transition alias value "${n}" is not supported`), "* => *" } }(n, e); if ("function" == typeof l) return void t.push(l); n = l } const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return e.push(`The provided transition expression "${n}" is not supported`), t; const r = i[1], o = i[2], s = i[3]; t.push(UM(r, s)); "<" == o[0] && !("*" == r && "*" == s) && t.push(UM(s, r)) }(i, e, t)) : e.push(n), e } const xh = new Set(["true", "1"]), Mh = new Set(["false", "0"]); function UM(n, t) { const e = xh.has(n) || Mh.has(n), i = xh.has(t) || Mh.has(t); return (r, o) => { let s = "*" == n || n == r, a = "*" == t || t == o; return !s && e && "boolean" == typeof r && (s = r ? xh.has(n) : Mh.has(n)), !a && i && "boolean" == typeof o && (a = o ? xh.has(t) : Mh.has(t)), s && a } } const kH = new RegExp("s*:selfs*,?", "g"); function u_(n, t, e) { return new AH(n).build(t, e) } class AH { constructor(t) { this._driver = t } build(t, e) { const i = new OH(e); return this._resetContextStyleTimingState(i), Ci(this, Pc(t), i) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0, r = e.depCount = 0; const o = [], s = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(a => { if (this._resetContextStyleTimingState(e), 0 == a.type) { const l = a, d = l.name; d.toString().split(/\s*,\s*/).forEach(h => { l.name = h, o.push(this.visitState(l, e)) }), l.name = d } else if (1 == a.type) { const l = this.visitTransition(a, e); i += l.queryCount, r += l.depCount, s.push(l) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: o, transitions: s, queryCount: i, depCount: r, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (i.containsDynamicStyles) { const o = new Set, s = r || {}; if (i.styles.forEach(a => { if (Eh(a)) { const l = a; Object.keys(l).forEach(d => { HM(l[d]).forEach(h => { s.hasOwnProperty(h) || o.add(h) }) }) } }), o.size) { const a = Dh(o.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${a.join(", ")}`) } } return { type: 0, name: t.name, style: i, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = Ci(this, Pc(t.animation), e); return { type: 1, matchers: EH(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: Cs(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(i => Ci(this, i, e)), options: Cs(t.options) } } visitGroup(t, e) { const i = e.currentTime; let r = 0; const o = t.steps.map(s => { e.currentTime = i; const a = Ci(this, s, e); return r = Math.max(r, e.currentTime), a }); return e.currentTime = r, { type: 3, steps: o, options: Cs(t.options) } } visitAnimate(t, e) { const i = function (n, t) { let e = null; if (n.hasOwnProperty("duration")) e = n; else if ("number" == typeof n) return h_(bh(n, t).duration, 0, ""); const i = n; if (i.split(/\s+/).some(o => "{" == o.charAt(0) && "{" == o.charAt(1))) { const o = h_(0, 0, ""); return o.dynamic = !0, o.strValue = i, o } return e = e || bh(i, t), h_(e.duration, e.delay, e.easing) }(t.timings, e.errors); e.currentAnimateTimings = i; let r, o = t.styles ? t.styles : ne({}); if (5 == o.type) r = this.visitKeyframes(o, e); else { let s = t.styles, a = !1; if (!s) { a = !0; const d = {}; i.easing && (d.easing = i.easing), s = ne(d) } e.currentTime += i.duration + i.delay; const l = this.visitStyle(s, e); l.isEmptyStep = a, r = l } return e.currentAnimateTimings = null, { type: 4, timings: i, style: r, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = []; Array.isArray(t.styles) ? t.styles.forEach(s => { "string" == typeof s ? s == co ? i.push(s) : e.errors.push(`The provided style string value ${s} is not allowed.`) : i.push(s) }) : i.push(t.styles); let r = !1, o = null; return i.forEach(s => { if (Eh(s)) { const a = s, l = a.easing; if (l && (o = l, delete a.easing), !r) for (let d in a) if (a[d].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: i, easing: o, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let r = e.currentTime, o = e.currentTime; i && o > 0 && (o -= i.duration + i.delay), t.styles.forEach(s => { "string" != typeof s && Object.keys(s).forEach(a => { if (!this._driver.validateStyleProperty(a)) return void e.errors.push(`The provided animation property "${a}" is not a supported CSS property for animations`); const l = e.collectedStyles[e.currentQuerySelector], d = l[a]; let h = !0; d && (o != r && o >= d.startTime && r <= d.endTime && (e.errors.push(`The CSS property "${a}" that exists between the times of "${d.startTime}ms" and "${d.endTime}ms" is also being animated in a parallel animation between the times of "${o}ms" and "${r}ms"`), h = !1), o = d.startTime), h && (l[a] = { startTime: o, endTime: r }), e.options && function (n, t, e) { const i = t.params || {}, r = HM(n); r.length && r.forEach(o => { i.hasOwnProperty(o) || e.push(`Unable to resolve the local animation param ${o} in the given list of values`) }) }(s[a], e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i; let o = 0; const s = []; let a = !1, l = !1, d = 0; const h = t.steps.map(H => { const F = this._makeStyleAst(H, e); let W = null != F.offset ? F.offset : function (n) { if ("string" == typeof n) return null; let t = null; if (Array.isArray(n)) n.forEach(e => { if (Eh(e) && e.hasOwnProperty("offset")) { const i = e; t = parseFloat(i.offset), delete i.offset } }); else if (Eh(n) && n.hasOwnProperty("offset")) { const e = n; t = parseFloat(e.offset), delete e.offset } return t }(F.styles), ie = 0; return null != W && (o++, ie = F.offset = W), l = l || ie < 0 || ie > 1, a = a || ie < d, d = ie, s.push(ie), F }); l && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), a && e.errors.push("Please ensure that all keyframe offsets are in order"); const m = t.steps.length; let y = 0; o > 0 && o < m ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == o && (y = 1 / (m - 1)); const D = m - 1, M = e.currentTime, k = e.currentAnimateTimings, P = k.duration; return h.forEach((H, F) => { const W = y > 0 ? F == D ? 1 : y * F : s[F], ie = W * P; e.currentTime = M + k.delay + ie, k.duration = ie, this._validateStyleAst(H, e), H.offset = W, i.styles.push(H) }), i } visitReference(t, e) { return { type: 8, animation: Ci(this, Pc(t.animation), e), options: Cs(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Cs(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Cs(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [o, s] = function (n) { const t = !!n.split(/\s*,\s*/).find(e => ":self" == e); return t && (n = n.replace(kH, "")), n = n.replace(/@\*/g, yh).replace(/@\w+/g, e => yh + "-" + e.substr(1)).replace(/:animating/g, s_), [n, t] }(t.selector); e.currentQuerySelector = i.length ? i + " " + o : o, bi(e.collectedStyles, e.currentQuerySelector, {}); const a = Ci(this, Pc(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: o, limit: r.limit || 0, optional: !!r.optional, includeSelf: s, animation: a, originalSelector: t.selector, options: Cs(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : bh(t.timings, e.errors, !0); return { type: 12, animation: Ci(this, Pc(t.animation), e), timings: i, options: null } } } class OH { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Eh(n) { return !Array.isArray(n) && "object" == typeof n } function Cs(n) { return n ? (n = Qa(n)).params && (n.params = function (n) { return n ? Qa(n) : null }(n.params)) : n = {}, n } function h_(n, t, e) { return { duration: n, delay: t, easing: e } } function f_(n, t, e, i, r, o, s = null, a = !1) { return { type: 1, element: n, keyframes: t, preStyleProps: e, postStyleProps: i, duration: r, delay: o, totalTime: r + o, easing: s, subTimeline: a } } class Sh { constructor() { this._map = new Map } get(t) { return this._map.get(t) || [] } append(t, e) { let i = this._map.get(t); i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const BH = new RegExp(":enter", "g"), HH = new RegExp(":leave", "g"); function p_(n, t, e, i, r, o = {}, s = {}, a, l, d = []) { return (new jH).buildKeyframes(n, t, e, i, r, o, s, a, l, d) } class jH { buildKeyframes(t, e, i, r, o, s, a, l, d, h = []) { d = d || new Sh; const m = new m_(t, e, d, r, o, h, []); m.options = l, m.currentTimeline.setStyles([s], null, m.errors, l), Ci(this, i, m); const y = m.timelines.filter(D => D.containsAnimation()); if (y.length && Object.keys(a).length) { const D = y[y.length - 1]; D.allowOnlyTimelineStyles() || D.setStyles([a], null, m.errors, l) } return y.length ? y.map(D => D.buildKeyframes()) : [f_(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const i = e.subInstructions.get(e.element); if (i) { const r = e.createSubContext(t.options), o = e.currentTimeline.currentTime, s = this._visitSubInstructions(i, r, r.options); o != s && e.transformIntoNewTimeline(s) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options); i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let o = e.currentTimeline.currentTime; const s = null != i.duration ? ys(i.duration) : null, a = null != i.delay ? ys(i.delay) : null; return 0 !== s && t.forEach(l => { const d = e.appendInstructionToTimeline(l, s, a); o = Math.max(o, d.duration + d.delay) }), o } visitReference(t, e) { e.updateOptions(t.options, !0), Ci(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let r = e; const o = t.options; if (o && (o.params || o.delay) && (r = e.createSubContext(o), r.transformIntoNewTimeline(), null != o.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = Th); const s = ys(o.delay); r.delayNextStep(s) } t.steps.length && (t.steps.forEach(s => Ci(this, s, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > i && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let r = e.currentTimeline.currentTime; const o = t.options && t.options.delay ? ys(t.options.delay) : 0; t.steps.forEach(s => { const a = e.createSubContext(t.options); o && a.delayNextStep(o), Ci(this, s, a), r = Math.max(r, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(s => e.currentTimeline.mergeTimelineCollectedStyles(s)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return bh(e.params ? Ch(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles()); const o = t.style; 5 == o.type ? this.visitKeyframes(o, e) : (e.incrementTime(i.duration), this.visitStyle(o, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline, r = e.currentAnimateTimings; !r && i.getCurrentStyleProperties().length && i.forwardFrame(); const o = r && r.easing || t.easing; t.isEmptyStep ? i.applyEmptyStep(o) : i.setStyles(t.styles, o, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings, r = e.currentTimeline.duration, o = i.duration, a = e.createSubContext().currentTimeline; a.easing = i.easing, t.styles.forEach(l => { a.forwardTime((l.offset || 0) * o), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(r + o), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime, r = t.options || {}, o = r.delay ? ys(r.delay) : 0; o && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Th); let s = i; const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = a.length; let l = null; a.forEach((d, h) => { e.currentQueryIndex = h; const m = e.createSubContext(t.options, d); o && m.delayNextStep(o), d === e.element && (l = m.currentTimeline), Ci(this, t.animation, m), m.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, m.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext, r = e.currentTimeline, o = t.timings, s = Math.abs(o.duration), a = s * (e.currentQueryTotal - 1); let l = s * e.currentQueryIndex; switch (o.duration < 0 ? "reverse" : o.easing) { case "reverse": l = a - l; break; case "full": l = i.currentStaggerTime }const h = e.currentTimeline; l && h.delayNextStep(l); const m = h.currentTime; Ci(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = r.currentTime - m + (r.startTime - i.currentTimeline.startTime) } } const Th = {}; class m_ { constructor(t, e, i, r, o, s, a, l) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = r, this._leaveClassName = o, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Th, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new kh(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let r = this.options; null != i.duration && (r.duration = ys(i.duration)), null != i.delay && (r.delay = ys(i.delay)); const o = i.params; if (o) { let s = r.params; s || (s = this.options.params = {}), Object.keys(o).forEach(a => { (!e || !s.hasOwnProperty(a)) && (s[a] = Ch(o[a], s, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {}; Object.keys(e).forEach(r => { i[r] = e[r] }) } } return t } createSubContext(t = null, e, i) { const r = e || this.element, o = new m_(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, i || 0)); return o.previousNode = this.previousNode, o.currentAnimateTimings = this.currentAnimateTimings, o.options = this._copyOptions(), o.updateOptions(t), o.currentQueryIndex = this.currentQueryIndex, o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this, this.subContextCount++, o } transformIntoNewTimeline(t) { return this.previousNode = Th, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay, easing: "" }, o = new zH(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(o), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, r, o, s) { let a = []; if (r && a.push(this.element), t.length > 0) { t = (t = t.replace(BH, "." + this._enterClassName)).replace(HH, "." + this._leaveClassName); let d = this._driver.query(this.element, t, 1 != i); 0 !== i && (d = i < 0 ? d.slice(d.length + i, d.length) : d.slice(0, i)), a.push(...d) } return !o && 0 == a.length && s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), a } } class kh { constructor(t, e, i, r) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new kh(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(e => { this._backFill[e] = this._globalTimelineStyles[e] || co, this._currentKeyframe[e] = co }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, r) { e && (this._previousKeyframe.easing = e); const o = r && r.params || {}, s = function (n, t) { const e = {}; let i; return n.forEach(r => { "*" === r ? (i = i || Object.keys(t), i.forEach(o => { e[o] = co })) : Ho(r, !1, e) }), e }(t, this._globalTimelineStyles); Object.keys(s).forEach(a => { const l = Ch(s[a], o, i); this._pendingStyles[a] = l, this._localTimelineStyles.hasOwnProperty(a) || (this._backFill[a] = this._globalTimelineStyles.hasOwnProperty(a) ? this._globalTimelineStyles[a] : co), this._updateStyle(a, l) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(i => { this._currentKeyframe[i] = t[i] }), Object.keys(this._localTimelineStyles).forEach(i => { this._currentKeyframe.hasOwnProperty(i) || (this._currentKeyframe[i] = this._localTimelineStyles[i]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const i = this._styleSummary[e], r = t._styleSummary[e]; (!i || r.time > i.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((a, l) => { const d = Ho(a, !0); Object.keys(d).forEach(h => { const m = d[h]; "!" == m ? t.add(h) : m == co && e.add(h) }), i || (d.offset = l / this.duration), r.push(d) }); const o = t.size ? Dh(t.values()) : [], s = e.size ? Dh(e.values()) : []; if (i) { const a = r[0], l = Qa(a); a.offset = 0, l.offset = 1, r = [a, l] } return f_(this.element, r, o, s, this.duration, this.startTime, this.easing, !1) } } class zH extends kh { constructor(t, e, i, r, o, s, a = !1) { super(t, e, s.delay), this.keyframes = i, this.preStyleProps = r, this.postStyleProps = o, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: i, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const o = [], s = i + e, a = e / s, l = Ho(t[0], !1); l.offset = 0, o.push(l); const d = Ho(t[0], !1); d.offset = qM(a), o.push(d); const h = t.length - 1; for (let m = 1; m <= h; m++) { let y = Ho(t[m], !1); y.offset = qM((e + y.offset * i) / s), o.push(y) } i = s, e = 0, r = "", t = o } return f_(this.element, t, this.preStyleProps, this.postStyleProps, i, e, r, !0) } } function qM(n, t = 3) { const e = Math.pow(10, t - 1); return Math.round(n * e) / e } class g_ { } class $H extends g_ { normalizePropertyName(t, e) { return c_(t) } normalizeStyleValue(t, e, i, r) { let o = ""; const s = i.toString().trim(); if (GH[e] && 0 !== i && "0" !== i) if ("number" == typeof i) o = "px"; else { const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && r.push(`Please provide a CSS unit value for ${t}:${i}`) } return s + o } } const GH = (() => function (n) { const t = {}; return n.forEach(e => t[e] = !0), t }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function WM(n, t, e, i, r, o, s, a, l, d, h, m, y) { return { type: 0, element: n, triggerName: t, isRemovalTransition: r, fromState: e, fromStyles: o, toState: i, toStyles: s, timelines: a, queriedElements: l, preStyleProps: d, postStyleProps: h, totalTime: m, errors: y } } const __ = {}; class YM { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, r) { return function (n, t, e, i, r) { return n.some(o => o(t, e, i, r)) }(this.ast.matchers, t, e, i, r) } buildStyles(t, e, i) { const r = this._stateStyles["*"], o = this._stateStyles[t], s = r ? r.buildStyles(e, i) : {}; return o ? o.buildStyles(e, i) : s } build(t, e, i, r, o, s, a, l, d, h) { const m = [], y = this.ast.options && this.ast.options.params || __, M = this.buildStyles(i, a && a.params || __, m), k = l && l.params || __, P = this.buildStyles(r, k, m), H = new Set, F = new Map, W = new Map, ie = "void" === r, $e = { params: Object.assign(Object.assign({}, y), k) }, Tt = h ? [] : p_(t, e, this.ast.animation, o, s, M, P, $e, d, m); let Ot = 0; if (Tt.forEach(wi => { Ot = Math.max(wi.duration + wi.delay, Ot) }), m.length) return WM(e, this._triggerName, i, r, ie, M, P, [], [], F, W, Ot, m); Tt.forEach(wi => { const xi = wi.element, dl = bi(F, xi, {}); wi.preStyleProps.forEach(or => dl[or] = !0); const _o = bi(W, xi, {}); wi.postStyleProps.forEach(or => _o[or] = !0), xi !== e && H.add(xi) }); const Di = Dh(H.values()); return WM(e, this._triggerName, i, r, ie, M, P, Tt, Di, F, W, Ot) } } class YH { constructor(t, e, i) { this.styles = t, this.defaultParams = e, this.normalizer = i } buildStyles(t, e) { const i = {}, r = Qa(this.defaultParams); return Object.keys(t).forEach(o => { const s = t[o]; null != s && (r[o] = s) }), this.styles.styles.forEach(o => { if ("string" != typeof o) { const s = o; Object.keys(s).forEach(a => { let l = s[a]; l.length > 1 && (l = Ch(l, r, e)); const d = this.normalizer.normalizePropertyName(a, e); l = this.normalizer.normalizeStyleValue(a, d, l, e), i[d] = l }) } }), i } } class KH { constructor(t, e, i) { this.name = t, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = {}, e.states.forEach(r => { this.states[r.name] = new YH(r.style, r.options && r.options.params || {}, i) }), QM(this.states, "true", "1"), QM(this.states, "false", "0"), e.transitions.forEach(r => { this.transitionFactories.push(new YM(t, r, this.states)) }), this.fallbackTransition = function (n, t, e) { return new YM(n, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(s, a) => !0], options: null, queryCount: 0, depCount: 0 }, t) }(t, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, r) { return this.transitionFactories.find(s => s.match(t, e, i, r)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } } function QM(n, t, e) { n.hasOwnProperty(t) ? n.hasOwnProperty(e) || (n[e] = n[t]) : n.hasOwnProperty(e) && (n[t] = n[e]) } const ZH = new Sh; class JH { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const i = [], r = u_(this._driver, e, i); if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`); this._animations[t] = r } _buildPlayer(t, e, i) { const r = t.element, o = kM(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(r, o, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const r = [], o = this._animations[t]; let s; const a = new Map; if (o ? (s = p_(this._driver, e, o, o_, _h, {}, {}, i, ZH, r), s.forEach(h => { const m = bi(a, h.element, {}); h.postStyleProps.forEach(y => m[y] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), s = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`); a.forEach((h, m) => { Object.keys(h).forEach(y => { h[y] = this._driver.computeStyle(m, y, co) }) }); const d = Vo(s.map(h => { const m = a.get(h.element); return this._buildPlayer(h, {}, m) })); return this._playersById[t] = d, d.onDestroy(() => this.destroy(t)), this.players.push(d), d } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, i, r) { const o = Jg(e, "", "", ""); return Xg(this._getPlayer(t), i, o, r), () => { } } command(t, e, i, r) { if ("register" == i) return void this.register(t, r[0]); if ("create" == i) return void this.create(t, e, r[0] || {}); const o = this._getPlayer(t); switch (i) { case "play": o.play(); break; case "pause": o.pause(); break; case "reset": o.reset(); break; case "restart": o.restart(); break; case "finish": o.finish(); break; case "init": o.init(); break; case "setPosition": o.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const KM = "ng-animate-queued", v_ = "ng-animate-disabled", rj = [], XM = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, oj = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Li = "__ng_removed"; class y_ { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = null != (n = i ? t.value : t) ? n : null, i) { const o = Qa(t); delete o.value, this.options = o } else this.options = {}; var n; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const i = this.options.params; Object.keys(e).forEach(r => { null == i[r] && (i[r] = e[r]) }) } } } const Fc = "void", b_ = new y_(Fc); class sj { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Bi(e, this._hostClassName) } listen(t, e, i, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`); if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (n = i) && "done" != n) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`); var n; const o = bi(this._elementListeners, t, []), s = { name: e, phase: i, callback: r }; o.push(s); const a = bi(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (Bi(t, vh), Bi(t, vh + "-" + e), a[e] = b_), () => { this._engine.afterFlush(() => { const l = o.indexOf(s); l >= 0 && o.splice(l, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, i, r = !0) { const o = this._getTrigger(e), s = new C_(this.id, e, t); let a = this._engine.statesByElement.get(t); a || (Bi(t, vh), Bi(t, vh + "-" + e), this._engine.statesByElement.set(t, a = {})); let l = a[e]; const d = new y_(i, this.id); if (!(i && i.hasOwnProperty("value")) && l && d.absorbOptions(l.options), a[e] = d, l || (l = b_), d.value !== Fc && l.value === d.value) { if (!function (n, t) { const e = Object.keys(n), i = Object.keys(t); if (e.length != i.length) return !1; for (let r = 0; r < e.length; r++) { const o = e[r]; if (!t.hasOwnProperty(o) || n[o] !== t[o]) return !1 } return !0 }(l.params, d.params)) { const k = [], P = o.matchStyles(l.value, l.params, k), H = o.matchStyles(d.value, d.params, k); k.length ? this._engine.reportError(k) : this._engine.afterFlush(() => { bs(t, P), kr(t, H) }) } return } const y = bi(this._engine.playersByElement, t, []); y.forEach(k => { k.namespaceId == this.id && k.triggerName == e && k.queued && k.destroy() }); let D = o.matchTransition(l.value, d.value, t, d.params), M = !1; if (!D) { if (!r) return; D = o.fallbackTransition, M = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: D, fromState: l, toState: d, player: s, isFallbackTransition: M }), M || (Bi(t, KM), s.onStart(() => { Ka(t, KM) })), s.onDone(() => { let k = this.players.indexOf(s); k >= 0 && this.players.splice(k, 1); const P = this._engine.playersByElement.get(t); if (P) { let H = P.indexOf(s); H >= 0 && P.splice(H, 1) } }), this.players.push(s), y.push(s), s } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => { delete e[t] }), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(r => r.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, yh, !0); i.forEach(r => { if (r[Li]) return; const o = this._engine.fetchNamespacesByElement(r); o.size ? o.forEach(s => s.triggerLeaveAnimation(r, e, !1, !0)) : this.clearElementCache(r) }), this._engine.afterFlushAnimationsDone(() => i.forEach(r => this.clearElementCache(r))) } triggerLeaveAnimation(t, e, i, r) { const o = this._engine.statesByElement.get(t); if (o) { const s = []; if (Object.keys(o).forEach(a => { if (this._triggers[a]) { const l = this.trigger(t, a, Fc, r); l && s.push(l) } }), s.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), i && Vo(s).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), i = this._engine.statesByElement.get(t); if (e && i) { const r = new Set; e.forEach(o => { const s = o.name; if (r.has(s)) return; r.add(s); const l = this._triggers[s].fallbackTransition, d = i[s] || b_, h = new y_(Fc), m = new C_(this.id, s, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: l, fromState: d, toState: h, player: m, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (i.totalAnimations) { const o = i.players.length ? i.playersByQueriedElement.get(t) : []; if (o && o.length) r = !0; else { let s = t; for (; s = s.parentNode;)if (i.statesByElement.get(s)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) i.markElementAsRemoved(this.id, t, !1, e); else { const o = t[Li]; (!o || o === XM) && (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { Bi(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const r = i.player; if (r.destroyed) return; const o = i.element, s = this._elementListeners.get(o); s && s.forEach(a => { if (a.name == i.triggerName) { const l = Jg(o, i.triggerName, i.fromState.value, i.toState.value); l._data = t, Xg(i.player, a.phase, l, a.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(i) }), this._queue = [], e.sort((i, r) => { const o = i.transition.ast.depCount, s = r.transition.ast.depCount; return 0 == o || 0 == s ? o - s : this._engine.driver.containsElement(i.element, r.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(i => i.element === t) || e, e } } class aj { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (r, o) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(i => { i.queued && t.push(i) }) }), t } createNamespace(t, e) { const i = new sj(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList.length - 1; if (i >= 0) { let r = !1; for (let o = i; o >= 0; o--)if (this.driver.containsElement(this._namespaceList[o].hostElement, e)) { this._namespaceList.splice(o + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let r = this._namespaceLookup[t]; r && r.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const r = this._namespaceList.indexOf(i); r >= 0 && this._namespaceList.splice(r, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, i = this.statesByElement.get(t); if (i) { const r = Object.keys(i); for (let o = 0; o < r.length; o++) { const s = i[r[o]].namespaceId; if (s) { const a = this._fetchNamespace(s); a && e.add(a) } } } return e } trigger(t, e, i, r) { if (Ah(e)) { const o = this._fetchNamespace(t); if (o) return o.trigger(e, i, r), !0 } return !1 } insertNode(t, e, i, r) { if (!Ah(e)) return; const o = e[Li]; if (o && o.setForRemoval) { o.setForRemoval = !1, o.setForMove = !0; const s = this.collectedLeaveElements.indexOf(e); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (t) { const s = this._fetchNamespace(t); s && s.insertNode(e, i) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Bi(t, v_)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Ka(t, v_)) } removeNode(t, e, i, r) { if (Ah(e)) { const o = t ? this._fetchNamespace(t) : null; if (o ? o.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), i) { const s = this.namespacesByHostElement.get(e); s && s.id !== t && s.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, i, r) { this.collectedLeaveElements.push(e), e[Li] = { namespaceId: t, setForRemoval: r, hasAnimation: i, removedBeforeQueried: !1 } } listen(t, e, i, r, o) { return Ah(e) ? this._fetchNamespace(t).listen(e, i, r, o) : () => { } } _buildInstruction(t, e, i, r, o) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, r, t.fromState.options, t.toState.options, e, o) } destroyInnerAnimations(t) { let e = this.driver.query(t, yh, !0); e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, s_, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(i => { i.queued ? i.markedForDestroy = !0 : i.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(i => i.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Vo(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { var e; const i = t[Li]; if (i && i.setForRemoval) { if (t[Li] = XM, i.namespaceId) { this.destroyInnerAnimations(t); const r = this._fetchNamespace(i.namespaceId); r && r.clearElementCache(t) } this._onRemovalComplete(t, i.setForRemoval) } (null === (e = t.classList) || void 0 === e ? void 0 : e.contains(v_)) && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((i, r) => this._balanceNamespaceList(i, r)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)Bi(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let r = 0; r < i.length; r++)i[r]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) { const i = this._whenQuietFns; this._whenQuietFns = [], e.length ? Vo(e).onDone(() => { i.forEach(r => r()) }) : i.forEach(r => r()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const i = new Sh, r = [], o = new Map, s = [], a = new Map, l = new Map, d = new Map, h = new Set; this.disabledNodes.forEach(ae => { h.add(ae); const _e = this.driver.query(ae, ".ng-animate-queued", !0); for (let Ne = 0; Ne < _e.length; Ne++)h.add(_e[Ne]) }); const m = this.bodyNode, y = Array.from(this.statesByElement.keys()), D = eE(y, this.collectedEnterElements), M = new Map; let k = 0; D.forEach((ae, _e) => { const Ne = o_ + k++; M.set(_e, Ne), ae.forEach(ct => Bi(ct, Ne)) }); const P = [], H = new Set, F = new Set; for (let ae = 0; ae < this.collectedLeaveElements.length; ae++) { const _e = this.collectedLeaveElements[ae], Ne = _e[Li]; Ne && Ne.setForRemoval && (P.push(_e), H.add(_e), Ne.hasAnimation ? this.driver.query(_e, ".ng-star-inserted", !0).forEach(ct => H.add(ct)) : F.add(_e)) } const W = new Map, ie = eE(y, Array.from(H)); ie.forEach((ae, _e) => { const Ne = _h + k++; W.set(_e, Ne), ae.forEach(ct => Bi(ct, Ne)) }), t.push(() => { D.forEach((ae, _e) => { const Ne = M.get(_e); ae.forEach(ct => Ka(ct, Ne)) }), ie.forEach((ae, _e) => { const Ne = W.get(_e); ae.forEach(ct => Ka(ct, Ne)) }), P.forEach(ae => { this.processLeaveNode(ae) }) }); const $e = [], Tt = []; for (let ae = this._namespaceList.length - 1; ae >= 0; ae--)this._namespaceList[ae].drainQueuedTransitions(e).forEach(Ne => { const ct = Ne.player, Cn = Ne.element; if ($e.push(ct), this.collectedEnterElements.length) { const ji = Cn[Li]; if (ji && ji.setForMove) return void ct.destroy() } const Fr = !m || !this.driver.containsElement(m, Cn), Mi = W.get(Cn), Yo = M.get(Cn), Pt = this._buildInstruction(Ne, i, Yo, Mi, Fr); if (Pt.errors && Pt.errors.length) return void Tt.push(Pt); if (Fr) return ct.onStart(() => bs(Cn, Pt.fromStyles)), ct.onDestroy(() => kr(Cn, Pt.toStyles)), void r.push(ct); if (Ne.isFallbackTransition) return ct.onStart(() => bs(Cn, Pt.fromStyles)), ct.onDestroy(() => kr(Cn, Pt.toStyles)), void r.push(ct); const Rk = []; Pt.timelines.forEach(ji => { ji.stretchStartingKeyframe = !0, this.disabledNodes.has(ji.element) || Rk.push(ji) }), Pt.timelines = Rk, i.append(Cn, Pt.timelines), s.push({ instruction: Pt, player: ct, element: Cn }), Pt.queriedElements.forEach(ji => bi(a, ji, []).push(ct)), Pt.preStyleProps.forEach((ji, ld) => { const Tf = Object.keys(ji); if (Tf.length) { let ks = l.get(ld); ks || l.set(ld, ks = new Set), Tf.forEach(Qv => ks.add(Qv)) } }), Pt.postStyleProps.forEach((ji, ld) => { const Tf = Object.keys(ji); let ks = d.get(ld); ks || d.set(ld, ks = new Set), Tf.forEach(Qv => ks.add(Qv)) }) }); if (Tt.length) { const ae = []; Tt.forEach(_e => { ae.push(`@${_e.triggerName} has failed due to:\n`), _e.errors.forEach(Ne => ae.push(`- ${Ne}\n`)) }), $e.forEach(_e => _e.destroy()), this.reportError(ae) } const Ot = new Map, Di = new Map; s.forEach(ae => { const _e = ae.element; i.has(_e) && (Di.set(_e, _e), this._beforeAnimationBuild(ae.player.namespaceId, ae.instruction, Ot)) }), r.forEach(ae => { const _e = ae.element; this._getPreviousPlayers(_e, !1, ae.namespaceId, ae.triggerName, null).forEach(ct => { bi(Ot, _e, []).push(ct), ct.destroy() }) }); const wi = P.filter(ae => nE(ae, l, d)), xi = new Map; JM(xi, this.driver, F, d, co).forEach(ae => { nE(ae, l, d) && wi.push(ae) }); const _o = new Map; D.forEach((ae, _e) => { JM(_o, this.driver, new Set(ae), l, "!") }), wi.forEach(ae => { const _e = xi.get(ae), Ne = _o.get(ae); xi.set(ae, Object.assign(Object.assign({}, _e), Ne)) }); const or = [], ul = [], hl = {}; s.forEach(ae => { const { element: _e, player: Ne, instruction: ct } = ae; if (i.has(_e)) { if (h.has(_e)) return Ne.onDestroy(() => kr(_e, ct.toStyles)), Ne.disabled = !0, Ne.overrideTotalTime(ct.totalTime), void r.push(Ne); let Cn = hl; if (Di.size > 1) { let Mi = _e; const Yo = []; for (; Mi = Mi.parentNode;) { const Pt = Di.get(Mi); if (Pt) { Cn = Pt; break } Yo.push(Mi) } Yo.forEach(Pt => Di.set(Pt, Cn)) } const Fr = this._buildAnimation(Ne.namespaceId, ct, Ot, o, _o, xi); if (Ne.setRealPlayer(Fr), Cn === hl) or.push(Ne); else { const Mi = this.playersByElement.get(Cn); Mi && Mi.length && (Ne.parentPlayer = Vo(Mi)), r.push(Ne) } } else bs(_e, ct.fromStyles), Ne.onDestroy(() => kr(_e, ct.toStyles)), ul.push(Ne), h.has(_e) && r.push(Ne) }), ul.forEach(ae => { const _e = o.get(ae.element); if (_e && _e.length) { const Ne = Vo(_e); ae.setRealPlayer(Ne) } }), r.forEach(ae => { ae.parentPlayer ? ae.syncPlayerEvents(ae.parentPlayer) : ae.destroy() }); for (let ae = 0; ae < P.length; ae++) { const _e = P[ae], Ne = _e[Li]; if (Ka(_e, _h), Ne && Ne.hasAnimation) continue; let ct = []; if (a.size) { let Fr = a.get(_e); Fr && Fr.length && ct.push(...Fr); let Mi = this.driver.query(_e, s_, !0); for (let Yo = 0; Yo < Mi.length; Yo++) { let Pt = a.get(Mi[Yo]); Pt && Pt.length && ct.push(...Pt) } } const Cn = ct.filter(Fr => !Fr.destroyed); Cn.length ? uj(this, _e, Cn) : this.processLeaveNode(_e) } return P.length = 0, or.forEach(ae => { this.players.push(ae), ae.onDone(() => { ae.destroy(); const _e = this.players.indexOf(ae); this.players.splice(_e, 1) }), ae.play() }), or } elementContainsData(t, e) { let i = !1; const r = e[Li]; return r && r.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, r, o) { let s = []; if (e) { const a = this.playersByQueriedElement.get(t); a && (s = a) } else { const a = this.playersByElement.get(t); if (a) { const l = !o || o == Fc; a.forEach(d => { d.queued || !l && d.triggerName != r || s.push(d) }) } } return (i || r) && (s = s.filter(a => !(i && i != a.namespaceId || r && r != a.triggerName))), s } _beforeAnimationBuild(t, e, i) { const o = e.element, s = e.isRemovalTransition ? void 0 : t, a = e.isRemovalTransition ? void 0 : e.triggerName; for (const l of e.timelines) { const d = l.element, h = d !== o, m = bi(i, d, []); this._getPreviousPlayers(d, h, s, a, e.toState).forEach(D => { const M = D.getRealPlayer(); M.beforeDestroy && M.beforeDestroy(), D.destroy(), m.push(D) }) } bs(o, e.fromStyles) } _buildAnimation(t, e, i, r, o, s) { const a = e.triggerName, l = e.element, d = [], h = new Set, m = new Set, y = e.timelines.map(M => { const k = M.element; h.add(k); const P = k[Li]; if (P && P.removedBeforeQueried) return new Ya(M.duration, M.delay); const H = k !== l, F = function (n) { const t = []; return tE(n, t), t }((i.get(k) || rj).map(Ot => Ot.getRealPlayer())).filter(Ot => !!Ot.element && Ot.element === k), W = o.get(k), ie = s.get(k), $e = kM(0, this._normalizer, 0, M.keyframes, W, ie), Tt = this._buildPlayer(M, $e, F); if (M.subTimeline && r && m.add(k), H) { const Ot = new C_(t, a, k); Ot.setRealPlayer(Tt), d.push(Ot) } return Tt }); d.forEach(M => { bi(this.playersByQueriedElement, M.element, []).push(M), M.onDone(() => function (n, t, e) { let i; if (n instanceof Map) { if (i = n.get(t), i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && n.delete(t) } } else if (i = n[t], i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && delete n[t] } return i }(this.playersByQueriedElement, M.element, M)) }), h.forEach(M => Bi(M, NM)); const D = Vo(y); return D.onDestroy(() => { h.forEach(M => Ka(M, NM)), kr(l, e.toStyles) }), m.forEach(M => { bi(r, M, []).push(D) }), D } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new Ya(t.duration, t.delay) } } class C_ { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new Ya, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(i => Xg(t, e, void 0, i)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { bi(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Ah(n) { return n && 1 === n.nodeType } function ZM(n, t) { const e = n.style.display; return n.style.display = null != t ? t : "none", e } function JM(n, t, e, i, r) { const o = []; e.forEach(l => o.push(ZM(l))); const s = []; i.forEach((l, d) => { const h = {}; l.forEach(m => { const y = h[m] = t.computeStyle(d, m, r); (!y || 0 == y.length) && (d[Li] = oj, s.push(d)) }), n.set(d, h) }); let a = 0; return e.forEach(l => ZM(l, o[a++])), s } function eE(n, t) { const e = new Map; if (n.forEach(a => e.set(a, [])), 0 == t.length) return e; const r = new Set(t), o = new Map; function s(a) { if (!a) return 1; let l = o.get(a); if (l) return l; const d = a.parentNode; return l = e.has(d) ? d : r.has(d) ? 1 : s(d), o.set(a, l), l } return t.forEach(a => { const l = s(a); 1 !== l && e.get(l).push(a) }), e } function Bi(n, t) { var e; null === (e = n.classList) || void 0 === e || e.add(t) } function Ka(n, t) { var e; null === (e = n.classList) || void 0 === e || e.remove(t) } function uj(n, t, e) { Vo(e).onDone(() => n.processLeaveNode(t)) } function tE(n, t) { for (let e = 0; e < n.length; e++) { const i = n[e]; i instanceof SM ? tE(i.players, t) : t.push(i) } } function nE(n, t, e) { const i = e.get(n); if (!i) return !1; let r = t.get(n); return r ? i.forEach(o => r.add(o)) : t.set(n, i), e.delete(n), !0 } class Ih { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (r, o) => { }, this._transitionEngine = new aj(t, e, i), this._timelineEngine = new JH(t, e, i), this._transitionEngine.onRemovalComplete = (r, o) => this.onRemovalComplete(r, o) } registerTrigger(t, e, i, r, o) { const s = t + "-" + r; let a = this._triggerCache[s]; if (!a) { const l = [], d = u_(this._driver, o, l); if (l.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${l.join("\n - ")}`); a = function (n, t, e) { return new KH(n, t, e) }(r, d, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(e, r, a) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, r) { this._transitionEngine.insertNode(t, e, i, r) } onRemove(t, e, i, r) { this._transitionEngine.removeNode(t, e, r || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, r) { if ("@" == i.charAt(0)) { const [o, s] = AM(i); this._timelineEngine.command(o, e, s, r) } else this._transitionEngine.trigger(t, e, i, r) } listen(t, e, i, r, o) { if ("@" == i.charAt(0)) { const [s, a] = AM(i); return this._timelineEngine.listen(s, e, a, o) } return this._transitionEngine.listen(t, e, i, r, o) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function iE(n, t) { let e = null, i = null; return Array.isArray(t) && t.length ? (e = D_(t[0]), t.length > 1 && (i = D_(t[t.length - 1]))) : t && (e = D_(t)), e || i ? new pj(n, e, i) : null } let pj = (() => { class n { constructor(e, i, r) { this._element = e, this._startStyles = i, this._endStyles = r, this._state = 0; let o = n.initialStylesByElement.get(e); o || n.initialStylesByElement.set(e, o = {}), this._initialStyles = o } start() { this._state < 1 && (this._startStyles && kr(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (kr(this._element, this._initialStyles), this._endStyles && (kr(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (n.initialStylesByElement.delete(this._element), this._startStyles && (bs(this._element, this._startStyles), this._endStyles = null), this._endStyles && (bs(this._element, this._endStyles), this._endStyles = null), kr(this._element, this._initialStyles), this._state = 3) } } return n.initialStylesByElement = new WeakMap, n })(); function D_(n) { let t = null; const e = Object.keys(n); for (let i = 0; i < e.length; i++) { const r = e[i]; mj(r) && (t = t || {}, t[r] = n[r]) } return t } function mj(n) { return "display" === n || "position" === n } const rE = "animation", oE = "animationend"; class vj { constructor(t, e, i, r, o, s, a) { this._element = t, this._name = e, this._duration = i, this._delay = r, this._easing = o, this._fillMode = s, this._onDoneFn = a, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = l => this._handleCallback(l) } apply() { (function (n, t) { const e = x_(n, "").trim(); let i = 0; e.length && (function (n, t) { let e = 0; for (let i = 0; i < n.length; i++)"," === n.charAt(i) && e++; return e }(e) + 1, t = `${e}, ${t}`), Rh(n, "", t) })(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), lE(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { sE(this._element, this._name, "paused") } resume() { sE(this._element, this._name, "running") } setPosition(t) { const e = aE(this._element, this._name); this._position = t * this._duration, Rh(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), i = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), lE(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (n, t) { const i = x_(n, "").split(","), r = w_(i, t); r >= 0 && (i.splice(r, 1), Rh(n, "", i.join(","))) }(this._element, this._name)) } } function sE(n, t, e) { Rh(n, "PlayState", e, aE(n, t)) } function aE(n, t) { const e = x_(n, ""); return e.indexOf(",") > 0 ? w_(e.split(","), t) : w_([e], t) } function w_(n, t) { for (let e = 0; e < n.length; e++)if (n[e].indexOf(t) >= 0) return e; return -1 } function lE(n, t, e) { e ? n.removeEventListener(oE, t) : n.addEventListener(oE, t) } function Rh(n, t, e, i) { const r = rE + t; if (null != i) { const o = n.style[r]; if (o.length) { const s = o.split(","); s[i] = e, e = s.join(",") } } n.style[r] = e } function x_(n, t) { return n.style[rE + t] || "" } class cE { constructor(t, e, i, r, o, s, a, l) { this.element = t, this.keyframes = e, this.animationName = i, this._duration = r, this._delay = o, this._finalStyles = a, this._specialStyles = l, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = s || "linear", this.totalTime = r + o, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), !(this._state >= 4) && (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), !(this._state >= 3) && (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new vj(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(i => { "offset" != i && (t[i] = e ? this._finalStyles[i] : d_(this.element, i)) }) } this.currentSnapshot = t } } class xj extends Ya { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = OM(e) } init() { this.__initialized || !this._startingStyles || (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { !this._startingStyles || (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { !this._startingStyles || (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class uE { constructor() { this._count = 0 } validateStyleProperty(t) { return t_(t) } matchesElement(t, e) { return !1 } containsElement(t, e) { return n_(t, e) } query(t, e, i) { return i_(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, i) { i = i.map(a => OM(a)); let r = `@keyframes ${e} {\n`, o = ""; i.forEach(a => { o = " "; const l = parseFloat(a.offset); r += `${o}${100 * l}% {\n`, o += " ", Object.keys(a).forEach(d => { const h = a[d]; switch (d) { case "offset": return; case "easing": return void (h && (r += `${o}animation-timing-function: ${h};\n`)); default: return void (r += `${o}${d}: ${h};\n`) } }), r += `${o}}\n` }), r += "}\n"; const s = document.createElement("style"); return s.textContent = r, s } animate(t, e, i, r, o, s = [], a) { const l = s.filter(P => P instanceof cE), d = {}; jM(i, r) && l.forEach(P => { let H = P.currentSnapshot; Object.keys(H).forEach(F => d[F] = H[F]) }); const h = function (n) { let t = {}; return n && (Array.isArray(n) ? n : [n]).forEach(i => { Object.keys(i).forEach(r => { "offset" == r || "easing" == r || (t[r] = i[r]) }) }), t }(e = zM(t, e, d)); if (0 == i) return new xj(t, h); const m = "gen_css_kf_" + this._count++, y = this.buildKeyframeElement(t, m, e); (function (n) { var t; const e = null === (t = n.getRootNode) || void 0 === t ? void 0 : t.call(n); return "undefined" != typeof ShadowRoot && e instanceof ShadowRoot ? e : document.head })(t).appendChild(y); const M = iE(t, e), k = new cE(t, e, m, i, r, o, h, M); return k.onDestroy(() => { var n; (n = y).parentNode.removeChild(n) }), k } } class fE { constructor(t, e, i, r) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, i) { return t.animate(e, i) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; if (this.hasStarted()) { const e = this._finalKeyframe; Object.keys(e).forEach(i => { "offset" != i && (t[i] = this._finished ? e[i] : d_(this.element, i)) }) } this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class kj { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(pE().toString()), this._cssKeyframesDriver = new uE } validateStyleProperty(t) { return t_(t) } matchesElement(t, e) { return !1 } containsElement(t, e) { return n_(t, e) } query(t, e, i) { return i_(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, i, r, o, s = [], a) { if (!a && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, r, o, s); const h = { duration: i, delay: r, fill: 0 == r ? "both" : "forwards" }; o && (h.easing = o); const m = {}, y = s.filter(M => M instanceof fE); jM(i, r) && y.forEach(M => { let k = M.currentSnapshot; Object.keys(k).forEach(P => m[P] = k[P]) }); const D = iE(t, e = zM(t, e = e.map(M => Ho(M, !1)), m)); return new fE(t, e, h, D) } } function pE() { return TM() && Element.prototype.animate || {} } let Ij = (() => { class n extends DM { constructor(e, i) { super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, { id: "0", encapsulation: p.None, styles: [], data: { animation: [] } }) } build(e) { const i = this._nextAnimationId.toString(); this._nextAnimationId++; const r = Array.isArray(e) ? wM(e) : e; return mE(this._renderer, null, i, "register", [r]), new Rj(i, this._renderer) } } return n.\u0275fac = function (e) { return new (e || n)(L(dc), L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class Rj extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new Oj(this._id, t, e || {}, this._renderer) } } class Oj { constructor(t, e, i, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return mE(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function mE(n, t, e, i, r) { return n.setProperty(t, `@@${e}:${i}`, r) } const gE = "@.disabled"; let Pj = (() => { class n { constructor(e, i, r) { this.delegate = e, this.engine = i, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), i.onRemovalComplete = (o, s) => { const a = null == s ? void 0 : s.parentNode(o); a && s.removeChild(a, o) } } createRenderer(e, i) { const o = this.delegate.createRenderer(e, i); if (!(e && i && i.data && i.data.animation)) { let h = this._rendererCache.get(o); return h || (h = new _E("", o, this.engine), this._rendererCache.set(o, h)), h } const s = i.id, a = i.id + "-" + this._currentId; this._currentId++, this.engine.register(a, e); const l = h => { Array.isArray(h) ? h.forEach(l) : this.engine.registerTrigger(s, a, e, h.name, h) }; return i.data.animation.forEach(l), new Fj(this, a, o, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(e, i, r) { e >= 0 && e < this._microtaskId ? this._zone.run(() => i(r)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(o => { const [s, a] = o; s(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([i, r])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return n.\u0275fac = function (e) { return new (e || n)(L(dc), L(Ih), L(Xe)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); class _E { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? r => e.destroyNode(r) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i, r = !0) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, r) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, r) { this.delegate.setAttribute(t, e, i, r) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, r) { this.delegate.setStyle(t, e, i, r) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { "@" == e.charAt(0) && e == gE ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class Fj extends _E { constructor(t, e, i, r) { super(e, i, r), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && e == gE ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if ("@" == e.charAt(0)) { const r = function (n) { switch (n) { case "body": return document.body; case "document": return document; case "window": return window; default: return n } }(t); let o = e.substr(1), s = ""; return "@" != o.charAt(0) && ([o, s] = function (n) { const t = n.indexOf("."); return [n.substring(0, t), n.substr(t + 1)] }(o)), this.engine.listen(this.namespaceId, r, o, s, a => { this.factory.scheduleListenerCallback(a._data || -1, i, a) }) } return this.delegate.listen(t, e, i) } } let Bj = (() => { class n extends Ih { constructor(e, i, r) { super(e.body, i, r) } ngOnDestroy() { this.flush() } } return n.\u0275fac = function (e) { return new (e || n)(L(Be), L(r_), L(g_)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const nr = new V("AnimationModuleType"), vE = [{ provide: DM, useClass: Ij }, { provide: g_, useFactory: function () { return new $H } }, { provide: Ih, useClass: Bj }, { provide: dc, useFactory: function (n, t, e) { return new Pj(n, t, e) }, deps: [Zu, Ih, Xe] }], yE = [{ provide: r_, useFactory: function () { return "function" == typeof pE() ? new kj : new uE } }, { provide: nr, useValue: "BrowserAnimations" }, ...vE], zj = [{ provide: r_, useClass: PM }, { provide: nr, useValue: "NoopAnimations" }, ...vE]; let Uj = (() => { class n { static withConfig(e) { return { ngModule: n, providers: e.disableAnimations ? zj : yE } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: yE, imports: [cx] }), n })(); class tz extends ut { constructor(t, e) { super() } schedule(t, e = 0) { return this } } const Ph = { setInterval(...n) { const { delegate: t } = Ph; return ((null == t ? void 0 : t.setInterval) || setInterval)(...n) }, clearInterval(n) { const { delegate: t } = Ph; return ((null == t ? void 0 : t.clearInterval) || clearInterval)(n) }, delegate: void 0 }; class k_ extends tz { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const i = this.id, r = this.scheduler; return null != i && (this.id = this.recycleAsyncId(r, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, i = 0) { return Ph.setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null != i && this.delay === i && !1 === this.pending) return e; Ph.clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(t, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let r, i = !1; try { this.work(t) } catch (o) { i = !0, r = o || new Error("Scheduled action threw falsy error") } if (i) return this.unsubscribe(), r } unsubscribe() { if (!this.closed) { const { id: t, scheduler: e } = this, { actions: i } = e; this.work = this.state = this.scheduler = null, this.pending = !1, Dn(i, this), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null, super.unsubscribe() } } } const EE = { now: () => (EE.delegate || Date).now(), delegate: void 0 }; class Bc { constructor(t, e = Bc.now) { this.schedulerActionCtor = t, this.now = e } schedule(t, e = 0, i) { return new this.schedulerActionCtor(this, t).schedule(i, e) } } Bc.now = EE.now; class A_ extends Bc { constructor(t, e = Bc.now) { super(t, e), this.actions = [], this._active = !1, this._scheduled = void 0 } flush(t) { const { actions: e } = this; if (this._active) return void e.push(t); let i; this._active = !0; do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this._active = !1, i) { for (; t = e.shift();)t.unsubscribe(); throw i } } } const Fh = new A_(k_), SE = Fh; function rz(n, t) { return n === t } function yn(n) { return lt((t, e) => { On(n).subscribe(new wt(e, () => e.complete(), Ui)), !e.closed && t.subscribe(e) }) } function si(n, t = 0) { return function (n) { return !isNaN(parseFloat(n)) && !isNaN(Number(n)) }(n) ? Number(n) : t } function kE(n) { return Array.isArray(n) ? n : [n] } function nn(n) { return null == n ? "" : "string" == typeof n ? n : `${n}px` } function hn(n) { return n instanceof ke ? n.nativeElement : n } let I_; try { I_ = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (n) { I_ = !1 } let Vc, Ds, R_, ai = (() => { class n { constructor(e) { this._platformId = e, this.isBrowser = this._platformId ? function (n) { return n === Xw }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !I_) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return n.\u0275fac = function (e) { return new (e || n)(L(Ou)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Xa = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(); function ir(n) { return function () { if (null == Vc && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Vc = !0 })) } finally { Vc = Vc || !1 } return Vc }() ? n : !!n.capture } function az() { if (null == Ds) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return Ds = !1, Ds; if ("scrollBehavior" in document.documentElement.style) Ds = !0; else { const n = Element.prototype.scrollTo; Ds = !!n && !/\{\s*\[native code\]\s*\}/.test(n.toString()) } } return Ds } function Lh(n) { if (function () { if (null == R_) { const n = "undefined" != typeof document ? document.head : null; R_ = !(!n || !n.createShadowRoot && !n.attachShadow) } return R_ }()) { const t = n.getRootNode ? n.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && t instanceof ShadowRoot) return t } return null } function O_() { let n = "undefined" != typeof document && document ? document.activeElement : null; for (; n && n.shadowRoot;) { const t = n.shadowRoot.activeElement; if (t === n) break; n = t } return n } function Vi(n) { return n.composedPath ? n.composedPath()[0] : n.target } function P_() { return "undefined" != typeof __karma__ && !!__karma__ || "undefined" != typeof jasmine && !!jasmine || "undefined" != typeof jest && !!jest || "undefined" != typeof Mocha && !!Mocha } let IE = (() => { class n { create(e) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(e) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Hc = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [IE] }), n })(), NE = (() => { class n { constructor(e) { this._platform = e } isDisabled(e) { return e.hasAttribute("disabled") } isVisible(e) { return function (n) { return !!(n.offsetWidth || n.offsetHeight || "function" == typeof n.getClientRects && n.getClientRects().length) }(e) && "visible" === getComputedStyle(e).visibility } isTabbable(e) { if (!this._platform.isBrowser) return !1; const i = function (n) { try { return n.frameElement } catch (t) { return null } }(function (n) { return n.ownerDocument && n.ownerDocument.defaultView || window }(e)); if (i && (-1 === BE(i) || !this.isVisible(i))) return !1; let r = e.nodeName.toLowerCase(), o = BE(e); return e.hasAttribute("contenteditable") ? -1 !== o : !("iframe" === r || "object" === r || this._platform.WEBKIT && this._platform.IOS && !function (n) { let t = n.nodeName.toLowerCase(), e = "input" === t && n.type; return "text" === e || "password" === e || "select" === t || "textarea" === t }(e)) && ("audio" === r ? !!e.hasAttribute("controls") && -1 !== o : "video" === r ? -1 !== o && (null !== o || this._platform.FIREFOX || e.hasAttribute("controls")) : e.tabIndex >= 0) } isFocusable(e, i) { return function (n) { return !function (n) { return function (n) { return "input" == n.nodeName.toLowerCase() }(n) && "hidden" == n.type }(n) && (function (n) { let t = n.nodeName.toLowerCase(); return "input" === t || "select" === t || "button" === t || "textarea" === t }(n) || function (n) { return function (n) { return "a" == n.nodeName.toLowerCase() }(n) && n.hasAttribute("href") }(n) || n.hasAttribute("contenteditable") || LE(n)) }(e) && !this.isDisabled(e) && ((null == i ? void 0 : i.ignoreVisibility) || this.isVisible(e)) } } return n.\u0275fac = function (e) { return new (e || n)(L(ai)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function LE(n) { if (!n.hasAttribute("tabindex") || void 0 === n.tabIndex) return !1; let t = n.getAttribute("tabindex"); return !(!t || isNaN(parseInt(t, 10))) } function BE(n) { if (!LE(n)) return null; const t = parseInt(n.getAttribute("tabindex") || "", 10); return isNaN(t) ? -1 : t } class wz { constructor(t, e, i, r, o = !1) { this._element = t, this._checker = e, this._ngZone = i, this._document = r, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, o || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.remove()), e && (e.removeEventListener("focus", this.endAnchorListener), e.remove()), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusInitialElement(t))) }) } focusFirstTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusFirstTabbableElement(t))) }) } focusLastTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusLastTabbableElement(t))) }) } _getRegionBoundary(t) { const e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(t) { const e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (e) { if (!this._checker.isFocusable(e)) { const i = this._getFirstTabbableElement(e); return null == i || i.focus(t), !!i } return e.focus(t), !0 } return this.focusFirstTabbableElement(t) } focusFirstTabbableElement(t) { const e = this._getRegionBoundary("start"); return e && e.focus(t), !!e } focusLastTabbableElement(t) { const e = this._getRegionBoundary("end"); return e && e.focus(t), !!e } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; const e = t.children; for (let i = 0; i < e.length; i++) { const r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null; if (r) return r } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; const e = t.children; for (let i = e.length - 1; i >= 0; i--) { const r = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null; if (r) return r } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(pn(1)).subscribe(t) } } let xz = (() => { class n { constructor(e, i, r) { this._checker = e, this._ngZone = i, this._document = r } create(e, i = !1) { return new wz(e, this._checker, this._ngZone, this._document, i) } } return n.\u0275fac = function (e) { return new (e || n)(L(NE), L(Xe), L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function F_(n) { return 0 === n.offsetX && 0 === n.offsetY } function N_(n) { const t = n.touches && n.touches[0] || n.changedTouches && n.changedTouches[0]; return !(!t || -1 !== t.identifier || null != t.radiusX && 1 !== t.radiusX || null != t.radiusY && 1 !== t.radiusY) } const Mz = new V("cdk-input-modality-detector-options"), Ez = { ignoreKeys: [18, 17, 224, 91, 16] }, Ja = ir({ passive: !0, capture: !0 }); let Sz = (() => { class n { constructor(e, i, r, o) { this._platform = e, this._mostRecentTarget = null, this._modality = new ri(null), this._lastTouchMs = 0, this._onKeydown = s => { var a, l; (null === (l = null === (a = this._options) || void 0 === a ? void 0 : a.ignoreKeys) || void 0 === l ? void 0 : l.some(d => d === s.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = Vi(s)) }, this._onMousedown = s => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(F_(s) ? "keyboard" : "mouse"), this._mostRecentTarget = Vi(s)) }, this._onTouchstart = s => { N_(s) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Vi(s)) }, this._options = Object.assign(Object.assign({}, Ez), o), this.modalityDetected = this._modality.pipe(An((t, e) => 1 <= e)), this.modalityChanged = this.modalityDetected.pipe(function (n, t = $i) { return n = null != n ? n : rz, lt((e, i) => { let r, o = !0; e.subscribe(new wt(i, s => { const a = t(s); (o || !n(r, a)) && (o = !1, r = a, i.next(s)) })) }) }()), e.isBrowser && i.runOutsideAngular(() => { r.addEventListener("keydown", this._onKeydown, Ja), r.addEventListener("mousedown", this._onMousedown, Ja), r.addEventListener("touchstart", this._onTouchstart, Ja) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Ja), document.removeEventListener("mousedown", this._onMousedown, Ja), document.removeEventListener("touchstart", this._onTouchstart, Ja)) } } return n.\u0275fac = function (e) { return new (e || n)(L(ai), L(Xe), L(Be), L(Mz, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const kz = new V("cdk-focus-monitor-default-options"), Bh = ir({ passive: !0, capture: !0 }); let ws = (() => { class n { constructor(e, i, r, o, s) { this._ngZone = e, this._platform = i, this._inputModalityDetector = r, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new se, this._rootNodeFocusAndBlurListener = a => { const l = Vi(a), d = "focus" === a.type ? this._onFocus : this._onBlur; for (let h = l; h; h = h.parentElement)d.call(this, a, h) }, this._document = o, this._detectionMode = (null == s ? void 0 : s.detectionMode) || 0 } monitor(e, i = !1) { const r = hn(e); if (!this._platform.isBrowser || 1 !== r.nodeType) return ge(null); const o = Lh(r) || this._getDocument(), s = this._elementInfo.get(r); if (s) return i && (s.checkChildren = !0), s.subject; const a = { checkChildren: i, subject: new se, rootNode: o }; return this._elementInfo.set(r, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(e) { const i = hn(e), r = this._elementInfo.get(i); r && (r.subject.complete(), this._setClasses(i), this._elementInfo.delete(i), this._removeGlobalListeners(r)) } focusVia(e, i, r) { const o = hn(e); o === this._getDocument().activeElement ? this._getClosestElementsInfo(o).forEach(([a, l]) => this._originChanged(a, i, l)) : (this._setOrigin(i), "function" == typeof o.focus && o.focus(r)) } ngOnDestroy() { this._elementInfo.forEach((e, i) => this.stopMonitoring(i)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(e) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(e) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(e) { return 1 === this._detectionMode || !!(null == e ? void 0 : e.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(e, i) { e.classList.toggle("cdk-focused", !!i), e.classList.toggle("cdk-touch-focused", "touch" === i), e.classList.toggle("cdk-keyboard-focused", "keyboard" === i), e.classList.toggle("cdk-mouse-focused", "mouse" === i), e.classList.toggle("cdk-program-focused", "program" === i) } _setOrigin(e, i = !1) { this._ngZone.runOutsideAngular(() => { this._origin = e, this._originFromTouchInteraction = "touch" === e && i, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(e, i) { const r = this._elementInfo.get(i), o = Vi(e); !r || !r.checkChildren && i !== o || this._originChanged(i, this._getFocusOrigin(o), r) } _onBlur(e, i) { const r = this._elementInfo.get(i); !r || r.checkChildren && e.relatedTarget instanceof Node && i.contains(e.relatedTarget) || (this._setClasses(i), this._emitOrigin(r.subject, null)) } _emitOrigin(e, i) { this._ngZone.run(() => e.next(i)) } _registerGlobalListeners(e) { if (!this._platform.isBrowser) return; const i = e.rootNode, r = this._rootNodeFocusListenerCount.get(i) || 0; r || this._ngZone.runOutsideAngular(() => { i.addEventListener("focus", this._rootNodeFocusAndBlurListener, Bh), i.addEventListener("blur", this._rootNodeFocusAndBlurListener, Bh) }), this._rootNodeFocusListenerCount.set(i, r + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(yn(this._stopInputModalityDetector)).subscribe(o => { this._setOrigin(o, !0) })) } _removeGlobalListeners(e) { const i = e.rootNode; if (this._rootNodeFocusListenerCount.has(i)) { const r = this._rootNodeFocusListenerCount.get(i); r > 1 ? this._rootNodeFocusListenerCount.set(i, r - 1) : (i.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Bh), i.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Bh), this._rootNodeFocusListenerCount.delete(i)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(e, i, r) { this._setClasses(e, i), this._emitOrigin(r.subject, i), this._lastFocusOrigin = i } _getClosestElementsInfo(e) { const i = []; return this._elementInfo.forEach((r, o) => { (o === e || r.checkChildren && o.contains(e)) && i.push([o, r]) }), i } } return n.\u0275fac = function (e) { return new (e || n)(L(Xe), L(ai), L(Sz), L(Be, 8), L(kz, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const HE = "cdk-high-contrast-black-on-white", jE = "cdk-high-contrast-white-on-black", L_ = "cdk-high-contrast-active"; let zE = (() => { class n { constructor(e, i) { this._platform = e, this._document = i } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const e = this._document.createElement("div"); e.style.backgroundColor = "rgb(1,2,3)", e.style.position = "absolute", this._document.body.appendChild(e); const i = this._document.defaultView || window, r = i && i.getComputedStyle ? i.getComputedStyle(e) : null, o = (r && r.backgroundColor || "").replace(/ /g, ""); switch (e.remove(), o) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const e = this._document.body.classList; e.remove(L_), e.remove(HE), e.remove(jE), this._hasCheckedHighContrastMode = !0; const i = this.getHighContrastMode(); 1 === i ? (e.add(L_), e.add(HE)) : 2 === i && (e.add(L_), e.add(jE)) } } } return n.\u0275fac = function (e) { return new (e || n)(L(ai), L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), jc = (() => { class n { constructor(e) { e._applyBodyHighContrastModeCssClasses() } } return n.\u0275fac = function (e) { return new (e || n)(L(zE)) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[Xa, Hc]] }), n })(), Az = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(); function B_(n = 0, t, e = SE) { let i = -1; return null != t && (Dd(t) ? e = t : i = t), new at(r => { let o = function (n) { return n instanceof Date && !isNaN(n) }(n) ? +n - e.now() : n; o < 0 && (o = 0); let s = 0; return e.schedule(function () { r.closed || (r.next(s++), 0 <= i ? this.schedule(void 0, i) : r.complete()) }, o) }) } const zc = { schedule(n) { let t = requestAnimationFrame, e = cancelAnimationFrame; const { delegate: i } = zc; i && (t = i.requestAnimationFrame, e = i.cancelAnimationFrame); const r = t(o => { e = void 0, n(o) }); return new ut(() => null == e ? void 0 : e(r)) }, requestAnimationFrame(...n) { const { delegate: t } = zc; return ((null == t ? void 0 : t.requestAnimationFrame) || requestAnimationFrame)(...n) }, cancelAnimationFrame(...n) { const { delegate: t } = zc; return ((null == t ? void 0 : t.cancelAnimationFrame) || cancelAnimationFrame)(...n) }, delegate: void 0 }, UE = new class extends A_ { flush(t) { this._active = !0, this._scheduled = void 0; const { actions: e } = this; let i, r = -1; t = t || e.shift(); const o = e.length; do { if (i = t.execute(t.state, t.delay)) break } while (++r < o && (t = e.shift())); if (this._active = !1, i) { for (; ++r < o && (t = e.shift());)t.unsubscribe(); throw i } } }(class extends k_ { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = zc.requestAnimationFrame(() => t.flush(void 0)))) } recycleAsyncId(t, e, i = 0) { if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (zc.cancelAnimationFrame(e), t._scheduled = void 0) } }), Fz = ["addListener", "removeListener"], Nz = ["addEventListener", "removeEventListener"], Lz = ["on", "off"]; function el(n, t, e, i) { if (Qe(e) && (i = e, e = void 0), i) return el(n, t, e).pipe(Sg(i)); const [r, o] = function (n) { return Qe(n.addEventListener) && Qe(n.removeEventListener) }(n) ? Nz.map(s => a => n[s](t, a, e)) : function (n) { return Qe(n.addListener) && Qe(n.removeListener) }(n) ? Fz.map($E(n, t)) : function (n) { return Qe(n.on) && Qe(n.off) }(n) ? Lz.map($E(n, t)) : []; if (!r && Fs(n)) return Ft(s => el(s, t, e))(On(n)); if (!r) throw new TypeError("Invalid event target"); return new at(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return r(a), () => o(a) }) } function $E(n, t) { return e => i => n[e](t, i) } let V_, jz = 1; const Vh = {}; function GE(n) { return n in Vh && (delete Vh[n], !0) } const zz = { setImmediate(n) { const t = jz++; return Vh[t] = !0, V_ || (V_ = Promise.resolve()), V_.then(() => GE(t) && n()), t }, clearImmediate(n) { GE(n) } }, { setImmediate: Uz, clearImmediate: $z } = zz, Hh = { setImmediate(...n) { const { delegate: t } = Hh; return ((null == t ? void 0 : t.setImmediate) || Uz)(...n) }, clearImmediate(n) { const { delegate: t } = Hh; return ((null == t ? void 0 : t.clearImmediate) || $z)(n) }, delegate: void 0 }; new class extends A_ { flush(t) { this._active = !0, this._scheduled = void 0; const { actions: e } = this; let i, r = -1; t = t || e.shift(); const o = e.length; do { if (i = t.execute(t.state, t.delay)) break } while (++r < o && (t = e.shift())); if (this._active = !1, i) { for (; ++r < o && (t = e.shift());)t.unsubscribe(); throw i } } }(class extends k_ { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = Hh.setImmediate(t.flush.bind(t, void 0)))) } recycleAsyncId(t, e, i = 0) { if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (Hh.clearImmediate(e), t._scheduled = void 0) } }); function qE(n, t = SE) { return function (n) { return lt((t, e) => { let i = !1, r = null, o = null, s = !1; const a = () => { if (null == o || o.unsubscribe(), o = null, i) { i = !1; const d = r; r = null, e.next(d) } s && e.complete() }, l = () => { o = null, s && e.complete() }; t.subscribe(new wt(e, d => { i = !0, r = d, o || On(n()).subscribe(o = new wt(e, a, l)) }, () => { s = !0, (!i || !o || o.closed) && e.complete() })) }) }(() => B_(n, t)) } const Qz = new V("cdk-dir-doc", { providedIn: "root", factory: function () { return tu(Be) } }), Xz = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let jo = (() => { class n { constructor(e) { if (this.value = "ltr", this.change = new we, e) { const r = e.documentElement ? e.documentElement.dir : null; this.value = function (n) { const t = (null == n ? void 0 : n.toLowerCase()) || ""; return "auto" === t && "undefined" != typeof navigator && (null == navigator ? void 0 : navigator.language) ? Xz.test(navigator.language) ? "rtl" : "ltr" : "rtl" === t ? "rtl" : "ltr" }((e.body ? e.body.dir : null) || r || "ltr") } } ngOnDestroy() { this.change.complete() } } return n.\u0275fac = function (e) { return new (e || n)(L(Qz, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), tl = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), eU = (() => { class n { constructor(e, i, r) { this._ngZone = e, this._platform = i, this._scrolled = new se, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = r } register(e) { this.scrollContainers.has(e) || this.scrollContainers.set(e, e.elementScrolled().subscribe(() => this._scrolled.next(e))) } deregister(e) { const i = this.scrollContainers.get(e); i && (i.unsubscribe(), this.scrollContainers.delete(e)) } scrolled(e = 20) { return this._platform.isBrowser ? new at(i => { this._globalSubscription || this._addGlobalListener(); const r = e > 0 ? this._scrolled.pipe(qE(e)).subscribe(i) : this._scrolled.subscribe(i); return this._scrolledCount++, () => { r.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : ge() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((e, i) => this.deregister(i)), this._scrolled.complete() } ancestorScrolled(e, i) { const r = this.getAncestorScrollContainers(e); return this.scrolled(i).pipe(An(o => !o || r.indexOf(o) > -1)) } getAncestorScrollContainers(e) { const i = []; return this.scrollContainers.forEach((r, o) => { this._scrollableContainsElement(o, e) && i.push(o) }), i } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(e, i) { let r = hn(i), o = e.getElementRef().nativeElement; do { if (r == o) return !0 } while (r = r.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => el(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return n.\u0275fac = function (e) { return new (e || n)(L(Xe), L(ai), L(Be, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Uc = (() => { class n { constructor(e, i, r) { this._platform = e, this._change = new se, this._changeListener = o => { this._change.next(o) }, this._document = r, i.runOutsideAngular(() => { if (e.isBrowser) { const o = this._getWindow(); o.addEventListener("resize", this._changeListener), o.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const e = this._getWindow(); e.removeEventListener("resize", this._changeListener), e.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const e = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), e } getViewportRect() { const e = this.getViewportScrollPosition(), { width: i, height: r } = this.getViewportSize(); return { top: e.top, left: e.left, bottom: e.top + r, right: e.left + i, height: r, width: i } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const e = this._document, i = this._getWindow(), r = e.documentElement, o = r.getBoundingClientRect(); return { top: -o.top || e.body.scrollTop || i.scrollY || r.scrollTop || 0, left: -o.left || e.body.scrollLeft || i.scrollX || r.scrollLeft || 0 } } change(e = 20) { return e > 0 ? this._change.pipe(qE(e)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const e = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: e.innerWidth, height: e.innerHeight } : { width: 0, height: 0 } } } return n.\u0275fac = function (e) { return new (e || n)(L(ai), L(Xe), L(Be, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Ir = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), jh = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[tl, Xa, Ir], tl, Ir] }), n })(); function H_(n, t, e) { for (let i in t) if (t.hasOwnProperty(i)) { const r = t[i]; r ? n.setProperty(i, r, (null == e ? void 0 : e.has(i)) ? "important" : "") : n.removeProperty(i) } return n } function nl(n, t) { const e = t ? "" : "none"; H_(n.style, { "touch-action": t ? "" : "none", "-webkit-user-drag": t ? "" : "none", "-webkit-tap-highlight-color": t ? "" : "transparent", "user-select": e, "-ms-user-select": e, "-webkit-user-select": e, "-moz-user-select": e }) } function WE(n, t, e) { H_(n.style, { position: t ? "" : "fixed", top: t ? "" : "0", opacity: t ? "" : "0", left: t ? "" : "-999em" }, e) } function zh(n, t) { return t && "none" != t ? n + " " + t : n } function YE(n) { const t = n.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3; return parseFloat(n) * t } function j_(n, t) { return n.getPropertyValue(t).split(",").map(i => i.trim()) } function z_(n) { const t = n.getBoundingClientRect(); return { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: t.width, height: t.height, x: t.x, y: t.y } } function U_(n, t, e) { const { top: i, bottom: r, left: o, right: s } = n; return e >= i && e <= r && t >= o && t <= s } function $c(n, t, e) { n.top += t, n.bottom = n.top + n.height, n.left += e, n.right = n.left + n.width } function QE(n, t, e, i) { const { top: r, right: o, bottom: s, left: a, width: l, height: d } = n, h = l * t, m = d * t; return i > r - m && i < s + m && e > a - h && e < o + h } class KE { constructor(t, e) { this._document = t, this._viewportRuler = e, this.positions = new Map } clear() { this.positions.clear() } cache(t) { this.clear(), this.positions.set(this._document, { scrollPosition: this._viewportRuler.getViewportScrollPosition() }), t.forEach(e => { this.positions.set(e, { scrollPosition: { top: e.scrollTop, left: e.scrollLeft }, clientRect: z_(e) }) }) } handleScroll(t) { const e = Vi(t), i = this.positions.get(e); if (!i) return null; const r = i.scrollPosition; let o, s; if (e === this._document) { const d = this._viewportRuler.getViewportScrollPosition(); o = d.top, s = d.left } else o = e.scrollTop, s = e.scrollLeft; const a = r.top - o, l = r.left - s; return this.positions.forEach((d, h) => { d.clientRect && e !== h && e.contains(h) && $c(d.clientRect, a, l) }), r.top = o, r.left = s, { top: a, left: l } } } function XE(n) { const t = n.cloneNode(!0), e = t.querySelectorAll("[id]"), i = n.nodeName.toLowerCase(); t.removeAttribute("id"); for (let r = 0; r < e.length; r++)e[r].removeAttribute("id"); return "canvas" === i ? eS(n, t) : ("input" === i || "select" === i || "textarea" === i) && JE(n, t), ZE("canvas", n, t, eS), ZE("input, textarea, select", n, t, JE), t } function ZE(n, t, e, i) { const r = t.querySelectorAll(n); if (r.length) { const o = e.querySelectorAll(n); for (let s = 0; s < r.length; s++)i(r[s], o[s]) } } let iU = 0; function JE(n, t) { "file" !== t.type && (t.value = n.value), "radio" === t.type && t.name && (t.name = `mat-clone-${t.name}-${iU++}`) } function eS(n, t) { const e = t.getContext("2d"); if (e) try { e.drawImage(n, 0, 0) } catch (i) { } } const tS = ir({ passive: !0 }), nS = ir({ passive: !1 }), $_ = new Set(["position"]); class oU { constructor(t, e, i, r, o, s) { this._config = e, this._document = i, this._ngZone = r, this._viewportRuler = o, this._dragDropRegistry = s, this._passiveTransform = { x: 0, y: 0 }, this._activeTransform = { x: 0, y: 0 }, this._hasStartedDragging = !1, this._moveEvents = new se, this._pointerMoveSubscription = ut.EMPTY, this._pointerUpSubscription = ut.EMPTY, this._scrollSubscription = ut.EMPTY, this._resizeSubscription = ut.EMPTY, this._boundaryElement = null, this._nativeInteractionsEnabled = !0, this._handles = [], this._disabledHandles = new Set, this._direction = "ltr", this.dragStartDelay = 0, this._disabled = !1, this.beforeStarted = new se, this.started = new se, this.released = new se, this.ended = new se, this.entered = new se, this.exited = new se, this.dropped = new se, this.moved = this._moveEvents, this._pointerDown = a => { if (this.beforeStarted.next(), this._handles.length) { const l = this._handles.find(d => a.target && (a.target === d || d.contains(a.target))); l && !this._disabledHandles.has(l) && !this.disabled && this._initializeDragSequence(l, a) } else this.disabled || this._initializeDragSequence(this._rootElement, a) }, this._pointerMove = a => { const l = this._getPointerPositionOnPage(a); if (!this._hasStartedDragging) { if (Math.abs(l.x - this._pickupPositionOnPage.x) + Math.abs(l.y - this._pickupPositionOnPage.y) >= this._config.dragStartThreshold) { const D = Date.now() >= this._dragStartTime + this._getDragStartDelay(a), M = this._dropContainer; if (!D) return void this._endDragSequence(a); (!M || !M.isDragging() && !M.isReceiving()) && (a.preventDefault(), this._hasStartedDragging = !0, this._ngZone.run(() => this._startDragSequence(a))) } return } this._boundaryElement && (!this._previewRect || !this._previewRect.width && !this._previewRect.height) && (this._previewRect = (this._preview || this._rootElement).getBoundingClientRect()), a.preventDefault(); const d = this._getConstrainedPointerPosition(l); if (this._hasMoved = !0, this._lastKnownPointerPosition = l, this._updatePointerDirectionDelta(d), this._dropContainer) this._updateActiveDropContainer(d, l); else { const h = this._activeTransform; h.x = d.x - this._pickupPositionOnPage.x + this._passiveTransform.x, h.y = d.y - this._pickupPositionOnPage.y + this._passiveTransform.y, this._applyRootElementTransform(h.x, h.y) } this._moveEvents.observers.length && this._ngZone.run(() => { this._moveEvents.next({ source: this, pointerPosition: d, event: a, distance: this._getDragDistance(d), delta: this._pointerDirectionDelta }) }) }, this._pointerUp = a => { this._endDragSequence(a) }, this.withRootElement(t).withParent(e.parentDragRef || null), this._parentPositions = new KE(i, o), s.registerDragItem(this) } get disabled() { return this._disabled || !(!this._dropContainer || !this._dropContainer.disabled) } set disabled(t) { const e = null != (n = t) && "false" != `${n}`; var n; e !== this._disabled && (this._disabled = e, this._toggleNativeDragInteractions(), this._handles.forEach(i => nl(i, e))) } getPlaceholderElement() { return this._placeholder } getRootElement() { return this._rootElement } getVisibleElement() { return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement() } withHandles(t) { this._handles = t.map(i => hn(i)), this._handles.forEach(i => nl(i, this.disabled)), this._toggleNativeDragInteractions(); const e = new Set; return this._disabledHandles.forEach(i => { this._handles.indexOf(i) > -1 && e.add(i) }), this._disabledHandles = e, this } withPreviewTemplate(t) { return this._previewTemplate = t, this } withPlaceholderTemplate(t) { return this._placeholderTemplate = t, this } withRootElement(t) { const e = hn(t); return e !== this._rootElement && (this._rootElement && this._removeRootElementListeners(this._rootElement), this._ngZone.runOutsideAngular(() => { e.addEventListener("mousedown", this._pointerDown, nS), e.addEventListener("touchstart", this._pointerDown, tS) }), this._initialTransform = void 0, this._rootElement = e), "undefined" != typeof SVGElement && this._rootElement instanceof SVGElement && (this._ownerSVGElement = this._rootElement.ownerSVGElement), this } withBoundaryElement(t) { return this._boundaryElement = t ? hn(t) : null, this._resizeSubscription.unsubscribe(), t && (this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize())), this } withParent(t) { return this._parentDragRef = t, this } dispose() { var t, e; this._removeRootElementListeners(this._rootElement), this.isDragging() && (null === (t = this._rootElement) || void 0 === t || t.remove()), null === (e = this._anchor) || void 0 === e || e.remove(), this._destroyPreview(), this._destroyPlaceholder(), this._dragDropRegistry.removeDragItem(this), this._removeSubscriptions(), this.beforeStarted.complete(), this.started.complete(), this.released.complete(), this.ended.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this._moveEvents.complete(), this._handles = [], this._disabledHandles.clear(), this._dropContainer = void 0, this._resizeSubscription.unsubscribe(), this._parentPositions.clear(), this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null } isDragging() { return this._hasStartedDragging && this._dragDropRegistry.isDragging(this) } reset() { this._rootElement.style.transform = this._initialTransform || "", this._activeTransform = { x: 0, y: 0 }, this._passiveTransform = { x: 0, y: 0 } } disableHandle(t) { !this._disabledHandles.has(t) && this._handles.indexOf(t) > -1 && (this._disabledHandles.add(t), nl(t, !0)) } enableHandle(t) { this._disabledHandles.has(t) && (this._disabledHandles.delete(t), nl(t, this.disabled)) } withDirection(t) { return this._direction = t, this } _withDropContainer(t) { this._dropContainer = t } getFreeDragPosition() { const t = this.isDragging() ? this._activeTransform : this._passiveTransform; return { x: t.x, y: t.y } } setFreeDragPosition(t) { return this._activeTransform = { x: 0, y: 0 }, this._passiveTransform.x = t.x, this._passiveTransform.y = t.y, this._dropContainer || this._applyRootElementTransform(t.x, t.y), this } withPreviewContainer(t) { return this._previewContainer = t, this } _sortFromLastPointerPosition() { const t = this._lastKnownPointerPosition; t && this._dropContainer && this._updateActiveDropContainer(this._getConstrainedPointerPosition(t), t) } _removeSubscriptions() { this._pointerMoveSubscription.unsubscribe(), this._pointerUpSubscription.unsubscribe(), this._scrollSubscription.unsubscribe() } _destroyPreview() { var t, e; null === (t = this._preview) || void 0 === t || t.remove(), null === (e = this._previewRef) || void 0 === e || e.destroy(), this._preview = this._previewRef = null } _destroyPlaceholder() { var t, e; null === (t = this._placeholder) || void 0 === t || t.remove(), null === (e = this._placeholderRef) || void 0 === e || e.destroy(), this._placeholder = this._placeholderRef = null } _endDragSequence(t) { if (this._dragDropRegistry.isDragging(this) && (this._removeSubscriptions(), this._dragDropRegistry.stopDragging(this), this._toggleNativeDragInteractions(), this._handles && (this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight), this._hasStartedDragging)) if (this.released.next({ source: this }), this._dropContainer) this._dropContainer._stopScrolling(), this._animatePreviewToPlaceholder().then(() => { this._cleanupDragArtifacts(t), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) }); else { this._passiveTransform.x = this._activeTransform.x; const e = this._getPointerPositionOnPage(t); this._passiveTransform.y = this._activeTransform.y, this._ngZone.run(() => { this.ended.next({ source: this, distance: this._getDragDistance(e), dropPoint: e }) }), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) } } _startDragSequence(t) { Gc(t) && (this._lastTouchEventTime = Date.now()), this._toggleNativeDragInteractions(); const e = this._dropContainer; if (e) { const i = this._rootElement, r = i.parentNode, o = this._placeholder = this._createPlaceholderElement(), s = this._anchor = this._anchor || this._document.createComment(""), a = this._getShadowRoot(); r.insertBefore(s, i), this._initialTransform = i.style.transform || "", this._preview = this._createPreviewElement(), WE(i, !1, $_), this._document.body.appendChild(r.replaceChild(o, i)), this._getPreviewInsertionPoint(r, a).appendChild(this._preview), this.started.next({ source: this }), e.start(), this._initialContainer = e, this._initialIndex = e.getItemIndex(this) } else this.started.next({ source: this }), this._initialContainer = this._initialIndex = void 0; this._parentPositions.cache(e ? e.getScrollableParents() : []) } _initializeDragSequence(t, e) { this._parentDragRef && e.stopPropagation(); const i = this.isDragging(), r = Gc(e), o = !r && 0 !== e.button, s = this._rootElement, a = Vi(e), l = !r && this._lastTouchEventTime && this._lastTouchEventTime + 800 > Date.now(), d = r ? N_(e) : F_(e); if (a && a.draggable && "mousedown" === e.type && e.preventDefault(), i || o || l || d) return; if (this._handles.length) { const y = s.style; this._rootElementTapHighlight = y.webkitTapHighlightColor || "", y.webkitTapHighlightColor = "transparent" } this._hasStartedDragging = this._hasMoved = !1, this._removeSubscriptions(), this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove), this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp), this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(y => this._updateOnScroll(y)), this._boundaryElement && (this._boundaryRect = z_(this._boundaryElement)); const h = this._previewTemplate; this._pickupPositionInElement = h && h.template && !h.matchSize ? { x: 0, y: 0 } : this._getPointerPositionInElement(t, e); const m = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(e); this._pointerDirectionDelta = { x: 0, y: 0 }, this._pointerPositionAtLastDirectionChange = { x: m.x, y: m.y }, this._dragStartTime = Date.now(), this._dragDropRegistry.startDragging(this, e) } _cleanupDragArtifacts(t) { WE(this._rootElement, !0, $_), this._anchor.parentNode.replaceChild(this._rootElement, this._anchor), this._destroyPreview(), this._destroyPlaceholder(), this._boundaryRect = this._previewRect = this._initialTransform = void 0, this._ngZone.run(() => { const e = this._dropContainer, i = e.getItemIndex(this), r = this._getPointerPositionOnPage(t), o = this._getDragDistance(r), s = e._isOverContainer(r.x, r.y); this.ended.next({ source: this, distance: o, dropPoint: r }), this.dropped.next({ item: this, currentIndex: i, previousIndex: this._initialIndex, container: e, previousContainer: this._initialContainer, isPointerOverContainer: s, distance: o, dropPoint: r }), e.drop(this, i, this._initialIndex, this._initialContainer, s, o, r), this._dropContainer = this._initialContainer }) } _updateActiveDropContainer({ x: t, y: e }, { x: i, y: r }) { let o = this._initialContainer._getSiblingContainerFromPosition(this, t, e); !o && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(t, e) && (o = this._initialContainer), o && o !== this._dropContainer && this._ngZone.run(() => { this.exited.next({ item: this, container: this._dropContainer }), this._dropContainer.exit(this), this._dropContainer = o, this._dropContainer.enter(this, t, e, o === this._initialContainer && o.sortingDisabled ? this._initialIndex : void 0), this.entered.next({ item: this, container: o, currentIndex: o.getItemIndex(this) }) }), this.isDragging() && (this._dropContainer._startScrollingIfNecessary(i, r), this._dropContainer._sortItem(this, t, e, this._pointerDirectionDelta), this._applyPreviewTransform(t - this._pickupPositionInElement.x, e - this._pickupPositionInElement.y)) } _createPreviewElement() { const t = this._previewTemplate, e = this.previewClass, i = t ? t.template : null; let r; if (i && t) { const o = t.matchSize ? this._rootElement.getBoundingClientRect() : null, s = t.viewContainer.createEmbeddedView(i, t.context); s.detectChanges(), r = rS(s, this._document), this._previewRef = s, t.matchSize ? oS(r, o) : r.style.transform = Uh(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y) } else { const o = this._rootElement; r = XE(o), oS(r, o.getBoundingClientRect()), this._initialTransform && (r.style.transform = this._initialTransform) } return H_(r.style, { "pointer-events": "none", margin: "0", position: "fixed", top: "0", left: "0", "z-index": `${this._config.zIndex || 1e3}` }, $_), nl(r, !1), r.classList.add("cdk-drag-preview"), r.setAttribute("dir", this._direction), e && (Array.isArray(e) ? e.forEach(o => r.classList.add(o)) : r.classList.add(e)), r } _animatePreviewToPlaceholder() { if (!this._hasMoved) return Promise.resolve(); const t = this._placeholder.getBoundingClientRect(); this._preview.classList.add("cdk-drag-animating"), this._applyPreviewTransform(t.left, t.top); const e = function (n) { const t = getComputedStyle(n), e = j_(t, "transition-property"), i = e.find(a => "transform" === a || "all" === a); if (!i) return 0; const r = e.indexOf(i), o = j_(t, "transition-duration"), s = j_(t, "transition-delay"); return YE(o[r]) + YE(s[r]) }(this._preview); return 0 === e ? Promise.resolve() : this._ngZone.runOutsideAngular(() => new Promise(i => { const r = s => { var a; (!s || Vi(s) === this._preview && "transform" === s.propertyName) && (null === (a = this._preview) || void 0 === a || a.removeEventListener("transitionend", r), i(), clearTimeout(o)) }, o = setTimeout(r, 1.5 * e); this._preview.addEventListener("transitionend", r) })) } _createPlaceholderElement() { const t = this._placeholderTemplate, e = t ? t.template : null; let i; return e ? (this._placeholderRef = t.viewContainer.createEmbeddedView(e, t.context), this._placeholderRef.detectChanges(), i = rS(this._placeholderRef, this._document)) : i = XE(this._rootElement), i.classList.add("cdk-drag-placeholder"), i } _getPointerPositionInElement(t, e) { const i = this._rootElement.getBoundingClientRect(), r = t === this._rootElement ? null : t, o = r ? r.getBoundingClientRect() : i, s = Gc(e) ? e.targetTouches[0] : e, a = this._getViewportScrollPosition(); return { x: o.left - i.left + (s.pageX - o.left - a.left), y: o.top - i.top + (s.pageY - o.top - a.top) } } _getPointerPositionOnPage(t) { const e = this._getViewportScrollPosition(), i = Gc(t) ? t.touches[0] || t.changedTouches[0] || { pageX: 0, pageY: 0 } : t, r = i.pageX - e.left, o = i.pageY - e.top; if (this._ownerSVGElement) { const s = this._ownerSVGElement.getScreenCTM(); if (s) { const a = this._ownerSVGElement.createSVGPoint(); return a.x = r, a.y = o, a.matrixTransform(s.inverse()) } } return { x: r, y: o } } _getConstrainedPointerPosition(t) { const e = this._dropContainer ? this._dropContainer.lockAxis : null; let { x: i, y: r } = this.constrainPosition ? this.constrainPosition(t, this) : t; if ("x" === this.lockAxis || "x" === e ? r = this._pickupPositionOnPage.y : ("y" === this.lockAxis || "y" === e) && (i = this._pickupPositionOnPage.x), this._boundaryRect) { const { x: o, y: s } = this._pickupPositionInElement, a = this._boundaryRect, l = this._previewRect, d = a.top + s, h = a.bottom - (l.height - s); i = iS(i, a.left + o, a.right - (l.width - o)), r = iS(r, d, h) } return { x: i, y: r } } _updatePointerDirectionDelta(t) { const { x: e, y: i } = t, r = this._pointerDirectionDelta, o = this._pointerPositionAtLastDirectionChange, s = Math.abs(e - o.x), a = Math.abs(i - o.y); return s > this._config.pointerDirectionChangeThreshold && (r.x = e > o.x ? 1 : -1, o.x = e), a > this._config.pointerDirectionChangeThreshold && (r.y = i > o.y ? 1 : -1, o.y = i), r } _toggleNativeDragInteractions() { if (!this._rootElement || !this._handles) return; const t = this._handles.length > 0 || !this.isDragging(); t !== this._nativeInteractionsEnabled && (this._nativeInteractionsEnabled = t, nl(this._rootElement, t)) } _removeRootElementListeners(t) { t.removeEventListener("mousedown", this._pointerDown, nS), t.removeEventListener("touchstart", this._pointerDown, tS) } _applyRootElementTransform(t, e) { const i = Uh(t, e), r = this._rootElement.style; null == this._initialTransform && (this._initialTransform = r.transform && "none" != r.transform ? r.transform : ""), r.transform = zh(i, this._initialTransform) } _applyPreviewTransform(t, e) { var i; const r = (null === (i = this._previewTemplate) || void 0 === i ? void 0 : i.template) ? void 0 : this._initialTransform, o = Uh(t, e); this._preview.style.transform = zh(o, r) } _getDragDistance(t) { const e = this._pickupPositionOnPage; return e ? { x: t.x - e.x, y: t.y - e.y } : { x: 0, y: 0 } } _cleanupCachedDimensions() { this._boundaryRect = this._previewRect = void 0, this._parentPositions.clear() } _containInsideBoundaryOnResize() { let { x: t, y: e } = this._passiveTransform; if (0 === t && 0 === e || this.isDragging() || !this._boundaryElement) return; const i = this._boundaryElement.getBoundingClientRect(), r = this._rootElement.getBoundingClientRect(); if (0 === i.width && 0 === i.height || 0 === r.width && 0 === r.height) return; const o = i.left - r.left, s = r.right - i.right, a = i.top - r.top, l = r.bottom - i.bottom; i.width > r.width ? (o > 0 && (t += o), s > 0 && (t -= s)) : t = 0, i.height > r.height ? (a > 0 && (e += a), l > 0 && (e -= l)) : e = 0, (t !== this._passiveTransform.x || e !== this._passiveTransform.y) && this.setFreeDragPosition({ y: e, x: t }) } _getDragStartDelay(t) { const e = this.dragStartDelay; return "number" == typeof e ? e : Gc(t) ? e.touch : e ? e.mouse : 0 } _updateOnScroll(t) { const e = this._parentPositions.handleScroll(t); if (e) { const i = Vi(t); this._boundaryRect && i !== this._boundaryElement && i.contains(this._boundaryElement) && $c(this._boundaryRect, e.top, e.left), this._pickupPositionOnPage.x += e.left, this._pickupPositionOnPage.y += e.top, this._dropContainer || (this._activeTransform.x -= e.left, this._activeTransform.y -= e.top, this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y)) } } _getViewportScrollPosition() { const t = this._parentPositions.positions.get(this._document); return t ? t.scrollPosition : this._viewportRuler.getViewportScrollPosition() } _getShadowRoot() { return void 0 === this._cachedShadowRoot && (this._cachedShadowRoot = Lh(this._rootElement)), this._cachedShadowRoot } _getPreviewInsertionPoint(t, e) { const i = this._previewContainer || "global"; if ("parent" === i) return t; if ("global" === i) { const r = this._document; return e || r.fullscreenElement || r.webkitFullscreenElement || r.mozFullScreenElement || r.msFullscreenElement || r.body } return hn(i) } } function Uh(n, t) { return `translate3d(${Math.round(n)}px, ${Math.round(t)}px, 0)` } function iS(n, t, e) { return Math.max(t, Math.min(e, n)) } function Gc(n) { return "t" === n.type[0] } function rS(n, t) { const e = n.rootNodes; if (1 === e.length && e[0].nodeType === t.ELEMENT_NODE) return e[0]; const i = t.createElement("div"); return e.forEach(r => i.appendChild(r)), i } function oS(n, t) { n.style.width = `${t.width}px`, n.style.height = `${t.height}px`, n.style.transform = Uh(t.left, t.top) } function qc(n, t) { return Math.max(0, Math.min(t, n)) } class aU { constructor(t, e, i, r, o) { this._dragDropRegistry = e, this._ngZone = r, this._viewportRuler = o, this.disabled = !1, this.sortingDisabled = !1, this.autoScrollDisabled = !1, this.autoScrollStep = 2, this.enterPredicate = () => !0, this.sortPredicate = () => !0, this.beforeStarted = new se, this.entered = new se, this.exited = new se, this.dropped = new se, this.sorted = new se, this._isDragging = !1, this._itemPositions = [], this._previousSwap = { drag: null, delta: 0, overlaps: !1 }, this._draggables = [], this._siblings = [], this._orientation = "vertical", this._activeSiblings = new Set, this._direction = "ltr", this._viewportScrollSubscription = ut.EMPTY, this._verticalScrollDirection = 0, this._horizontalScrollDirection = 0, this._stopScrollTimers = new se, this._cachedShadowRoot = null, this._startScrollInterval = () => { this._stopScrolling(), function (n = 0, t = Fh) { return n < 0 && (n = 0), B_(n, n, t) }(0, UE).pipe(yn(this._stopScrollTimers)).subscribe(() => { const s = this._scrollNode, a = this.autoScrollStep; 1 === this._verticalScrollDirection ? s.scrollBy(0, -a) : 2 === this._verticalScrollDirection && s.scrollBy(0, a), 1 === this._horizontalScrollDirection ? s.scrollBy(-a, 0) : 2 === this._horizontalScrollDirection && s.scrollBy(a, 0) }) }, this.element = hn(t), this._document = i, this.withScrollableParents([this.element]), e.registerDropContainer(this), this._parentPositions = new KE(i, o) } dispose() { this._stopScrolling(), this._stopScrollTimers.complete(), this._viewportScrollSubscription.unsubscribe(), this.beforeStarted.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this.sorted.complete(), this._activeSiblings.clear(), this._scrollNode = null, this._parentPositions.clear(), this._dragDropRegistry.removeDropContainer(this) } isDragging() { return this._isDragging } start() { this._draggingStarted(), this._notifyReceivingSiblings() } enter(t, e, i, r) { let o; this._draggingStarted(), null == r ? (o = this.sortingDisabled ? this._draggables.indexOf(t) : -1, -1 === o && (o = this._getItemIndexFromPointerPosition(t, e, i))) : o = r; const s = this._activeDraggables, a = s.indexOf(t), l = t.getPlaceholderElement(); let d = s[o]; if (d === t && (d = s[o + 1]), !d && (null == o || -1 === o || o < s.length - 1) && this._shouldEnterAsFirstChild(e, i) && (d = s[0]), a > -1 && s.splice(a, 1), d && !this._dragDropRegistry.isDragging(d)) { const h = d.getRootElement(); h.parentElement.insertBefore(l, h), s.splice(o, 0, t) } else hn(this.element).appendChild(l), s.push(t); l.style.transform = "", this._cacheItemPositions(), this._cacheParentPositions(), this._notifyReceivingSiblings(), this.entered.next({ item: t, container: this, currentIndex: this.getItemIndex(t) }) } exit(t) { this._reset(), this.exited.next({ item: t, container: this }) } drop(t, e, i, r, o, s, a) { this._reset(), this.dropped.next({ item: t, currentIndex: e, previousIndex: i, container: this, previousContainer: r, isPointerOverContainer: o, distance: s, dropPoint: a }) } withItems(t) { const e = this._draggables; return this._draggables = t, t.forEach(i => i._withDropContainer(this)), this.isDragging() && (e.filter(r => r.isDragging()).every(r => -1 === t.indexOf(r)) ? this._reset() : this._cacheItems()), this } withDirection(t) { return this._direction = t, this } connectedTo(t) { return this._siblings = t.slice(), this } withOrientation(t) { return this._orientation = t, this } withScrollableParents(t) { const e = hn(this.element); return this._scrollableElements = -1 === t.indexOf(e) ? [e, ...t] : t.slice(), this } getScrollableParents() { return this._scrollableElements } getItemIndex(t) { return this._isDragging ? ("horizontal" === this._orientation && "rtl" === this._direction ? this._itemPositions.slice().reverse() : this._itemPositions).findIndex(i => i.drag === t) : this._draggables.indexOf(t) } isReceiving() { return this._activeSiblings.size > 0 } _sortItem(t, e, i, r) { if (this.sortingDisabled || !this._clientRect || !QE(this._clientRect, .05, e, i)) return; const o = this._itemPositions, s = this._getItemIndexFromPointerPosition(t, e, i, r); if (-1 === s && o.length > 0) return; const a = "horizontal" === this._orientation, l = o.findIndex(P => P.drag === t), d = o[s], m = d.clientRect, y = l > s ? 1 : -1, D = this._getItemOffsetPx(o[l].clientRect, m, y), M = this._getSiblingOffsetPx(l, o, y), k = o.slice(); (function (n, t, e) { const i = qc(t, n.length - 1), r = qc(e, n.length - 1); if (i === r) return; const o = n[i], s = r < i ? -1 : 1; for (let a = i; a !== r; a += s)n[a] = n[a + s]; n[r] = o })(o, l, s), this.sorted.next({ previousIndex: l, currentIndex: s, container: this, item: t }), o.forEach((P, H) => { if (k[H] === P) return; const F = P.drag === t, W = F ? D : M, ie = F ? t.getPlaceholderElement() : P.drag.getRootElement(); P.offset += W, a ? (ie.style.transform = zh(`translate3d(${Math.round(P.offset)}px, 0, 0)`, P.initialTransform), $c(P.clientRect, 0, W)) : (ie.style.transform = zh(`translate3d(0, ${Math.round(P.offset)}px, 0)`, P.initialTransform), $c(P.clientRect, W, 0)) }), this._previousSwap.overlaps = U_(m, e, i), this._previousSwap.drag = d.drag, this._previousSwap.delta = a ? r.x : r.y } _startScrollingIfNecessary(t, e) { if (this.autoScrollDisabled) return; let i, r = 0, o = 0; if (this._parentPositions.positions.forEach((s, a) => { a === this._document || !s.clientRect || i || QE(s.clientRect, .05, t, e) && ([r, o] = function (n, t, e, i) { const r = lS(t, i), o = cS(t, e); let s = 0, a = 0; if (r) { const l = n.scrollTop; 1 === r ? l > 0 && (s = 1) : n.scrollHeight - l > n.clientHeight && (s = 2) } if (o) { const l = n.scrollLeft; 1 === o ? l > 0 && (a = 1) : n.scrollWidth - l > n.clientWidth && (a = 2) } return [s, a] }(a, s.clientRect, t, e), (r || o) && (i = a)) }), !r && !o) { const { width: s, height: a } = this._viewportRuler.getViewportSize(), l = { width: s, height: a, top: 0, right: s, bottom: a, left: 0 }; r = lS(l, e), o = cS(l, t), i = window } i && (r !== this._verticalScrollDirection || o !== this._horizontalScrollDirection || i !== this._scrollNode) && (this._verticalScrollDirection = r, this._horizontalScrollDirection = o, this._scrollNode = i, (r || o) && i ? this._ngZone.runOutsideAngular(this._startScrollInterval) : this._stopScrolling()) } _stopScrolling() { this._stopScrollTimers.next() } _draggingStarted() { const t = hn(this.element).style; this.beforeStarted.next(), this._isDragging = !0, this._initialScrollSnap = t.msScrollSnapType || t.scrollSnapType || "", t.scrollSnapType = t.msScrollSnapType = "none", this._cacheItems(), this._viewportScrollSubscription.unsubscribe(), this._listenToScrollEvents() } _cacheParentPositions() { const t = hn(this.element); this._parentPositions.cache(this._scrollableElements), this._clientRect = this._parentPositions.positions.get(t).clientRect } _cacheItemPositions() { const t = "horizontal" === this._orientation; this._itemPositions = this._activeDraggables.map(e => { const i = e.getVisibleElement(); return { drag: e, offset: 0, initialTransform: i.style.transform || "", clientRect: z_(i) } }).sort((e, i) => t ? e.clientRect.left - i.clientRect.left : e.clientRect.top - i.clientRect.top) } _reset() { this._isDragging = !1; const t = hn(this.element).style; t.scrollSnapType = t.msScrollSnapType = this._initialScrollSnap, this._activeDraggables.forEach(e => { var i; const r = e.getRootElement(); if (r) { const o = null === (i = this._itemPositions.find(s => s.drag === e)) || void 0 === i ? void 0 : i.initialTransform; r.style.transform = o || "" } }), this._siblings.forEach(e => e._stopReceiving(this)), this._activeDraggables = [], this._itemPositions = [], this._previousSwap.drag = null, this._previousSwap.delta = 0, this._previousSwap.overlaps = !1, this._stopScrolling(), this._viewportScrollSubscription.unsubscribe(), this._parentPositions.clear() } _getSiblingOffsetPx(t, e, i) { const r = "horizontal" === this._orientation, o = e[t].clientRect, s = e[t + -1 * i]; let a = o[r ? "width" : "height"] * i; if (s) { const l = r ? "left" : "top", d = r ? "right" : "bottom"; -1 === i ? a -= s.clientRect[l] - o[d] : a += o[l] - s.clientRect[d] } return a } _getItemOffsetPx(t, e, i) { const r = "horizontal" === this._orientation; let o = r ? e.left - t.left : e.top - t.top; return -1 === i && (o += r ? e.width - t.width : e.height - t.height), o } _shouldEnterAsFirstChild(t, e) { if (!this._activeDraggables.length) return !1; const i = this._itemPositions, r = "horizontal" === this._orientation; if (i[0].drag !== this._activeDraggables[0]) { const s = i[i.length - 1].clientRect; return r ? t >= s.right : e >= s.bottom } { const s = i[0].clientRect; return r ? t <= s.left : e <= s.top } } _getItemIndexFromPointerPosition(t, e, i, r) { const o = "horizontal" === this._orientation, s = this._itemPositions.findIndex(({ drag: a, clientRect: l }) => { if (a === t) return !1; if (r) { const d = o ? r.x : r.y; if (a === this._previousSwap.drag && this._previousSwap.overlaps && d === this._previousSwap.delta) return !1 } return o ? e >= Math.floor(l.left) && e < Math.floor(l.right) : i >= Math.floor(l.top) && i < Math.floor(l.bottom) }); return -1 !== s && this.sortPredicate(s, t, this) ? s : -1 } _cacheItems() { this._activeDraggables = this._draggables.slice(), this._cacheItemPositions(), this._cacheParentPositions() } _isOverContainer(t, e) { return null != this._clientRect && U_(this._clientRect, t, e) } _getSiblingContainerFromPosition(t, e, i) { return this._siblings.find(r => r._canReceive(t, e, i)) } _canReceive(t, e, i) { if (!this._clientRect || !U_(this._clientRect, e, i) || !this.enterPredicate(t, this)) return !1; const r = this._getShadowRoot().elementFromPoint(e, i); if (!r) return !1; const o = hn(this.element); return r === o || o.contains(r) } _startReceiving(t, e) { const i = this._activeSiblings; !i.has(t) && e.every(r => this.enterPredicate(r, this) || this._draggables.indexOf(r) > -1) && (i.add(t), this._cacheParentPositions(), this._listenToScrollEvents()) } _stopReceiving(t) { this._activeSiblings.delete(t), this._viewportScrollSubscription.unsubscribe() } _listenToScrollEvents() { this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(t => { if (this.isDragging()) { const e = this._parentPositions.handleScroll(t); e && (this._itemPositions.forEach(({ clientRect: i }) => { $c(i, e.top, e.left) }), this._itemPositions.forEach(({ drag: i }) => { this._dragDropRegistry.isDragging(i) && i._sortFromLastPointerPosition() })) } else this.isReceiving() && this._cacheParentPositions() }) } _getShadowRoot() { if (!this._cachedShadowRoot) { const t = Lh(hn(this.element)); this._cachedShadowRoot = t || this._document } return this._cachedShadowRoot } _notifyReceivingSiblings() { const t = this._activeDraggables.filter(e => e.isDragging()); this._siblings.forEach(e => e._startReceiving(this, t)) } } function lS(n, t) { const { top: e, bottom: i, height: r } = n, o = .05 * r; return t >= e - o && t <= e + o ? 1 : t >= i - o && t <= i + o ? 2 : 0 } function cS(n, t) { const { left: e, right: i, width: r } = n, o = .05 * r; return t >= e - o && t <= e + o ? 1 : t >= i - o && t <= i + o ? 2 : 0 } const $h = ir({ passive: !1, capture: !0 }); let cU = (() => { class n { constructor(e, i) { this._ngZone = e, this._dropInstances = new Set, this._dragInstances = new Set, this._activeDragInstances = [], this._globalListeners = new Map, this._draggingPredicate = r => r.isDragging(), this.pointerMove = new se, this.pointerUp = new se, this.scroll = new se, this._preventDefaultWhileDragging = r => { this._activeDragInstances.length > 0 && r.preventDefault() }, this._persistentTouchmoveListener = r => { this._activeDragInstances.length > 0 && (this._activeDragInstances.some(this._draggingPredicate) && r.preventDefault(), this.pointerMove.next(r)) }, this._document = i } registerDropContainer(e) { this._dropInstances.has(e) || this._dropInstances.add(e) } registerDragItem(e) { this._dragInstances.add(e), 1 === this._dragInstances.size && this._ngZone.runOutsideAngular(() => { this._document.addEventListener("touchmove", this._persistentTouchmoveListener, $h) }) } removeDropContainer(e) { this._dropInstances.delete(e) } removeDragItem(e) { this._dragInstances.delete(e), this.stopDragging(e), 0 === this._dragInstances.size && this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, $h) } startDragging(e, i) { if (!(this._activeDragInstances.indexOf(e) > -1) && (this._activeDragInstances.push(e), 1 === this._activeDragInstances.length)) { const r = i.type.startsWith("touch"); this._globalListeners.set(r ? "touchend" : "mouseup", { handler: o => this.pointerUp.next(o), options: !0 }).set("scroll", { handler: o => this.scroll.next(o), options: !0 }).set("selectstart", { handler: this._preventDefaultWhileDragging, options: $h }), r || this._globalListeners.set("mousemove", { handler: o => this.pointerMove.next(o), options: $h }), this._ngZone.runOutsideAngular(() => { this._globalListeners.forEach((o, s) => { this._document.addEventListener(s, o.handler, o.options) }) }) } } stopDragging(e) { const i = this._activeDragInstances.indexOf(e); i > -1 && (this._activeDragInstances.splice(i, 1), 0 === this._activeDragInstances.length && this._clearGlobalListeners()) } isDragging(e) { return this._activeDragInstances.indexOf(e) > -1 } scrolled(e) { const i = [this.scroll]; return e && e !== this._document && i.push(new at(r => this._ngZone.runOutsideAngular(() => { const s = a => { this._activeDragInstances.length && r.next(a) }; return e.addEventListener("scroll", s, !0), () => { e.removeEventListener("scroll", s, !0) } }))), ei(...i) } ngOnDestroy() { this._dragInstances.forEach(e => this.removeDragItem(e)), this._dropInstances.forEach(e => this.removeDropContainer(e)), this._clearGlobalListeners(), this.pointerMove.complete(), this.pointerUp.complete() } _clearGlobalListeners() { this._globalListeners.forEach((e, i) => { this._document.removeEventListener(i, e.handler, e.options) }), this._globalListeners.clear() } } return n.\u0275fac = function (e) { return new (e || n)(L(Xe), L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const dU = { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 }; let uU = (() => { class n { constructor(e, i, r, o) { this._document = e, this._ngZone = i, this._viewportRuler = r, this._dragDropRegistry = o } createDrag(e, i = dU) { return new oU(e, i, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry) } createDropList(e) { return new aU(e, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler) } } return n.\u0275fac = function (e) { return new (e || n)(L(Be), L(Xe), L(Uc), L(cU)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), hU = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [uU], imports: [Ir] }), n })(); class G_ { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class q_ extends G_ { constructor(t, e, i, r) { super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = r } } class W_ extends G_ { constructor(t, e, i) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = i } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class fU extends G_ { constructor(t) { super(), this.element = t instanceof ke ? t.nativeElement : t } } class Y_ { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof q_ ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof W_ ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof fU ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class pU extends Y_ { constructor(t, e, i, r, o) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = r, this.attachDomPortal = s => { const a = s.element, l = this._document.createComment("dom-portal"); a.parentNode.insertBefore(l, a), this.outletElement.appendChild(a), this._attachedPortal = s, super.setDisposeFn(() => { l.parentNode && l.parentNode.replaceChild(a, l) }) }, this._document = o } attachComponentPortal(t) { const i = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let r; return t.viewContainerRef ? (r = t.viewContainerRef.createComponent(i, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => r.destroy())) : (r = i.create(t.injector || this._defaultInjector), this._appRef.attachView(r.hostView), this.setDisposeFn(() => { this._appRef.detachView(r.hostView), r.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(r)), this._attachedPortal = t, r } attachTemplatePortal(t) { let e = t.viewContainerRef, i = e.createEmbeddedView(t.templateRef, t.context); return i.rootNodes.forEach(r => this.outletElement.appendChild(r)), i.detectChanges(), this.setDisposeFn(() => { let r = e.indexOf(i); -1 !== r && e.remove(r) }), this._attachedPortal = t, i } dispose() { super.dispose(), this.outletElement.remove() } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let dS = (() => { class n extends Y_ { constructor(e, i, r) { super(), this._componentFactoryResolver = e, this._viewContainerRef = i, this._isInitialized = !1, this.attached = new we, this.attachDomPortal = o => { const s = o.element, a = this._document.createComment("dom-portal"); o.setAttachedHost(this), s.parentNode.insertBefore(a, s), this._getRootNode().appendChild(s), this._attachedPortal = o, super.setDisposeFn(() => { a.parentNode && a.parentNode.replaceChild(s, a) }) }, this._document = r } get portal() { return this._attachedPortal } set portal(e) { this.hasAttached() && !e && !this._isInitialized || (this.hasAttached() && super.detach(), e && super.attach(e), this._attachedPortal = e || null) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(e) { e.setAttachedHost(this); const i = null != e.viewContainerRef ? e.viewContainerRef : this._viewContainerRef, o = (e.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(e.component), s = i.createComponent(o, i.length, e.injector || i.injector); return i !== this._viewContainerRef && this._getRootNode().appendChild(s.hostView.rootNodes[0]), super.setDisposeFn(() => s.destroy()), this._attachedPortal = e, this._attachedRef = s, this.attached.emit(s), s } attachTemplatePortal(e) { e.setAttachedHost(this); const i = this._viewContainerRef.createEmbeddedView(e.templateRef, e.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = e, this._attachedRef = i, this.attached.emit(i), i } _getRootNode() { const e = this._viewContainerRef.element.nativeElement; return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode } } return n.\u0275fac = function (e) { return new (e || n)(w(Fo), w(Zt), w(Be)) }, n.\u0275dir = z({ type: n, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [Z] }), n })(), uo = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), uS = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[tl]] }), n })(), yS = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[jh]] }), n })(), bS = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(); const PU = new V("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let oe = (() => { class n { constructor(e, i, r) { this._sanityChecks = i, this._document = r, this._hasDoneGlobalChecks = !1, e._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(e) { return !P_() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[e]) } } return n.\u0275fac = function (e) { return new (e || n)(L(zE), L(PU, 8), L(Be)) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[tl], tl] }), n })(); function Xc(n, t) { return class extends n { constructor(...e) { super(...e), this.defaultColor = t, this.color = t } get color() { return this._color } set color(e) { const i = e || this.defaultColor; i !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), i && this._elementRef.nativeElement.classList.add(`mat-${i}`), this._color = i) } } } const NU = new V("MAT_DATE_LOCALE", { providedIn: "root", factory: function () { return tu(no) } }); class Or { constructor() { this._localeChanges = new se, this.localeChanges = this._localeChanges } getValidDateOrNull(t) { return this.isDateInstance(t) && this.isValid(t) ? t : null } deserialize(t) { return null == t || this.isDateInstance(t) && this.isValid(t) ? t : this.invalid() } setLocale(t) { this.locale = t, this._localeChanges.next() } compareDate(t, e) { return this.getYear(t) - this.getYear(e) || this.getMonth(t) - this.getMonth(e) || this.getDate(t) - this.getDate(e) } sameDate(t, e) { if (t && e) { let i = this.isValid(t), r = this.isValid(e); return i && r ? !this.compareDate(t, e) : i == r } return t == e } clampDate(t, e, i) { return e && this.compareDate(t, e) < 0 ? e : i && this.compareDate(t, i) > 0 ? i : t } } const uv = new V("mat-date-formats"), BU = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/; function hv(n, t) { const e = Array(n); for (let i = 0; i < n; i++)e[i] = t(i); return e } let VU = (() => { class n extends Or { constructor(e, i) { super(), this.useUtcForDisplay = !1, super.setLocale(e) } getYear(e) { return e.getFullYear() } getMonth(e) { return e.getMonth() } getDate(e) { return e.getDate() } getDayOfWeek(e) { return e.getDay() } getMonthNames(e) { const i = new Intl.DateTimeFormat(this.locale, { month: e, timeZone: "utc" }); return hv(12, r => this._format(i, new Date(2017, r, 1))) } getDateNames() { const e = new Intl.DateTimeFormat(this.locale, { day: "numeric", timeZone: "utc" }); return hv(31, i => this._format(e, new Date(2017, 0, i + 1))) } getDayOfWeekNames(e) { const i = new Intl.DateTimeFormat(this.locale, { weekday: e, timeZone: "utc" }); return hv(7, r => this._format(i, new Date(2017, 0, r + 1))) } getYearName(e) { const i = new Intl.DateTimeFormat(this.locale, { year: "numeric", timeZone: "utc" }); return this._format(i, e) } getFirstDayOfWeek() { return 0 } getNumDaysInMonth(e) { return this.getDate(this._createDateWithOverflow(this.getYear(e), this.getMonth(e) + 1, 0)) } clone(e) { return new Date(e.getTime()) } createDate(e, i, r) { let o = this._createDateWithOverflow(e, i, r); return o.getMonth(), o } today() { return new Date } parse(e) { return "number" == typeof e ? new Date(e) : e ? new Date(Date.parse(e)) : null } format(e, i) { if (!this.isValid(e)) throw Error("NativeDateAdapter: Cannot format invalid date."); const r = new Intl.DateTimeFormat(this.locale, Object.assign(Object.assign({}, i), { timeZone: "utc" })); return this._format(r, e) } addCalendarYears(e, i) { return this.addCalendarMonths(e, 12 * i) } addCalendarMonths(e, i) { let r = this._createDateWithOverflow(this.getYear(e), this.getMonth(e) + i, this.getDate(e)); return this.getMonth(r) != ((this.getMonth(e) + i) % 12 + 12) % 12 && (r = this._createDateWithOverflow(this.getYear(r), this.getMonth(r), 0)), r } addCalendarDays(e, i) { return this._createDateWithOverflow(this.getYear(e), this.getMonth(e), this.getDate(e) + i) } toIso8601(e) { return [e.getUTCFullYear(), this._2digit(e.getUTCMonth() + 1), this._2digit(e.getUTCDate())].join("-") } deserialize(e) { if ("string" == typeof e) { if (!e) return null; if (BU.test(e)) { let i = new Date(e); if (this.isValid(i)) return i } } return super.deserialize(e) } isDateInstance(e) { return e instanceof Date } isValid(e) { return !isNaN(e.getTime()) } invalid() { return new Date(NaN) } _createDateWithOverflow(e, i, r) { const o = new Date; return o.setFullYear(e, i, r), o.setHours(0, 0, 0, 0), o } _2digit(e) { return ("00" + e).slice(-2) } _format(e, i) { const r = new Date; return r.setUTCFullYear(i.getFullYear(), i.getMonth(), i.getDate()), r.setUTCHours(i.getHours(), i.getMinutes(), i.getSeconds(), i.getMilliseconds()), e.format(r) } } return n.\u0275fac = function (e) { return new (e || n)(L(NU, 8), L(ai)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const HU = { parse: { dateInput: null }, display: { dateInput: { year: "numeric", month: "numeric", day: "numeric" }, monthYearLabel: { year: "numeric", month: "short" }, dateA11yLabel: { year: "numeric", month: "long", day: "numeric" }, monthYearA11yLabel: { year: "numeric", month: "long" } } }; let jU = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [{ provide: Or, useClass: VU }], imports: [[Xa]] }), n })(), zU = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [{ provide: uv, useValue: HU }], imports: [[jU]] }), n })(), af = (() => { class n { isErrorState(e, i) { return !!(e && e.invalid && (e.touched || i && i.submitted)) } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), lf = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe], oe] }), n })(), rr = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe, Xa], oe] }), n })(), pv = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe]] }), n })(), cf = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[rr, un, oe, pv]] }), n })(); const TS = az(); class JU { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = nn(-this._previousScrollPosition.left), t.style.top = nn(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, i = t.style, r = this._document.body.style, o = i.scrollBehavior || "", s = r.scrollBehavior || ""; this._isEnabled = !1, i.left = this._previousHTMLStyles.left, i.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), TS && (i.scrollBehavior = r.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), TS && (i.scrollBehavior = o, r.scrollBehavior = s) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const e = this._document.body, i = this._viewportRuler.getViewportSize(); return e.scrollHeight > i.height || e.scrollWidth > i.width } } class e3 { constructor(t, e, i, r) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i, this._config = r, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const e = this._viewportRuler.getViewportScrollPosition().top; Math.abs(e - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class kS { enable() { } disable() { } attach() { } } function mv(n, t) { return t.some(e => n.bottom < e.top || n.top > e.bottom || n.right < e.left || n.left > e.right) } function AS(n, t) { return t.some(e => n.top < e.top || n.bottom > e.bottom || n.left < e.left || n.right > e.right) } class t3 { constructor(t, e, i, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this._config = r, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const e = this._overlayRef.overlayElement.getBoundingClientRect(), { width: i, height: r } = this._viewportRuler.getViewportSize(); mv(e, [{ width: i, height: r, bottom: r, right: i, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let n3 = (() => { class n { constructor(e, i, r, o) { this._scrollDispatcher = e, this._viewportRuler = i, this._ngZone = r, this.noop = () => new kS, this.close = s => new e3(this._scrollDispatcher, this._ngZone, this._viewportRuler, s), this.block = () => new JU(this._viewportRuler, this._document), this.reposition = s => new t3(this._scrollDispatcher, this._viewportRuler, this._ngZone, s), this._document = o } } return n.\u0275fac = function (e) { return new (e || n)(L(eU), L(Uc), L(Xe), L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); class gv { constructor(t) { if (this.scrollStrategy = new kS, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const i of e) void 0 !== t[i] && (this[i] = t[i]) } } } class r3 { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } class o3 { constructor(t, e, i, r, o, s, a, l, d) { this._portalOutlet = t, this._host = e, this._pane = i, this._config = r, this._ngZone = o, this._keyboardDispatcher = s, this._document = a, this._location = l, this._outsideClickDispatcher = d, this._backdropElement = null, this._backdropClick = new se, this._attachments = new se, this._detachments = new se, this._locationChanges = ut.EMPTY, this._backdropClickHandler = h => this._backdropClick.next(h), this._keydownEvents = new se, this._outsidePointerEvents = new se, r.scrollStrategy && (this._scrollStrategy = r.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = r.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(pn(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { var t; const e = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._disposeBackdrop(this._backdropElement), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), null === (t = this._host) || void 0 === t || t.remove(), this._previousHostParent = this._pane = this._host = null, e && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = nn(this._config.width), t.height = nn(this._config.height), t.minWidth = nn(this._config.minWidth), t.minHeight = nn(this._config.minHeight), t.maxWidth = nn(this._config.maxWidth), t.maxHeight = nn(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { const t = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(t) }) }) : this._backdropElement.classList.add(t) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { const t = this._backdropElement; if (!t) return; let e; const i = () => { t && (t.removeEventListener("click", this._backdropClickHandler), t.removeEventListener("transitionend", i), this._disposeBackdrop(t)), this._config.backdropClass && this._toggleClasses(t, this._config.backdropClass, !1), clearTimeout(e) }; t.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { t.addEventListener("transitionend", i) }), t.style.pointerEvents = "none", e = this._ngZone.runOutsideAngular(() => setTimeout(i, 500)) } _toggleClasses(t, e, i) { const r = kE(e || []).filter(o => !!o); r.length && (i ? t.classList.add(...r) : t.classList.remove(...r)) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(yn(ei(this._attachments, this._detachments))).subscribe(() => { (!this._pane || !this._host || 0 === this._pane.children.length) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._host.remove()), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } _disposeBackdrop(t) { t && (t.remove(), this._backdropElement === t && (this._backdropElement = null)) } } let _v = (() => { class n { constructor(e, i) { this._platform = i, this._document = e } ngOnDestroy() { var e; null === (e = this._containerElement) || void 0 === e || e.remove() } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const e = "cdk-overlay-container"; if (this._platform.isBrowser || P_()) { const r = this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`); for (let o = 0; o < r.length; o++)r[o].remove() } const i = this._document.createElement("div"); i.classList.add(e), P_() ? i.setAttribute("platform", "test") : this._platform.isBrowser || i.setAttribute("platform", "server"), this._document.body.appendChild(i), this._containerElement = i } } return n.\u0275fac = function (e) { return new (e || n)(L(Be), L(ai)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const IS = "cdk-overlay-connected-position-bounding-box", s3 = /([A-Za-z%]+)$/; class a3 { constructor(t, e, i, r, o) { this._viewportRuler = e, this._document = i, this._platform = r, this._overlayContainer = o, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new se, this._resizeSubscription = ut.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add(IS), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, i = this._viewportRect, r = []; let o; for (let s of this._preferredPositions) { let a = this._getOriginPoint(t, s), l = this._getOverlayPoint(a, e, s), d = this._getOverlayFit(l, e, i, s); if (d.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(s, a); this._canFitWithFlexibleDimensions(d, l, i) ? r.push({ position: s, origin: a, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(a, s) }) : (!o || o.overlayFit.visibleArea < d.visibleArea) && (o = { overlayFit: d, overlayPoint: l, originPoint: a, position: s, overlayRect: e }) } if (r.length) { let s = null, a = -1; for (const l of r) { const d = l.boundingBoxRect.width * l.boundingBoxRect.height * (l.position.weight || 1); d > a && (a = d, s = l) } return this._isPushed = !1, void this._applyPosition(s.position, s.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(o.position, o.originPoint); this._applyPosition(o.position, o.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && Ms(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(IS), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let i, r; if ("center" == e.originX) i = t.left + t.width / 2; else { const o = this._isRtl() ? t.right : t.left, s = this._isRtl() ? t.left : t.right; i = "start" == e.originX ? o : s } return r = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: i, y: r } } _getOverlayPoint(t, e, i) { let r, o; return r = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, o = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, { x: t.x + r, y: t.y + o } } _getOverlayFit(t, e, i, r) { const o = OS(e); let { x: s, y: a } = t, l = this._getOffset(r, "x"), d = this._getOffset(r, "y"); l && (s += l), d && (a += d); let y = 0 - a, D = a + o.height - i.height, M = this._subtractOverflows(o.width, 0 - s, s + o.width - i.width), k = this._subtractOverflows(o.height, y, D), P = M * k; return { visibleArea: P, isCompletelyWithinViewport: o.width * o.height === P, fitsInViewportVertically: k === o.height, fitsInViewportHorizontally: M == o.width } } _canFitWithFlexibleDimensions(t, e, i) { if (this._hasFlexibleDimensions) { const r = i.bottom - e.y, o = i.right - e.x, s = RS(this._overlayRef.getConfig().minHeight), a = RS(this._overlayRef.getConfig().minWidth), d = t.fitsInViewportHorizontally || null != a && a <= o; return (t.fitsInViewportVertically || null != s && s <= r) && d } return !1 } _pushOverlayOnScreen(t, e, i) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const r = OS(e), o = this._viewportRect, s = Math.max(t.x + r.width - o.width, 0), a = Math.max(t.y + r.height - o.height, 0), l = Math.max(o.top - i.top - t.y, 0), d = Math.max(o.left - i.left - t.x, 0); let h = 0, m = 0; return h = r.width <= o.width ? d || -s : t.x < this._viewportMargin ? o.left - i.left - t.x : 0, m = r.height <= o.height ? l || -a : t.y < this._viewportMargin ? o.top - i.top - t.y : 0, this._previousPushAmount = { x: h, y: m }, { x: t.x + h, y: t.y + m } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const i = this._getScrollVisibility(), r = new r3(t, i); this._positionChanges.next(r) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let i, r = t.overlayY; i = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let o = 0; o < e.length; o++)e[o].style.transformOrigin = `${i} ${r}` } _calculateBoundingBoxRect(t, e) { const i = this._viewportRect, r = this._isRtl(); let o, s, a, h, m, y; if ("top" === e.overlayY) s = t.y, o = i.height - s + this._viewportMargin; else if ("bottom" === e.overlayY) a = i.height - t.y + 2 * this._viewportMargin, o = i.height - a + this._viewportMargin; else { const D = Math.min(i.bottom - t.y + i.top, t.y), M = this._lastBoundingBoxSize.height; o = 2 * D, s = t.y - D, o > M && !this._isInitialRender && !this._growAfterOpen && (s = t.y - M / 2) } if ("end" === e.overlayX && !r || "start" === e.overlayX && r) y = i.width - t.x + this._viewportMargin, h = t.x - this._viewportMargin; else if ("start" === e.overlayX && !r || "end" === e.overlayX && r) m = t.x, h = i.right - t.x; else { const D = Math.min(i.right - t.x + i.left, t.x), M = this._lastBoundingBoxSize.width; h = 2 * D, m = t.x - D, h > M && !this._isInitialRender && !this._growAfterOpen && (m = t.x - M / 2) } return { top: s, left: m, bottom: a, right: y, width: h, height: o } } _setBoundingBoxStyles(t, e) { const i = this._calculateBoundingBoxRect(t, e); !this._isInitialRender && !this._growAfterOpen && (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width)); const r = {}; if (this._hasExactPosition()) r.top = r.left = "0", r.bottom = r.right = r.maxHeight = r.maxWidth = "", r.width = r.height = "100%"; else { const o = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth; r.height = nn(i.height), r.top = nn(i.top), r.bottom = nn(i.bottom), r.width = nn(i.width), r.left = nn(i.left), r.right = nn(i.right), r.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", r.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", o && (r.maxHeight = nn(o)), s && (r.maxWidth = nn(s)) } this._lastBoundingBoxSize = i, Ms(this._boundingBox.style, r) } _resetBoundingBoxStyles() { Ms(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { Ms(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const i = {}, r = this._hasExactPosition(), o = this._hasFlexibleDimensions, s = this._overlayRef.getConfig(); if (r) { const h = this._viewportRuler.getViewportScrollPosition(); Ms(i, this._getExactOverlayY(e, t, h)), Ms(i, this._getExactOverlayX(e, t, h)) } else i.position = "static"; let a = "", l = this._getOffset(e, "x"), d = this._getOffset(e, "y"); l && (a += `translateX(${l}px) `), d && (a += `translateY(${d}px)`), i.transform = a.trim(), s.maxHeight && (r ? i.maxHeight = nn(s.maxHeight) : o && (i.maxHeight = "")), s.maxWidth && (r ? i.maxWidth = nn(s.maxWidth) : o && (i.maxWidth = "")), Ms(this._pane.style, i) } _getExactOverlayY(t, e, i) { let r = { top: "", bottom: "" }, o = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, i)); let s = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return o.y -= s, "bottom" === t.overlayY ? r.bottom = this._document.documentElement.clientHeight - (o.y + this._overlayRect.height) + "px" : r.top = nn(o.y), r } _getExactOverlayX(t, e, i) { let s, r = { left: "", right: "" }, o = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, i)), s = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === s ? r.right = this._document.documentElement.clientWidth - (o.x + this._overlayRect.width) + "px" : r.left = nn(o.x), r } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), i = this._scrollables.map(r => r.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: AS(t, i), isOriginOutsideView: mv(t, i), isOverlayClipped: AS(e, i), isOverlayOutsideView: mv(e, i) } } _subtractOverflows(t, ...e) { return e.reduce((i, r) => i - Math.max(r, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, i = this._viewportRuler.getViewportScrollPosition(); return { top: i.top + this._viewportMargin, left: i.left + this._viewportMargin, right: i.left + t - this._viewportMargin, bottom: i.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && kE(t).forEach(e => { "" !== e && -1 === this._appliedPanelClasses.indexOf(e) && (this._appliedPanelClasses.push(e), this._pane.classList.add(e)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof ke) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, i = t.height || 0; return { top: t.y, bottom: t.y + i, left: t.x, right: t.x + e, height: i, width: e } } } function Ms(n, t) { for (let e in t) t.hasOwnProperty(e) && (n[e] = t[e]); return n } function RS(n) { if ("number" != typeof n && null != n) { const [t, e] = n.split(s3); return e && "px" !== e ? null : parseFloat(t) } return n || null } function OS(n) { return { top: Math.floor(n.top), right: Math.floor(n.right), bottom: Math.floor(n.bottom), left: Math.floor(n.left), width: Math.floor(n.width), height: Math.floor(n.height) } } const PS = "cdk-global-overlay-wrapper"; class l3 { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(PS), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, i = this._overlayRef.getConfig(), { width: r, height: o, maxWidth: s, maxHeight: a } = i, l = !("100%" !== r && "100vw" !== r || s && "100%" !== s && "100vw" !== s), d = !("100%" !== o && "100vh" !== o || a && "100%" !== a && "100vh" !== a); t.position = this._cssPosition, t.marginLeft = l ? "0" : this._leftOffset, t.marginTop = d ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, l ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = d ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, i = e.style; e.classList.remove(PS), i.justifyContent = i.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let c3 = (() => { class n { constructor(e, i, r, o) { this._viewportRuler = e, this._document = i, this._platform = r, this._overlayContainer = o } global() { return new l3 } flexibleConnectedTo(e) { return new a3(e, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return n.\u0275fac = function (e) { return new (e || n)(L(Uc), L(Be), L(ai), L(_v)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), FS = (() => { class n { constructor(e) { this._attachedOverlays = [], this._document = e } ngOnDestroy() { this.detach() } add(e) { this.remove(e), this._attachedOverlays.push(e) } remove(e) { const i = this._attachedOverlays.indexOf(e); i > -1 && this._attachedOverlays.splice(i, 1), 0 === this._attachedOverlays.length && this.detach() } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), d3 = (() => { class n extends FS { constructor(e) { super(e), this._keydownListener = i => { const r = this._attachedOverlays; for (let o = r.length - 1; o > -1; o--)if (r[o]._keydownEvents.observers.length > 0) { r[o]._keydownEvents.next(i); break } } } add(e) { super.add(e), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return n.\u0275fac = function (e) { return new (e || n)(L(Be)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), u3 = (() => { class n extends FS { constructor(e, i) { super(e), this._platform = i, this._cursorStyleIsSet = !1, this._pointerDownListener = r => { this._pointerDownEventTarget = Vi(r) }, this._clickListener = r => { const o = Vi(r), s = "click" === r.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : o; this._pointerDownEventTarget = null; const a = this._attachedOverlays.slice(); for (let l = a.length - 1; l > -1; l--) { const d = a[l]; if (!(d._outsidePointerEvents.observers.length < 1) && d.hasAttached()) { if (d.overlayElement.contains(o) || d.overlayElement.contains(s)) break; d._outsidePointerEvents.next(r) } } } } add(e) { if (super.add(e), !this._isAttached) { const i = this._document.body; i.addEventListener("pointerdown", this._pointerDownListener, !0), i.addEventListener("click", this._clickListener, !0), i.addEventListener("auxclick", this._clickListener, !0), i.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = i.style.cursor, i.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const e = this._document.body; e.removeEventListener("pointerdown", this._pointerDownListener, !0), e.removeEventListener("click", this._clickListener, !0), e.removeEventListener("auxclick", this._clickListener, !0), e.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (e.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } } return n.\u0275fac = function (e) { return new (e || n)(L(Be), L(ai)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), h3 = 0, Pr = (() => { class n { constructor(e, i, r, o, s, a, l, d, h, m, y) { this.scrollStrategies = e, this._overlayContainer = i, this._componentFactoryResolver = r, this._positionBuilder = o, this._keyboardDispatcher = s, this._injector = a, this._ngZone = l, this._document = d, this._directionality = h, this._location = m, this._outsideClickDispatcher = y } create(e) { const i = this._createHostElement(), r = this._createPaneElement(i), o = this._createPortalOutlet(r), s = new gv(e); return s.direction = s.direction || this._directionality.value, new o3(o, i, r, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(e) { const i = this._document.createElement("div"); return i.id = "cdk-overlay-" + h3++, i.classList.add("cdk-overlay-pane"), e.appendChild(i), i } _createHostElement() { const e = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(e), e } _createPortalOutlet(e) { return this._appRef || (this._appRef = this._injector.get(Va)), new pU(e, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return n.\u0275fac = function (e) { return new (e || n)(L(n3), L(_v), L(Fo), L(c3), L(d3), L(qt), L(Xe), L(Be), L(jo), L(_c), L(u3)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(); const m3 = { provide: new V("cdk-connected-overlay-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let mo = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [Pr, m3], imports: [[tl, uo, jh], jh] }), n })(), Lv = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe, Hc], oe] }), n })(); const D5 = { provide: new V("mat-autocomplete-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let E5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [D5], imports: [[mo, cf, oe, un], Ir, cf, oe] }), n })(), S5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[jc, oe], oe] }), n })(), T5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[mo, oe, uo], oe] }), n })(), rd = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[rr, oe], oe] }), n })(), F5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe, rr], oe] }), n })(), N5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe], oe] }), n })(), $T = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), Y5 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[rr, oe, Hc, $T], oe, $T] }), n })(); const YT = new V("mat-chips-default-options"); let a$ = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [af, { provide: YT, useValue: { separatorKeyCodes: [13] } }], imports: [[oe]] }), n })(), sk = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe], oe] }), n })(), zv = (() => { class n { constructor() { this.changes = new se, this.optionalLabel = "Optional", this.completedLabel = "Completed", this.editableLabel = "Editable" } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const P$ = { provide: zv, deps: [[new an, new pi, zv]], useFactory: function (n) { return n || new zv } }; let F$ = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [P$, af], imports: [[oe, un, uo, rd, uS, sk, rr], oe] }), n })(), lk = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[Xa]] }), n })(), L$ = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [af], imports: [[lk, Lv, oe], lk, Lv] }), n })(), W$ = (() => { class n { constructor() { this.changes = new se, this.calendarLabel = "Calendar", this.openCalendarLabel = "Open calendar", this.closeCalendarLabel = "Close calendar", this.prevMonthLabel = "Previous month", this.nextMonthLabel = "Next month", this.prevYearLabel = "Previous year", this.nextYearLabel = "Next year", this.prevMultiYearLabel = "Previous 24 years", this.nextMultiYearLabel = "Next 24 years", this.switchToMonthViewLabel = "Choose date", this.switchToMultiYearViewLabel = "Choose month and year" } formatYearRange(e, i) { return `${e} \u2013 ${i}` } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const K$ = { provide: new V("mat-datepicker-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let t8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [W$, K$], imports: [[un, rd, mo, jc, uo, oe], Ir] }), n })(); function n8(n, t) { } class Uv { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = "first-tabbable", this.restoreFocus = !0, this.closeOnNavigation = !0 } } const r8 = { dialogContainer: Rt("dialogContainer", [je("void, exit", ne({ opacity: 0, transform: "scale(0.7)" })), je("enter", ne({ transform: "none" })), Je("* => enter", rt("150ms cubic-bezier(0, 0, 0.2, 1)", ne({ transform: "none", opacity: 1 }))), Je("* => void, * => exit", rt("75ms cubic-bezier(0.4, 0.0, 0.2, 1)", ne({ opacity: 0 })))]) }; let o8 = (() => { class n extends Y_ { constructor(e, i, r, o, s, a, l, d) { super(), this._elementRef = e, this._focusTrapFactory = i, this._changeDetectorRef = r, this._config = s, this._interactivityChecker = a, this._ngZone = l, this._focusMonitor = d, this._animationStateChanged = new we, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = h => (this._portalOutlet.hasAttached(), this._portalOutlet.attachDomPortal(h)), this._ariaLabelledBy = s.ariaLabelledBy || null, this._document = o } _initializeWithAttachedContent() { this._setupFocusTrap(), this._capturePreviouslyFocusedElement() } attachComponentPortal(e) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachComponentPortal(e) } attachTemplatePortal(e) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachTemplatePortal(e) } _recaptureFocus() { this._containsFocus() || this._trapFocus() } _forceFocus(e, i) { this._interactivityChecker.isFocusable(e) || (e.tabIndex = -1, this._ngZone.runOutsideAngular(() => { e.addEventListener("blur", () => e.removeAttribute("tabindex")), e.addEventListener("mousedown", () => e.removeAttribute("tabindex")) })), e.focus(i) } _focusByCssSelector(e, i) { let r = this._elementRef.nativeElement.querySelector(e); r && this._forceFocus(r, i) } _trapFocus() { const e = this._elementRef.nativeElement; switch (this._config.autoFocus) { case !1: case "dialog": this._containsFocus() || e.focus(); break; case !0: case "first-tabbable": this._focusTrap.focusInitialElementWhenReady().then(i => { i || this._focusDialogContainer() }); break; case "first-heading": this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]'); break; default: this._focusByCssSelector(this._config.autoFocus) } } _restoreFocus() { const e = this._elementFocusedBeforeDialogWasOpened; if (this._config.restoreFocus && e && "function" == typeof e.focus) { const i = O_(), r = this._elementRef.nativeElement; (!i || i === this._document.body || i === r || r.contains(i)) && (this._focusMonitor ? (this._focusMonitor.focusVia(e, this._closeInteractionType), this._closeInteractionType = null) : e.focus()) } this._focusTrap && this._focusTrap.destroy() } _setupFocusTrap() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement) } _capturePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = O_()) } _focusDialogContainer() { this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus() } _containsFocus() { const e = this._elementRef.nativeElement, i = O_(); return e === i || e.contains(i) } } return n.\u0275fac = function (e) { return new (e || n)(w(ke), w(xz), w(_n), w(Be, 8), w(Uv), w(NE), w(Xe), w(ws)) }, n.\u0275dir = z({ type: n, viewQuery: function (e, i) { if (1 & e && Jt(dS, 7), 2 & e) { let r; ze(r = function () { return n = q(), t = Cy(), n[19].queries[t].queryList; var n, t }()) && (i._portalOutlet = r.first) } }, features: [Z] }), n })(), s8 = (() => { class n extends o8 { constructor() { super(...arguments), this._state = "enter" } _onAnimationDone({ toState: e, totalTime: i }) { "enter" === e ? (this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: i })) : "exit" === e && (this._restoreFocus(), this._animationStateChanged.next({ state: "closed", totalTime: i })) } _onAnimationStart({ toState: e, totalTime: i }) { "enter" === e ? this._animationStateChanged.next({ state: "opening", totalTime: i }) : ("exit" === e || "void" === e) && this._animationStateChanged.next({ state: "closing", totalTime: i }) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } return n.\u0275fac = function () { let t; return function (i) { return (t || (t = function (n) { return hr(() => { const t = n.prototype.constructor, e = t[gt] || up(t), i = Object.prototype; let r = Object.getPrototypeOf(n.prototype).constructor; for (; r && r !== i;) { const o = r[gt] || up(r); if (o && o !== e) return o; r = Object.getPrototypeOf(r) } return o => new o }) }(n)))(i || n) } }(), n.\u0275cmp = ue({ type: n, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function (e, i) { 1 & e && wm("@dialogContainer.start", function (o) { return i._onAnimationStart(o) })("@dialogContainer.done", function (o) { return i._onAnimationDone(o) }), 2 & e && (Jr("id", i._id), nt("role", i._config.role)("aria-labelledby", i._config.ariaLabel ? null : i._ariaLabelledBy)("aria-label", i._config.ariaLabel)("aria-describedby", i._config.ariaDescribedBy || null), Tm("@dialogContainer", i._state)) }, features: [Z], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function (e, i) { 1 & e && Zr(0, n8, 0, 0, "ng-template", 0) }, directives: [dS], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [r8.dialogContainer] } }), n })(), a8 = 0; class l8 { constructor(t, e, i = "mat-dialog-" + a8++) { this._overlayRef = t, this._containerInstance = e, this.id = i, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new se, this._afterClosed = new se, this._beforeClosed = new se, this._state = 0, e._id = i, e._animationStateChanged.pipe(An(r => "opened" === r.state), pn(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(An(r => "closed" === r.state), pn(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._finishDialogClose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(An(r => 27 === r.keyCode && !this.disableClose && !function (n, ...t) { return t.length ? t.some(e => n[e]) : n.altKey || n.shiftKey || n.ctrlKey || n.metaKey }(r))).subscribe(r => { r.preventDefault(), hk(this, "keyboard") }), t.backdropClick().subscribe(() => { this.disableClose ? this._containerInstance._recaptureFocus() : hk(this, "mouse") }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(An(e => "closing" === e.state), pn(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100) }), this._state = 1, this._containerInstance._startExitAnimation() } afterOpened() { return this._afterOpened } afterClosed() { return this._afterClosed } beforeClosed() { return this._beforeClosed } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._overlayRef.updateSize({ width: t, height: e }), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } getState() { return this._state } _finishDialogClose() { this._state = 2, this._overlayRef.dispose() } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } function hk(n, t, e) { return void 0 !== n._containerInstance && (n._containerInstance._closeInteractionType = t), n.close(e) } const c8 = new V("MatDialogData"), d8 = new V("mat-dialog-default-options"), fk = new V("mat-dialog-scroll-strategy"), h8 = { provide: fk, deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.block() } }; let f8 = (() => { class n { constructor(e, i, r, o, s, a, l, d, h, m) { this._overlay = e, this._injector = i, this._defaultOptions = r, this._parentDialog = o, this._overlayContainer = s, this._dialogRefConstructor = l, this._dialogContainerType = d, this._dialogDataToken = h, this._animationMode = m, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new se, this._afterOpenedAtThisLevel = new se, this._ariaHiddenElements = new Map, this._dialogAnimatingOpen = !1, this.afterAllClosed = th(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(Dc(void 0))), this._scrollStrategy = a } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } _getAfterAllClosed() { const e = this._parentDialog; return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel } open(e, i) { if (i = function (n, t) { return Object.assign(Object.assign({}, t), n) }(i, this._defaultOptions || new Uv), i.id && this.getDialogById(i.id), this._dialogAnimatingOpen) return this._lastDialogRef; const r = this._createOverlay(i), o = this._attachDialogContainer(r, i); if ("NoopAnimations" !== this._animationMode) { const a = o._animationStateChanged.subscribe(l => { "opening" === l.state && (this._dialogAnimatingOpen = !0), "opened" === l.state && (this._dialogAnimatingOpen = !1, a.unsubscribe()) }); this._animationStateSubscriptions || (this._animationStateSubscriptions = new ut), this._animationStateSubscriptions.add(a) } const s = this._attachDialogContent(e, o, r, i); return this._lastDialogRef = s, this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(s), s.afterClosed().subscribe(() => this._removeOpenDialog(s)), this.afterOpened.next(s), o._initializeWithAttachedContent(), s } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(e) { return this.openDialogs.find(i => i.id === e) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete(), this._animationStateSubscriptions && this._animationStateSubscriptions.unsubscribe() } _createOverlay(e) { const i = this._getOverlayConfig(e); return this._overlay.create(i) } _getOverlayConfig(e) { const i = new gv({ positionStrategy: this._overlay.position().global(), scrollStrategy: e.scrollStrategy || this._scrollStrategy(), panelClass: e.panelClass, hasBackdrop: e.hasBackdrop, direction: e.direction, minWidth: e.minWidth, minHeight: e.minHeight, maxWidth: e.maxWidth, maxHeight: e.maxHeight, disposeOnNavigation: e.closeOnNavigation }); return e.backdropClass && (i.backdropClass = e.backdropClass), i } _attachDialogContainer(e, i) { const o = qt.create({ parent: i && i.viewContainerRef && i.viewContainerRef.injector || this._injector, providers: [{ provide: Uv, useValue: i }] }), s = new q_(this._dialogContainerType, i.viewContainerRef, o, i.componentFactoryResolver); return e.attach(s).instance } _attachDialogContent(e, i, r, o) { const s = new this._dialogRefConstructor(r, i, o.id); if (e instanceof cn) i.attachTemplatePortal(new W_(e, null, { $implicit: o.data, dialogRef: s })); else { const a = this._createInjector(o, s, i), l = i.attachComponentPortal(new q_(e, o.viewContainerRef, a)); s.componentInstance = l.instance } return s.updateSize(o.width, o.height).updatePosition(o.position), s } _createInjector(e, i, r) { const o = e && e.viewContainerRef && e.viewContainerRef.injector, s = [{ provide: this._dialogContainerType, useValue: r }, { provide: this._dialogDataToken, useValue: e.data }, { provide: this._dialogRefConstructor, useValue: i }]; return e.direction && (!o || !o.get(jo, null, Ie.Optional)) && s.push({ provide: jo, useValue: { value: e.direction, change: ge() } }), qt.create({ parent: o || this._injector, providers: s }) } _removeOpenDialog(e) { const i = this.openDialogs.indexOf(e); i > -1 && (this.openDialogs.splice(i, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((r, o) => { r ? o.setAttribute("aria-hidden", r) : o.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._getAfterAllClosed().next())) } _hideNonDialogContentFromAssistiveTechnology() { const e = this._overlayContainer.getContainerElement(); if (e.parentElement) { const i = e.parentElement.children; for (let r = i.length - 1; r > -1; r--) { let o = i[r]; o !== e && "SCRIPT" !== o.nodeName && "STYLE" !== o.nodeName && !o.hasAttribute("aria-live") && (this._ariaHiddenElements.set(o, o.getAttribute("aria-hidden")), o.setAttribute("aria-hidden", "true")) } } } _closeDialogs(e) { let i = e.length; for (; i--;)e[i].close() } } return n.\u0275fac = function (e) { Ia() }, n.\u0275dir = z({ type: n }), n })(), p8 = (() => { class n extends f8 { constructor(e, i, r, o, s, a, l, d) { super(e, i, o, a, l, s, l8, s8, c8, d) } } return n.\u0275fac = function (e) { return new (e || n)(L(Pr), L(qt), L(_c, 8), L(d8, 8), L(fk), L(n, 12), L(_v), L(nr, 8)) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac }), n })(), g8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [p8, h8], imports: [[mo, uo, oe], oe] }), n })(), pk = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe], oe] }), n })(), _8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), v8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe, _8, uo]] }), n })(), C8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[lf, oe], lf, oe] }), n })(), F8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[lf, rr, oe, pv, un], lf, oe, pv, pk] }), n })(); const V8 = { provide: new V("mat-menu-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let H8 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [V8], imports: [[un, oe, rr, mo], Ir, oe] }), n })(); const G8 = { provide: new V("mat-select-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition() } }; let bk = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [G8], imports: [[un, mo, cf, oe], Ir, Lv, cf, oe] }), n })(); const Q8 = { provide: new V("mat-tooltip-scroll-strategy"), deps: [Pr], useFactory: function (n) { return () => n.scrollStrategies.reposition({ scrollThrottle: 20 }) } }; let Ck = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [Q8], imports: [[jc, un, mo, oe], oe, Ir] }), n })(), $v = (() => { class n { constructor() { this.changes = new se, this.itemsPerPageLabel = "Items per page:", this.nextPageLabel = "Next page", this.previousPageLabel = "Previous page", this.firstPageLabel = "First page", this.lastPageLabel = "Last page", this.getRangeLabel = (e, i, r) => { if (0 == r || 0 == i) return `0 of ${r}`; const o = e * i; return `${o + 1} \u2013 ${o < (r = Math.max(r, 0)) ? Math.min(o + i, r) : o + i} of ${r}` } } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const t4 = { provide: $v, deps: [[new an, new pi, $v]], useFactory: function (n) { return n || new $v } }; let n4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [t4], imports: [[un, rd, bk, Ck, oe]] }), n })(), o4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe], oe] }), n })(); function s4(n, t) { if (1 & n && (Pl(), vt(0, "circle", 3)), 2 & n) { const e = Po(); Dr("animation-name", "mat-progress-spinner-stroke-rotate-" + e._spinnerAnimationLabel)("stroke-dashoffset", e._getStrokeDashOffset(), "px")("stroke-dasharray", e._getStrokeCircumference(), "px")("stroke-width", e._getCircleStrokeWidth(), "%"), nt("r", e._getCircleRadius()) } } function a4(n, t) { if (1 & n && (Pl(), vt(0, "circle", 3)), 2 & n) { const e = Po(); Dr("stroke-dashoffset", e._getStrokeDashOffset(), "px")("stroke-dasharray", e._getStrokeCircumference(), "px")("stroke-width", e._getCircleStrokeWidth(), "%"), nt("r", e._getCircleRadius()) } } const c4 = Xc(class { constructor(n) { this._elementRef = n } }, "primary"), d4 = new V("mat-progress-spinner-default-options", { providedIn: "root", factory: function () { return { diameter: 100 } } }); class qo extends c4 { constructor(t, e, i, r, o) { super(t), this._document = i, this._diameter = 100, this._value = 0, this.mode = "determinate"; const s = qo._diameters; this._spinnerAnimationLabel = this._getSpinnerAnimationLabel(), s.has(i.head) || s.set(i.head, new Set([100])), this._noopAnimations = "NoopAnimations" === r && !!o && !o._forceAnimations, o && (o.diameter && (this.diameter = o.diameter), o.strokeWidth && (this.strokeWidth = o.strokeWidth)) } get diameter() { return this._diameter } set diameter(t) { this._diameter = si(t), this._spinnerAnimationLabel = this._getSpinnerAnimationLabel(), this._styleRoot && this._attachStyleNode() } get strokeWidth() { return this._strokeWidth || this.diameter / 10 } set strokeWidth(t) { this._strokeWidth = si(t) } get value() { return "determinate" === this.mode ? this._value : 0 } set value(t) { this._value = Math.max(0, Math.min(100, si(t))) } ngOnInit() { const t = this._elementRef.nativeElement; this._styleRoot = Lh(t) || this._document.head, this._attachStyleNode(), t.classList.add("mat-progress-spinner-indeterminate-animation") } _getCircleRadius() { return (this.diameter - 10) / 2 } _getViewBox() { const t = 2 * this._getCircleRadius() + this.strokeWidth; return `0 0 ${t} ${t}` } _getStrokeCircumference() { return 2 * Math.PI * this._getCircleRadius() } _getStrokeDashOffset() { return "determinate" === this.mode ? this._getStrokeCircumference() * (100 - this._value) / 100 : null } _getCircleStrokeWidth() { return this.strokeWidth / this.diameter * 100 } _attachStyleNode() { const t = this._styleRoot, e = this._diameter, i = qo._diameters; let r = i.get(t); if (!r || !r.has(e)) { const o = this._document.createElement("style"); o.setAttribute("mat-spinner-animation", this._spinnerAnimationLabel), o.textContent = this._getAnimationText(), t.appendChild(o), r || (r = new Set, i.set(t, r)), r.add(e) } } _getAnimationText() { const t = this._getStrokeCircumference(); return "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g, "" + .95 * t).replace(/END_VALUE/g, "" + .2 * t).replace(/DIAMETER/g, `${this._spinnerAnimationLabel}`) } _getSpinnerAnimationLabel() { return this.diameter.toString().replace(".", "_") } } qo._diameters = new WeakMap, qo.\u0275fac = function (t) { return new (t || qo)(w(ke), w(ai), w(Be, 8), w(nr, 8), w(d4)) }, qo.\u0275cmp = ue({ type: qo, selectors: [["mat-progress-spinner"]], hostAttrs: ["role", "progressbar", "tabindex", "-1", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function (t, e) { 2 & t && (nt("aria-valuemin", "determinate" === e.mode ? 0 : null)("aria-valuemax", "determinate" === e.mode ? 100 : null)("aria-valuenow", "determinate" === e.mode ? e.value : null)("mode", e.mode), Dr("width", e.diameter, "px")("height", e.diameter, "px"), jt("_mat-animation-noopable", e._noopAnimations)) }, inputs: { color: "color", diameter: "diameter", strokeWidth: "strokeWidth", mode: "mode", value: "value" }, exportAs: ["matProgressSpinner"], features: [Z], decls: 3, vars: 8, consts: [["preserveAspectRatio", "xMidYMid meet", "focusable", "false", "aria-hidden", "true", 3, "ngSwitch"], ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"], ["cx", "50%", "cy", "50%"]], template: function (t, e) { 1 & t && (Pl(), pe(0, "svg", 0), Zr(1, s4, 1, 9, "circle", 1), Zr(2, a4, 1, 7, "circle", 2), me()), 2 & t && (Dr("width", e.diameter, "px")("height", e.diameter, "px"), Wt("ngSwitch", "indeterminate" === e.mode), nt("viewBox", e._getViewBox()), St(1), Wt("ngSwitchCase", !0), St(1), Wt("ngSwitchCase", !1)) }, directives: [Wu, Ww], styles: [".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\n"], encapsulation: 2, changeDetection: 0 }); let f4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe, un], oe] }), n })(), E4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[rr, oe], oe] }), n })(), T4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe, Xa, Ir], Ir, oe] }), n })(), V4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe], oe] }), n })(), Ek = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({}), n })(), J4 = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[Ek, rr, oe, Hc], Ek, oe] }), n })(), nG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[mo, uo, un, rd, oe], oe] }), n })(), Wv = (() => { class n { constructor() { this.changes = new se } } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275prov = X({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const oG = { provide: Wv, deps: [[new an, new pi, Wv]], useFactory: function (n) { return n || new Wv } }; let sG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ providers: [oG], imports: [[un, oe]] }), n })(), wG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[yS, oe], oe] }), n })(), kG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[un, oe, uo, rr, Hc, jc], oe] }), n })(), AG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[oe], oe] }), n })(), BG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [[bS, oe], oe] }), n })(), VG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n }), n.\u0275inj = re({ imports: [jc, Az, uS, yS, bS, hU, E5, S5, T5, rd, F5, N5, Y5, a$, F$, t8, g8, pk, v8, C8, sk, L$, F8, H8, zU, n4, o4, f4, E4, rr, bk, T4, V4, J4, nG, sG, wG, kG, AG, Ck, BG, mo, uo, jh] }), n })(), HG = (() => { class n { } return n.\u0275fac = function (e) { return new (e || n) }, n.\u0275mod = J({ type: n, bootstrap: [gH] }), n.\u0275inj = re({ providers: [], imports: [[cx, pH, Uj, VG]] }), n })(); vw = !1, NB().bootstrapModule(HG).catch(n => console.error(n)) }, 259: function (Qo, cd) { var Qe; !function (Ee, Nr) { "use strict"; "object" == typeof Qo.exports ? Qo.exports = Ee.document ? Nr(Ee, !0) : function (Dn) { if (!Dn.document) throw new Error("jQuery requires a window with a document"); return Nr(Dn) } : Nr(Ee) }("undefined" != typeof window ? window : this, function (Ee, Nr) { "use strict"; var Dn = [], ut = Object.getPrototypeOf, zi = Dn.slice, pl = Dn.flat ? function (c) { return Dn.flat.call(c) } : function (c) { return Dn.concat.apply([], c) }, As = Dn.push, Ei = Dn.indexOf, Lr = {}, ml = Lr.toString, Ui = Lr.hasOwnProperty, dd = Ui.toString, kf = dd.call(Object), dt = {}, Pe = function (u) { return "function" == typeof u && "number" != typeof u.nodeType && "function" != typeof u.item }, Jn = function (u) { return null != u && u === u.window }, Ge = Ee.document, Af = { type: !0, src: !0, nonce: !0, noModule: !0 }; function Is(c, u, f) { var p, _, v = (f = f || Ge).createElement("script"); if (v.text = c, u) for (p in Af) (_ = u[p] || u.getAttribute && u.getAttribute(p)) && v.setAttribute(p, _); f.head.appendChild(v).parentNode.removeChild(v) } function sr(c) { return null == c ? c + "" : "object" == typeof c || "function" == typeof c ? Lr[ml.call(c)] || "object" : typeof c } var g = function (c, u) { return new g.fn.init(c, u) }; function Ko(c) { var u = !!c && "length" in c && c.length, f = sr(c); return !Pe(c) && !Jn(c) && ("array" === f || 0 === u || "number" == typeof u && u > 0 && u - 1 in c) } g.fn = g.prototype = { jquery: "3.6.0", constructor: g, length: 0, toArray: function () { return zi.call(this) }, get: function (c) { return null == c ? zi.call(this) : c < 0 ? this[c + this.length] : this[c] }, pushStack: function (c) { var u = g.merge(this.constructor(), c); return u.prevObject = this, u }, each: function (c) { return g.each(this, c) }, map: function (c) { return this.pushStack(g.map(this, function (u, f) { return c.call(u, f, u) })) }, slice: function () { return this.pushStack(zi.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(g.grep(this, function (c, u) { return (u + 1) % 2 })) }, odd: function () { return this.pushStack(g.grep(this, function (c, u) { return u % 2 })) }, eq: function (c) { var u = this.length, f = +c + (c < 0 ? u : 0); return this.pushStack(f >= 0 && f < u ? [this[f]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: As, sort: Dn.sort, splice: Dn.splice }, g.extend = g.fn.extend = function () { var c, u, f, p, _, v, b = arguments[0] || {}, S = 1, x = arguments.length, R = !1; for ("boolean" == typeof b && (R = b, b = arguments[S] || {}, S++), "object" != typeof b && !Pe(b) && (b = {}), S === x && (b = this, S--); S < x; S++)if (null != (c = arguments[S])) for (u in c) p = c[u], "__proto__" !== u && b !== p && (R && p && (g.isPlainObject(p) || (_ = Array.isArray(p))) ? (f = b[u], v = _ && !Array.isArray(f) ? [] : _ || g.isPlainObject(f) ? f : {}, _ = !1, b[u] = g.extend(R, v, p)) : void 0 !== p && (b[u] = p)); return b }, g.extend({ expando: "jQuery" + ("3.6.0" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (c) { throw new Error(c) }, noop: function () { }, isPlainObject: function (c) { var u, f; return !(!c || "[object Object]" !== ml.call(c) || (u = ut(c)) && ("function" != typeof (f = Ui.call(u, "constructor") && u.constructor) || dd.call(f) !== kf)) }, isEmptyObject: function (c) { var u; for (u in c) return !1; return !0 }, globalEval: function (c, u, f) { Is(c, { nonce: u && u.nonce }, f) }, each: function (c, u) { var f, p = 0; if (Ko(c)) for (f = c.length; p < f && !1 !== u.call(c[p], p, c[p]); p++); else for (p in c) if (!1 === u.call(c[p], p, c[p])) break; return c }, makeArray: function (c, u) { var f = u || []; return null != c && (Ko(Object(c)) ? g.merge(f, "string" == typeof c ? [c] : c) : As.call(f, c)), f }, inArray: function (c, u, f) { return null == u ? -1 : Ei.call(u, c, f) }, merge: function (c, u) { for (var f = +u.length, p = 0, _ = c.length; p < f; p++)c[_++] = u[p]; return c.length = _, c }, grep: function (c, u, f) { for (var _ = [], v = 0, b = c.length, S = !f; v < b; v++)!u(c[v], v) !== S && _.push(c[v]); return _ }, map: function (c, u, f) { var p, _, v = 0, b = []; if (Ko(c)) for (p = c.length; v < p; v++)null != (_ = u(c[v], v, f)) && b.push(_); else for (v in c) null != (_ = u(c[v], v, f)) && b.push(_); return pl(b) }, guid: 1, support: dt }), "function" == typeof Symbol && (g.fn[Symbol.iterator] = Dn[Symbol.iterator]), g.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (c, u) { Lr["[object " + u + "]"] = u.toLowerCase() }); var Br = function (c) { var u, f, p, _, v, b, S, x, R, N, $, I, B, ce, Me, de, gt, xt, jn, ue = "sizzle" + 1 * new Date, Se = c.document, Mn = 0, tt = 0, Mt = Ks(), J = Ks(), Ys = Ks(), Pn = Ks(), z = function (C, E) { return C === E && ($ = !0), 0 }, Nt = {}.hasOwnProperty, ft = [], En = ft.pop, Qt = ft.push, Gt = ft.push, ns = ft.slice, Wi = function (C, E) { for (var T = 0, j = C.length; T < j; T++)if (C[T] === E) return T; return -1 }, $r = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", ot = "[\\x20\\t\\r\\n\\f]", zn = "(?:\\\\[\\da-fA-F]{1,6}" + ot + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", rn = "\\[" + ot + "*(" + zn + ")(?:" + ot + "*([*^$|!~]?=)" + ot + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + zn + "))|)" + ot + "*\\]", Al = ":(" + zn + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + rn + ")*)|.*)\\)|)", ti = new RegExp(ot + "+", "g"), Q = new RegExp("^" + ot + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ot + "+$", "g"), Ye = new RegExp("^" + ot + "*," + ot + "*"), Ct = new RegExp("^" + ot + "*([>+~]|" + ot + ")" + ot + "*"), Un = new RegExp(ot + "|>"), Gr = new RegExp(Al), Kt = new RegExp("^" + zn + "$"), ki = { ID: new RegExp("^#(" + zn + ")"), CLASS: new RegExp("^\\.(" + zn + ")"), TAG: new RegExp("^(" + zn + "|[*])"), ATTR: new RegExp("^" + rn), PSEUDO: new RegExp("^" + Al), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ot + "*(even|odd|(([+-]|)(\\d*)n|)" + ot + "*(?:([+-]|)" + ot + "*(\\d+)|))" + ot + "*\\)|)", "i"), bool: new RegExp("^(?:" + $r + ")$", "i"), needsContext: new RegExp("^" + ot + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ot + "*((?:-\\d)?\\d*)" + ot + "*\\)|)(?=[^-]|$)", "i") }, kt = /HTML$/i, is = /^(?:input|select|textarea|button)$/i, Mo = /^h\d$/i, Te = /^[^{]+\{\s*\[native \w/, Qs = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, fr = /[+~]/, ci = new RegExp("\\\\[\\da-fA-F]{1,6}" + ot + "?|\\\\([^\\r\\n\\f])", "g"), Fn = function (C, E) { var T = "0x" + C.slice(1) - 65536; return E || (T < 0 ? String.fromCharCode(T + 65536) : String.fromCharCode(T >> 10 | 55296, 1023 & T | 56320)) }, Sn = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, Eo = function (C, E) { return E ? "\0" === C ? "\ufffd" : C.slice(0, -1) + "\\" + C.charCodeAt(C.length - 1).toString(16) + " " : "\\" + C }, qr = function () { I() }, di = Il(function (C) { return !0 === C.disabled && "fieldset" === C.nodeName.toLowerCase() }, { dir: "parentNode", next: "legend" }); try { Gt.apply(ft = ns.call(Se.childNodes), Se.childNodes) } catch (C) { Gt = { apply: ft.length ? function (E, T) { Qt.apply(E, ns.call(T)) } : function (E, T) { for (var j = E.length, O = 0; E[j++] = T[O++];); E.length = j - 1 } } } function he(C, E, T, j) { var O, U, G, Y, K, ye, fe, be = E && E.ownerDocument, Re = E ? E.nodeType : 9; if (T = T || [], "string" != typeof C || !C || 1 !== Re && 9 !== Re && 11 !== Re) return T; if (!j && (I(E), E = E || B, Me)) { if (11 !== Re && (K = Qs.exec(C))) if (O = K[1]) { if (9 === Re) { if (!(G = E.getElementById(O))) return T; if (G.id === O) return T.push(G), T } else if (be && (G = be.getElementById(O)) && jn(E, G) && G.id === O) return T.push(G), T } else { if (K[2]) return Gt.apply(T, E.getElementsByTagName(C)), T; if ((O = K[3]) && f.getElementsByClassName && E.getElementsByClassName) return Gt.apply(T, E.getElementsByClassName(O)), T } if (f.qsa && !Pn[C + " "] && (!de || !de.test(C)) && (1 !== Re || "object" !== E.nodeName.toLowerCase())) { if (fe = C, be = E, 1 === Re && (Un.test(C) || Ct.test(C))) { for (((be = fr.test(C) && Od(E.parentNode) || E) !== E || !f.scope) && ((Y = E.getAttribute("id")) ? Y = Y.replace(Sn, Eo) : E.setAttribute("id", Y = ue)), U = (ye = b(C)).length; U--;)ye[U] = (Y ? "#" + Y : ":scope") + " " + ea(ye[U]); fe = ye.join(",") } try { return Gt.apply(T, be.querySelectorAll(fe)), T } catch (_t) { Pn(C, !0) } finally { Y === ue && E.removeAttribute("id") } } } return x(C.replace(Q, "$1"), E, T, j) } function Ks() { var C = []; return function E(T, j) { return C.push(T + " ") > p.cacheLength && delete E[C.shift()], E[T + " "] = j } } function ui(C) { return C[ue] = !0, C } function Lt(C) { var E = B.createElement("fieldset"); try { return !!C(E) } catch (T) { return !1 } finally { E.parentNode && E.parentNode.removeChild(E), E = null } } function $n(C, E) { for (var T = C.split("|"), j = T.length; j--;)p.attrHandle[T[j]] = E } function Xs(C, E) { var T = E && C, j = T && 1 === C.nodeType && 1 === E.nodeType && C.sourceIndex - E.sourceIndex; if (j) return j; if (T) for (; T = T.nextSibling;)if (T === E) return -1; return C ? 1 : -1 } function Zs(C) { return function (E) { return "input" === E.nodeName.toLowerCase() && E.type === C } } function Js(C) { return function (E) { var T = E.nodeName.toLowerCase(); return ("input" === T || "button" === T) && E.type === C } } function ni(C) { return function (E) { return "form" in E ? E.parentNode && !1 === E.disabled ? "label" in E ? "label" in E.parentNode ? E.parentNode.disabled === C : E.disabled === C : E.isDisabled === C || E.isDisabled !== !C && di(E) === C : E.disabled === C : "label" in E && E.disabled === C } } function Wr(C) { return ui(function (E) { return E = +E, ui(function (T, j) { for (var O, U = C([], T.length, E), G = U.length; G--;)T[O = U[G]] && (T[O] = !(j[O] = T[O])) }) }) } function Od(C) { return C && void 0 !== C.getElementsByTagName && C } for (u in f = he.support = {}, v = he.isXML = function (C) { var T = C && (C.ownerDocument || C).documentElement; return !kt.test(C && C.namespaceURI || T && T.nodeName || "HTML") }, I = he.setDocument = function (C) { var E, T, j = C ? C.ownerDocument || C : Se; return j == B || 9 !== j.nodeType || !j.documentElement || (ce = (B = j).documentElement, Me = !v(B), Se != B && (T = B.defaultView) && T.top !== T && (T.addEventListener ? T.addEventListener("unload", qr, !1) : T.attachEvent && T.attachEvent("onunload", qr)), f.scope = Lt(function (O) { return ce.appendChild(O).appendChild(B.createElement("div")), void 0 !== O.querySelectorAll && !O.querySelectorAll(":scope fieldset div").length }), f.attributes = Lt(function (O) { return O.className = "i", !O.getAttribute("className") }), f.getElementsByTagName = Lt(function (O) { return O.appendChild(B.createComment("")), !O.getElementsByTagName("*").length }), f.getElementsByClassName = Te.test(B.getElementsByClassName), f.getById = Lt(function (O) { return ce.appendChild(O).id = ue, !B.getElementsByName || !B.getElementsByName(ue).length }), f.getById ? (p.filter.ID = function (O) { var U = O.replace(ci, Fn); return function (G) { return G.getAttribute("id") === U } }, p.find.ID = function (O, U) { if (void 0 !== U.getElementById && Me) { var G = U.getElementById(O); return G ? [G] : [] } }) : (p.filter.ID = function (O) { var U = O.replace(ci, Fn); return function (G) { var Y = void 0 !== G.getAttributeNode && G.getAttributeNode("id"); return Y && Y.value === U } }, p.find.ID = function (O, U) { if (void 0 !== U.getElementById && Me) { var G, Y, K, ye = U.getElementById(O); if (ye) { if ((G = ye.getAttributeNode("id")) && G.value === O) return [ye]; for (K = U.getElementsByName(O), Y = 0; ye = K[Y++];)if ((G = ye.getAttributeNode("id")) && G.value === O) return [ye] } return [] } }), p.find.TAG = f.getElementsByTagName ? function (O, U) { return void 0 !== U.getElementsByTagName ? U.getElementsByTagName(O) : f.qsa ? U.querySelectorAll(O) : void 0 } : function (O, U) { var G, Y = [], K = 0, ye = U.getElementsByTagName(O); if ("*" === O) { for (; G = ye[K++];)1 === G.nodeType && Y.push(G); return Y } return ye }, p.find.CLASS = f.getElementsByClassName && function (O, U) { if (void 0 !== U.getElementsByClassName && Me) return U.getElementsByClassName(O) }, gt = [], de = [], (f.qsa = Te.test(B.querySelectorAll)) && (Lt(function (O) { var U; ce.appendChild(O).innerHTML = "<a id='" + ue + "'></a><select id='" + ue + "-\r\\' msallowcapture=''><option selected=''></option></select>", O.querySelectorAll("[msallowcapture^='']").length && de.push("[*^$]=" + ot + "*(?:''|\"\")"), O.querySelectorAll("[selected]").length || de.push("\\[" + ot + "*(?:value|" + $r + ")"), O.querySelectorAll("[id~=" + ue + "-]").length || de.push("~="), (U = B.createElement("input")).setAttribute("name", ""), O.appendChild(U), O.querySelectorAll("[name='']").length || de.push("\\[" + ot + "*name" + ot + "*=" + ot + "*(?:''|\"\")"), O.querySelectorAll(":checked").length || de.push(":checked"), O.querySelectorAll("a#" + ue + "+*").length || de.push(".#.+[+~]"), O.querySelectorAll("\\\f"), de.push("[\\r\\n\\f]") }), Lt(function (O) { O.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var U = B.createElement("input"); U.setAttribute("type", "hidden"), O.appendChild(U).setAttribute("name", "D"), O.querySelectorAll("[name=d]").length && de.push("name" + ot + "*[*^$|!~]?="), 2 !== O.querySelectorAll(":enabled").length && de.push(":enabled", ":disabled"), ce.appendChild(O).disabled = !0, 2 !== O.querySelectorAll(":disabled").length && de.push(":enabled", ":disabled"), O.querySelectorAll("*,:x"), de.push(",.*:") })), (f.matchesSelector = Te.test(xt = ce.matches || ce.webkitMatchesSelector || ce.mozMatchesSelector || ce.oMatchesSelector || ce.msMatchesSelector)) && Lt(function (O) { f.disconnectedMatch = xt.call(O, "*"), xt.call(O, "[s!='']:x"), gt.push("!=", Al) }), de = de.length && new RegExp(de.join("|")), gt = gt.length && new RegExp(gt.join("|")), E = Te.test(ce.compareDocumentPosition), jn = E || Te.test(ce.contains) ? function (O, U) { var G = 9 === O.nodeType ? O.documentElement : O, Y = U && U.parentNode; return O === Y || !(!Y || 1 !== Y.nodeType || !(G.contains ? G.contains(Y) : O.compareDocumentPosition && 16 & O.compareDocumentPosition(Y))) } : function (O, U) { if (U) for (; U = U.parentNode;)if (U === O) return !0; return !1 }, z = E ? function (O, U) { if (O === U) return $ = !0, 0; var G = !O.compareDocumentPosition - !U.compareDocumentPosition; return G || (1 & (G = (O.ownerDocument || O) == (U.ownerDocument || U) ? O.compareDocumentPosition(U) : 1) || !f.sortDetached && U.compareDocumentPosition(O) === G ? O == B || O.ownerDocument == Se && jn(Se, O) ? -1 : U == B || U.ownerDocument == Se && jn(Se, U) ? 1 : N ? Wi(N, O) - Wi(N, U) : 0 : 4 & G ? -1 : 1) } : function (O, U) { if (O === U) return $ = !0, 0; var G, Y = 0, K = O.parentNode, ye = U.parentNode, fe = [O], be = [U]; if (!K || !ye) return O == B ? -1 : U == B ? 1 : K ? -1 : ye ? 1 : N ? Wi(N, O) - Wi(N, U) : 0; if (K === ye) return Xs(O, U); for (G = O; G = G.parentNode;)fe.unshift(G); for (G = U; G = G.parentNode;)be.unshift(G); for (; fe[Y] === be[Y];)Y++; return Y ? Xs(fe[Y], be[Y]) : fe[Y] == Se ? -1 : be[Y] == Se ? 1 : 0 }), B }, he.matches = function (C, E) { return he(C, null, null, E) }, he.matchesSelector = function (C, E) { if (I(C), f.matchesSelector && Me && !Pn[E + " "] && (!gt || !gt.test(E)) && (!de || !de.test(E))) try { var T = xt.call(C, E); if (T || f.disconnectedMatch || C.document && 11 !== C.document.nodeType) return T } catch (j) { Pn(E, !0) } return he(E, B, null, [C]).length > 0 }, he.contains = function (C, E) { return (C.ownerDocument || C) != B && I(C), jn(C, E) }, he.attr = function (C, E) { (C.ownerDocument || C) != B && I(C); var T = p.attrHandle[E.toLowerCase()], j = T && Nt.call(p.attrHandle, E.toLowerCase()) ? T(C, E, !Me) : void 0; return void 0 !== j ? j : f.attributes || !Me ? C.getAttribute(E) : (j = C.getAttributeNode(E)) && j.specified ? j.value : null }, he.escape = function (C) { return (C + "").replace(Sn, Eo) }, he.error = function (C) { throw new Error("Syntax error, unrecognized expression: " + C) }, he.uniqueSort = function (C) { var E, T = [], j = 0, O = 0; if ($ = !f.detectDuplicates, N = !f.sortStable && C.slice(0), C.sort(z), $) { for (; E = C[O++];)E === C[O] && (j = T.push(O)); for (; j--;)C.splice(T[j], 1) } return N = null, C }, _ = he.getText = function (C) { var E, T = "", j = 0, O = C.nodeType; if (O) { if (1 === O || 9 === O || 11 === O) { if ("string" == typeof C.textContent) return C.textContent; for (C = C.firstChild; C; C = C.nextSibling)T += _(C) } else if (3 === O || 4 === O) return C.nodeValue } else for (; E = C[j++];)T += _(E); return T }, (p = he.selectors = { cacheLength: 50, createPseudo: ui, match: ki, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (C) { return C[1] = C[1].replace(ci, Fn), C[3] = (C[3] || C[4] || C[5] || "").replace(ci, Fn), "~=" === C[2] && (C[3] = " " + C[3] + " "), C.slice(0, 4) }, CHILD: function (C) { return C[1] = C[1].toLowerCase(), "nth" === C[1].slice(0, 3) ? (C[3] || he.error(C[0]), C[4] = +(C[4] ? C[5] + (C[6] || 1) : 2 * ("even" === C[3] || "odd" === C[3])), C[5] = +(C[7] + C[8] || "odd" === C[3])) : C[3] && he.error(C[0]), C }, PSEUDO: function (C) { var E, T = !C[6] && C[2]; return ki.CHILD.test(C[0]) ? null : (C[3] ? C[2] = C[4] || C[5] || "" : T && Gr.test(T) && (E = b(T, !0)) && (E = T.indexOf(")", T.length - E) - T.length) && (C[0] = C[0].slice(0, E), C[2] = T.slice(0, E)), C.slice(0, 3)) } }, filter: { TAG: function (C) { var E = C.replace(ci, Fn).toLowerCase(); return "*" === C ? function () { return !0 } : function (T) { return T.nodeName && T.nodeName.toLowerCase() === E } }, CLASS: function (C) { var E = Mt[C + " "]; return E || (E = new RegExp("(^|" + ot + ")" + C + "(" + ot + "|$)")) && Mt(C, function (T) { return E.test("string" == typeof T.className && T.className || void 0 !== T.getAttribute && T.getAttribute("class") || "") }) }, ATTR: function (C, E, T) { return function (j) { var O = he.attr(j, C); return null == O ? "!=" === E : !E || (O += "", "=" === E ? O === T : "!=" === E ? O !== T : "^=" === E ? T && 0 === O.indexOf(T) : "*=" === E ? T && O.indexOf(T) > -1 : "$=" === E ? T && O.slice(-T.length) === T : "~=" === E ? (" " + O.replace(ti, " ") + " ").indexOf(T) > -1 : "|=" === E && (O === T || O.slice(0, T.length + 1) === T + "-")) } }, CHILD: function (C, E, T, j, O) { var U = "nth" !== C.slice(0, 3), G = "last" !== C.slice(-4), Y = "of-type" === E; return 1 === j && 0 === O ? function (K) { return !!K.parentNode } : function (K, ye, fe) { var be, Re, _t, ee, Bt, gn, Gn = U !== G ? "nextSibling" : "previousSibling", Dt = K.parentNode, So = Y && K.nodeName.toLowerCase(), rs = !fe && !Y, Tn = !1; if (Dt) { if (U) { for (; Gn;) { for (ee = K; ee = ee[Gn];)if (Y ? ee.nodeName.toLowerCase() === So : 1 === ee.nodeType) return !1; gn = Gn = "only" === C && !gn && "nextSibling" } return !0 } if (gn = [G ? Dt.firstChild : Dt.lastChild], G && rs) { for (Tn = (Bt = (be = (Re = (_t = (ee = Dt)[ue] || (ee[ue] = {}))[ee.uniqueID] || (_t[ee.uniqueID] = {}))[C] || [])[0] === Mn && be[1]) && be[2], ee = Bt && Dt.childNodes[Bt]; ee = ++Bt && ee && ee[Gn] || (Tn = Bt = 0) || gn.pop();)if (1 === ee.nodeType && ++Tn && ee === K) { Re[C] = [Mn, Bt, Tn]; break } } else if (rs && (Tn = Bt = (be = (Re = (_t = (ee = K)[ue] || (ee[ue] = {}))[ee.uniqueID] || (_t[ee.uniqueID] = {}))[C] || [])[0] === Mn && be[1]), !1 === Tn) for (; (ee = ++Bt && ee && ee[Gn] || (Tn = Bt = 0) || gn.pop()) && ((Y ? ee.nodeName.toLowerCase() !== So : 1 !== ee.nodeType) || !++Tn || (rs && ((Re = (_t = ee[ue] || (ee[ue] = {}))[ee.uniqueID] || (_t[ee.uniqueID] = {}))[C] = [Mn, Tn]), ee !== K));); return (Tn -= O) === j || Tn % j == 0 && Tn / j >= 0 } } }, PSEUDO: function (C, E) { var T, j = p.pseudos[C] || p.setFilters[C.toLowerCase()] || he.error("unsupported pseudo: " + C); return j[ue] ? j(E) : j.length > 1 ? (T = [C, C, "", E], p.setFilters.hasOwnProperty(C.toLowerCase()) ? ui(function (O, U) { for (var G, Y = j(O, E), K = Y.length; K--;)O[G = Wi(O, Y[K])] = !(U[G] = Y[K]) }) : function (O) { return j(O, 0, T) }) : j } }, pseudos: { not: ui(function (C) { var E = [], T = [], j = S(C.replace(Q, "$1")); return j[ue] ? ui(function (O, U, G, Y) { for (var K, ye = j(O, null, Y, []), fe = O.length; fe--;)(K = ye[fe]) && (O[fe] = !(U[fe] = K)) }) : function (O, U, G) { return E[0] = O, j(E, null, G, T), E[0] = null, !T.pop() } }), has: ui(function (C) { return function (E) { return he(C, E).length > 0 } }), contains: ui(function (C) { return C = C.replace(ci, Fn), function (E) { return (E.textContent || _(E)).indexOf(C) > -1 } }), lang: ui(function (C) { return Kt.test(C || "") || he.error("unsupported lang: " + C), C = C.replace(ci, Fn).toLowerCase(), function (E) { var T; do { if (T = Me ? E.lang : E.getAttribute("xml:lang") || E.getAttribute("lang")) return (T = T.toLowerCase()) === C || 0 === T.indexOf(C + "-") } while ((E = E.parentNode) && 1 === E.nodeType); return !1 } }), target: function (C) { var E = c.location && c.location.hash; return E && E.slice(1) === C.id }, root: function (C) { return C === ce }, focus: function (C) { return C === B.activeElement && (!B.hasFocus || B.hasFocus()) && !!(C.type || C.href || ~C.tabIndex) }, enabled: ni(!1), disabled: ni(!0), checked: function (C) { var E = C.nodeName.toLowerCase(); return "input" === E && !!C.checked || "option" === E && !!C.selected }, selected: function (C) { return !0 === C.selected }, empty: function (C) { for (C = C.firstChild; C; C = C.nextSibling)if (C.nodeType < 6) return !1; return !0 }, parent: function (C) { return !p.pseudos.empty(C) }, header: function (C) { return Mo.test(C.nodeName) }, input: function (C) { return is.test(C.nodeName) }, button: function (C) { var E = C.nodeName.toLowerCase(); return "input" === E && "button" === C.type || "button" === E }, text: function (C) { var E; return "input" === C.nodeName.toLowerCase() && "text" === C.type && (null == (E = C.getAttribute("type")) || "text" === E.toLowerCase()) }, first: Wr(function () { return [0] }), last: Wr(function (C, E) { return [E - 1] }), eq: Wr(function (C, E, T) { return [T < 0 ? T + E : T] }), even: Wr(function (C, E) { for (var T = 0; T < E; T += 2)C.push(T); return C }), odd: Wr(function (C, E) { for (var T = 1; T < E; T += 2)C.push(T); return C }), lt: Wr(function (C, E, T) { for (var j = T < 0 ? T + E : T > E ? E : T; --j >= 0;)C.push(j); return C }), gt: Wr(function (C, E, T) { for (var j = T < 0 ? T + E : T; ++j < E;)C.push(j); return C }) } }).pseudos.nth = p.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) p.pseudos[u] = Zs(u); for (u in { submit: !0, reset: !0 }) p.pseudos[u] = Js(u); function Pd() { } function ea(C) { for (var E = 0, T = C.length, j = ""; E < T; E++)j += C[E].value; return j } function Il(C, E, T) { var j = E.dir, O = E.next, U = O || j, G = T && "parentNode" === U, Y = tt++; return E.first ? function (K, ye, fe) { for (; K = K[j];)if (1 === K.nodeType || G) return C(K, ye, fe); return !1 } : function (K, ye, fe) { var be, Re, _t, ee = [Mn, Y]; if (fe) { for (; K = K[j];)if ((1 === K.nodeType || G) && C(K, ye, fe)) return !0 } else for (; K = K[j];)if (1 === K.nodeType || G) if (Re = (_t = K[ue] || (K[ue] = {}))[K.uniqueID] || (_t[K.uniqueID] = {}), O && O === K.nodeName.toLowerCase()) K = K[j] || K; else { if ((be = Re[U]) && be[0] === Mn && be[1] === Y) return ee[2] = be[2]; if (Re[U] = ee, ee[2] = C(K, ye, fe)) return !0 } return !1 } } function Fd(C) { return C.length > 1 ? function (E, T, j) { for (var O = C.length; O--;)if (!C[O](E, T, j)) return !1; return !0 } : C[0] } function Rl(C, E, T, j, O) { for (var U, G = [], Y = 0, K = C.length, ye = null != E; Y < K; Y++)(U = C[Y]) && (!T || T(U, j, O)) && (G.push(U), ye && E.push(Y)); return G } function Nd(C, E, T, j, O, U) { return j && !j[ue] && (j = Nd(j)), O && !O[ue] && (O = Nd(O, U)), ui(function (G, Y, K, ye) { var fe, be, Re, _t = [], ee = [], Bt = Y.length, gn = G || function (C, E, T) { for (var j = 0, O = E.length; j < O; j++)he(C, E[j], T); return T }(E || "*", K.nodeType ? [K] : K, []), Gn = !C || !G && E ? gn : Rl(gn, _t, C, K, ye), Dt = T ? O || (G ? C : Bt || j) ? [] : Y : Gn; if (T && T(Gn, Dt, K, ye), j) for (fe = Rl(Dt, ee), j(fe, [], K, ye), be = fe.length; be--;)(Re = fe[be]) && (Dt[ee[be]] = !(Gn[ee[be]] = Re)); if (G) { if (O || C) { if (O) { for (fe = [], be = Dt.length; be--;)(Re = Dt[be]) && fe.push(Gn[be] = Re); O(null, Dt = [], fe, ye) } for (be = Dt.length; be--;)(Re = Dt[be]) && (fe = O ? Wi(G, Re) : _t[be]) > -1 && (G[fe] = !(Y[fe] = Re)) } } else Dt = Rl(Dt === Y ? Dt.splice(Bt, Dt.length) : Dt), O ? O(null, Y, Dt, ye) : Gt.apply(Y, Dt) }) } function Ld(C) { for (var E, T, j, O = C.length, U = p.relative[C[0].type], G = U || p.relative[" "], Y = U ? 1 : 0, K = Il(function (be) { return be === E }, G, !0), ye = Il(function (be) { return Wi(E, be) > -1 }, G, !0), fe = [function (be, Re, _t) { var ee = !U && (_t || Re !== R) || ((E = Re).nodeType ? K(be, Re, _t) : ye(be, Re, _t)); return E = null, ee }]; Y < O; Y++)if (T = p.relative[C[Y].type]) fe = [Il(Fd(fe), T)]; else { if ((T = p.filter[C[Y].type].apply(null, C[Y].matches))[ue]) { for (j = ++Y; j < O && !p.relative[C[j].type]; j++); return Nd(Y > 1 && Fd(fe), Y > 1 && ea(C.slice(0, Y - 1).concat({ value: " " === C[Y - 2].type ? "*" : "" })).replace(Q, "$1"), T, Y < j && Ld(C.slice(Y, j)), j < O && Ld(C = C.slice(j)), j < O && ea(C)) } fe.push(T) } return Fd(fe) } return Pd.prototype = p.filters = p.pseudos, p.setFilters = new Pd, b = he.tokenize = function (C, E) { var T, j, O, U, G, Y, K, ye = J[C + " "]; if (ye) return E ? 0 : ye.slice(0); for (G = C, Y = [], K = p.preFilter; G;) { for (U in (!T || (j = Ye.exec(G))) && (j && (G = G.slice(j[0].length) || G), Y.push(O = [])), T = !1, (j = Ct.exec(G)) && (T = j.shift(), O.push({ value: T, type: j[0].replace(Q, " ") }), G = G.slice(T.length)), p.filter) (j = ki[U].exec(G)) && (!K[U] || (j = K[U](j))) && (T = j.shift(), O.push({ value: T, type: U, matches: j }), G = G.slice(T.length)); if (!T) break } return E ? G.length : G ? he.error(C) : J(C, Y).slice(0) }, S = he.compile = function (C, E) { var T, j = [], O = [], U = Ys[C + " "]; if (!U) { for (E || (E = b(C)), T = E.length; T--;)(U = Ld(E[T]))[ue] ? j.push(U) : O.push(U); U = Ys(C, function (C, E) { var T = E.length > 0, j = C.length > 0, O = function (U, G, Y, K, ye) { var fe, be, Re, _t = 0, ee = "0", Bt = U && [], gn = [], Gn = R, Dt = U || j && p.find.TAG("*", ye), So = Mn += null == Gn ? 1 : Math.random() || .1, rs = Dt.length; for (ye && (R = G == B || G || ye); ee !== rs && null != (fe = Dt[ee]); ee++) { if (j && fe) { for (be = 0, !G && fe.ownerDocument != B && (I(fe), Y = !Me); Re = C[be++];)if (Re(fe, G || B, Y)) { K.push(fe); break } ye && (Mn = So) } T && ((fe = !Re && fe) && _t--, U && Bt.push(fe)) } if (_t += ee, T && ee !== _t) { for (be = 0; Re = E[be++];)Re(Bt, gn, G, Y); if (U) { if (_t > 0) for (; ee--;)Bt[ee] || gn[ee] || (gn[ee] = En.call(K)); gn = Rl(gn) } Gt.apply(K, gn), ye && !U && gn.length > 0 && _t + E.length > 1 && he.uniqueSort(K) } return ye && (Mn = So, R = Gn), Bt }; return T ? ui(O) : O }(O, j)), U.selector = C } return U }, x = he.select = function (C, E, T, j) { var O, U, G, Y, K, ye = "function" == typeof C && C, fe = !j && b(C = ye.selector || C); if (T = T || [], 1 === fe.length) { if ((U = fe[0] = fe[0].slice(0)).length > 2 && "ID" === (G = U[0]).type && 9 === E.nodeType && Me && p.relative[U[1].type]) { if (!(E = (p.find.ID(G.matches[0].replace(ci, Fn), E) || [])[0])) return T; ye && (E = E.parentNode), C = C.slice(U.shift().value.length) } for (O = ki.needsContext.test(C) ? 0 : U.length; O-- && !p.relative[Y = (G = U[O]).type];)if ((K = p.find[Y]) && (j = K(G.matches[0].replace(ci, Fn), fr.test(U[0].type) && Od(E.parentNode) || E))) { if (U.splice(O, 1), !(C = j.length && ea(U))) return Gt.apply(T, j), T; break } } return (ye || S(C, fe))(j, E, !Me, T, !E || fr.test(C) && Od(E.parentNode) || E), T }, f.sortStable = ue.split("").sort(z).join("") === ue, f.detectDuplicates = !!$, I(), f.sortDetached = Lt(function (C) { return 1 & C.compareDocumentPosition(B.createElement("fieldset")) }), Lt(function (C) { return C.innerHTML = "<a href='#'></a>", "#" === C.firstChild.getAttribute("href") }) || $n("type|href|height|width", function (C, E, T) { if (!T) return C.getAttribute(E, "type" === E.toLowerCase() ? 1 : 2) }), (!f.attributes || !Lt(function (C) { return C.innerHTML = "<input/>", C.firstChild.setAttribute("value", ""), "" === C.firstChild.getAttribute("value") })) && $n("value", function (C, E, T) { if (!T && "input" === C.nodeName.toLowerCase()) return C.defaultValue }), Lt(function (C) { return null == C.getAttribute("disabled") }) || $n($r, function (C, E, T) { var j; if (!T) return !0 === C[E] ? E.toLowerCase() : (j = C.getAttributeNode(E)) && j.specified ? j.value : null }), he }(Ee); g.find = Br, g.expr = Br.selectors, g.expr[":"] = g.expr.pseudos, g.uniqueSort = g.unique = Br.uniqueSort, g.text = Br.getText, g.isXMLDoc = Br.isXML, g.contains = Br.contains, g.escapeSelector = Br.escape; var ar = function (c, u, f) { for (var p = [], _ = void 0 !== f; (c = c[u]) && 9 !== c.nodeType;)if (1 === c.nodeType) { if (_ && g(c).is(f)) break; p.push(c) } return p }, $i = function (c, u) { for (var f = []; c; c = c.nextSibling)1 === c.nodeType && c !== u && f.push(c); return f }, If = g.expr.match.needsContext; function Bn(c, u) { return c.nodeName && c.nodeName.toLowerCase() === u.toLowerCase() } var at = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function Os(c, u, f) { return Pe(u) ? g.grep(c, function (p, _) { return !!u.call(p, _, p) !== f }) : u.nodeType ? g.grep(c, function (p) { return p === u !== f }) : "string" != typeof u ? g.grep(c, function (p) { return Ei.call(u, p) > -1 !== f }) : g.filter(u, c, f) } g.filter = function (c, u, f) { var p = u[0]; return f && (c = ":not(" + c + ")"), 1 === u.length && 1 === p.nodeType ? g.find.matchesSelector(p, c) ? [p] : [] : g.find.matches(c, g.grep(u, function (_) { return 1 === _.nodeType })) }, g.fn.extend({ find: function (c) { var u, f, p = this.length, _ = this; if ("string" != typeof c) return this.pushStack(g(c).filter(function () { for (u = 0; u < p; u++)if (g.contains(_[u], this)) return !0 })); for (f = this.pushStack([]), u = 0; u < p; u++)g.find(c, _[u], f); return p > 1 ? g.uniqueSort(f) : f }, filter: function (c) { return this.pushStack(Os(this, c || [], !1)) }, not: function (c) { return this.pushStack(Os(this, c || [], !0)) }, is: function (c) { return !!Os(this, "string" == typeof c && If.test(c) ? g(c) : c || [], !1).length } }); var ud, Rf = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, Of = g.fn.init = function (c, u, f) { var p, _; if (!c) return this; if (f = f || ud, "string" == typeof c) { if (!(p = "<" === c[0] && ">" === c[c.length - 1] && c.length >= 3 ? [null, c, null] : Rf.exec(c)) || !p[1] && u) return !u || u.jquery ? (u || f).find(c) : this.constructor(u).find(c); if (p[1]) { if (g.merge(this, g.parseHTML(p[1], (u = u instanceof g ? u[0] : u) && u.nodeType ? u.ownerDocument || u : Ge, !0)), at.test(p[1]) && g.isPlainObject(u)) for (p in u) Pe(this[p]) ? this[p](u[p]) : this.attr(p, u[p]); return this } return (_ = Ge.getElementById(p[2])) && (this[0] = _, this.length = 1), this } return c.nodeType ? (this[0] = c, this.length = 1, this) : Pe(c) ? void 0 !== f.ready ? f.ready(c) : c(g) : g.makeArray(c, this) }; Of.prototype = g.fn, ud = g(Ge); var se = /^(?:parents|prev(?:Until|All))/, hd = { children: !0, contents: !0, next: !0, prev: !0 }; function gl(c, u) { for (; (c = c[u]) && 1 !== c.nodeType;); return c } g.fn.extend({ has: function (c) { var u = g(c, this), f = u.length; return this.filter(function () { for (var p = 0; p < f; p++)if (g.contains(this, u[p])) return !0 }) }, closest: function (c, u) { var f, p = 0, _ = this.length, v = [], b = "string" != typeof c && g(c); if (!If.test(c)) for (; p < _; p++)for (f = this[p]; f && f !== u; f = f.parentNode)if (f.nodeType < 11 && (b ? b.index(f) > -1 : 1 === f.nodeType && g.find.matchesSelector(f, c))) { v.push(f); break } return this.pushStack(v.length > 1 ? g.uniqueSort(v) : v) }, index: function (c) { return c ? "string" == typeof c ? Ei.call(g(c), this[0]) : Ei.call(this, c.jquery ? c[0] : c) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (c, u) { return this.pushStack(g.uniqueSort(g.merge(this.get(), g(c, u)))) }, addBack: function (c) { return this.add(null == c ? this.prevObject : this.prevObject.filter(c)) } }), g.each({ parent: function (c) { var u = c.parentNode; return u && 11 !== u.nodeType ? u : null }, parents: function (c) { return ar(c, "parentNode") }, parentsUntil: function (c, u, f) { return ar(c, "parentNode", f) }, next: function (c) { return gl(c, "nextSibling") }, prev: function (c) { return gl(c, "previousSibling") }, nextAll: function (c) { return ar(c, "nextSibling") }, prevAll: function (c) { return ar(c, "previousSibling") }, nextUntil: function (c, u, f) { return ar(c, "nextSibling", f) }, prevUntil: function (c, u, f) { return ar(c, "previousSibling", f) }, siblings: function (c) { return $i((c.parentNode || {}).firstChild, c) }, children: function (c) { return $i(c.firstChild) }, contents: function (c) { return null != c.contentDocument && ut(c.contentDocument) ? c.contentDocument : (Bn(c, "template") && (c = c.content || c), g.merge([], c.childNodes)) } }, function (c, u) { g.fn[c] = function (f, p) { var _ = g.map(this, u, f); return "Until" !== c.slice(-5) && (p = f), p && "string" == typeof p && (_ = g.filter(p, _)), this.length > 1 && (hd[c] || g.uniqueSort(_), se.test(c) && _.reverse()), this.pushStack(_) } }); var lt = /[^\x20\t\r\n\f]+/g; function Fe(c) { return c } function vo(c) { throw c } function Pf(c, u, f, p) { var _; try { c && Pe(_ = c.promise) ? _.call(c).done(u).fail(f) : c && Pe(_ = c.then) ? _.call(c, u, f) : u.apply(void 0, [c].slice(p)) } catch (v) { f.apply(void 0, [v]) } } g.Callbacks = function (c) { c = "string" == typeof c ? function (c) { var u = {}; return g.each(c.match(lt) || [], function (f, p) { u[p] = !0 }), u }(c) : g.extend({}, c); var u, f, p, _, v = [], b = [], S = -1, x = function () { for (_ = _ || c.once, p = u = !0; b.length; S = -1)for (f = b.shift(); ++S < v.length;)!1 === v[S].apply(f[0], f[1]) && c.stopOnFalse && (S = v.length, f = !1); c.memory || (f = !1), u = !1, _ && (v = f ? [] : "") }, R = { add: function () { return v && (f && !u && (S = v.length - 1, b.push(f)), function N($) { g.each($, function (I, B) { Pe(B) ? (!c.unique || !R.has(B)) && v.push(B) : B && B.length && "string" !== sr(B) && N(B) }) }(arguments), f && !u && x()), this }, remove: function () { return g.each(arguments, function (N, $) { for (var I; (I = g.inArray($, v, I)) > -1;)v.splice(I, 1), I <= S && S-- }), this }, has: function (N) { return N ? g.inArray(N, v) > -1 : v.length > 0 }, empty: function () { return v && (v = []), this }, disable: function () { return _ = b = [], v = f = "", this }, disabled: function () { return !v }, lock: function () { return _ = b = [], !f && !u && (v = f = ""), this }, locked: function () { return !!_ }, fireWith: function (N, $) { return _ || ($ = [N, ($ = $ || []).slice ? $.slice() : $], b.push($), u || x()), this }, fire: function () { return R.fireWith(this, arguments), this }, fired: function () { return !!p } }; return R }, g.extend({ Deferred: function (c) { var u = [["notify", "progress", g.Callbacks("memory"), g.Callbacks("memory"), 2], ["resolve", "done", g.Callbacks("once memory"), g.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", g.Callbacks("once memory"), g.Callbacks("once memory"), 1, "rejected"]], f = "pending", p = { state: function () { return f }, always: function () { return _.done(arguments).fail(arguments), this }, catch: function (v) { return p.then(null, v) }, pipe: function () { var v = arguments; return g.Deferred(function (b) { g.each(u, function (S, x) { var R = Pe(v[x[4]]) && v[x[4]]; _[x[1]](function () { var N = R && R.apply(this, arguments); N && Pe(N.promise) ? N.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[x[0] + "With"](this, R ? [N] : arguments) }) }), v = null }).promise() }, then: function (v, b, S) { var x = 0; function R(N, $, I, B) { return function () { var ce = this, Me = arguments, de = function () { var xt, jn; if (!(N < x)) { if ((xt = I.apply(ce, Me)) === $.promise()) throw new TypeError("Thenable self-resolution"); Pe(jn = xt && ("object" == typeof xt || "function" == typeof xt) && xt.then) ? B ? jn.call(xt, R(x, $, Fe, B), R(x, $, vo, B)) : (x++, jn.call(xt, R(x, $, Fe, B), R(x, $, vo, B), R(x, $, Fe, $.notifyWith))) : (I !== Fe && (ce = void 0, Me = [xt]), (B || $.resolveWith)(ce, Me)) } }, gt = B ? de : function () { try { de() } catch (xt) { g.Deferred.exceptionHook && g.Deferred.exceptionHook(xt, gt.stackTrace), N + 1 >= x && (I !== vo && (ce = void 0, Me = [xt]), $.rejectWith(ce, Me)) } }; N ? gt() : (g.Deferred.getStackHook && (gt.stackTrace = g.Deferred.getStackHook()), Ee.setTimeout(gt)) } } return g.Deferred(function (N) { u[0][3].add(R(0, N, Pe(S) ? S : Fe, N.notifyWith)), u[1][3].add(R(0, N, Pe(v) ? v : Fe)), u[2][3].add(R(0, N, Pe(b) ? b : vo)) }).promise() }, promise: function (v) { return null != v ? g.extend(v, p) : p } }, _ = {}; return g.each(u, function (v, b) { var S = b[2], x = b[5]; p[b[1]] = S.add, x && S.add(function () { f = x }, u[3 - v][2].disable, u[3 - v][3].disable, u[0][2].lock, u[0][3].lock), S.add(b[3].fire), _[b[0]] = function () { return _[b[0] + "With"](this === _ ? void 0 : this, arguments), this }, _[b[0] + "With"] = S.fireWith }), p.promise(_), c && c.call(_, _), _ }, when: function (c) { var u = arguments.length, f = u, p = Array(f), _ = zi.call(arguments), v = g.Deferred(), b = function (S) { return function (x) { p[S] = this, _[S] = arguments.length > 1 ? zi.call(arguments) : x, --u || v.resolveWith(p, _) } }; if (u <= 1 && (Pf(c, v.done(b(f)).resolve, v.reject, !u), "pending" === v.state() || Pe(_[f] && _[f].then))) return v.then(); for (; f--;)Pf(_[f], b(f), v.reject); return v.promise() } }); var fd = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; g.Deferred.exceptionHook = function (c, u) { Ee.console && Ee.console.warn && c && fd.test(c.name) && Ee.console.warn("jQuery.Deferred exception: " + c.message, c.stack, u) }, g.readyException = function (c) { Ee.setTimeout(function () { throw c }) }; var pd = g.Deferred(); function _l() { Ge.removeEventListener("DOMContentLoaded", _l), Ee.removeEventListener("load", _l), g.ready() } g.fn.ready = function (c) { return pd.then(c).catch(function (u) { g.readyException(u) }), this }, g.extend({ isReady: !1, readyWait: 1, ready: function (c) { (!0 === c ? --g.readyWait : g.isReady) || (g.isReady = !0, !(!0 !== c && --g.readyWait > 0) && pd.resolveWith(Ge, [g])) } }), g.ready.then = pd.then, "complete" === Ge.readyState || "loading" !== Ge.readyState && !Ge.documentElement.doScroll ? Ee.setTimeout(g.ready) : (Ge.addEventListener("DOMContentLoaded", _l), Ee.addEventListener("load", _l)); var lr = function (c, u, f, p, _, v, b) { var S = 0, x = c.length, R = null == f; if ("object" === sr(f)) for (S in _ = !0, f) lr(c, u, S, f[S], !0, v, b); else if (void 0 !== p && (_ = !0, Pe(p) || (b = !0), R && (b ? (u.call(c, p), u = null) : (R = u, u = function (N, $, I) { return R.call(g(N), I) })), u)) for (; S < x; S++)u(c[S], f, b ? p : p.call(c[S], S, u(c[S], f))); return _ ? c : R ? u.call(c) : x ? u(c[0], f) : v }, Kv = /^-ms-/, Ff = /-([a-z])/g; function Xv(c, u) { return u.toUpperCase() } function li(c) { return c.replace(Kv, "ms-").replace(Ff, Xv) } var Ps = function (c) { return 1 === c.nodeType || 9 === c.nodeType || !+c.nodeType }; function yo() { this.expando = g.expando + yo.uid++ } yo.uid = 1, yo.prototype = { cache: function (c) { var u = c[this.expando]; return u || (u = {}, Ps(c) && (c.nodeType ? c[this.expando] = u : Object.defineProperty(c, this.expando, { value: u, configurable: !0 }))), u }, set: function (c, u, f) { var p, _ = this.cache(c); if ("string" == typeof u) _[li(u)] = f; else for (p in u) _[li(p)] = u[p]; return _ }, get: function (c, u) { return void 0 === u ? this.cache(c) : c[this.expando] && c[this.expando][li(u)] }, access: function (c, u, f) { return void 0 === u || u && "string" == typeof u && void 0 === f ? this.get(c, u) : (this.set(c, u, f), void 0 !== f ? f : u) }, remove: function (c, u) { var f, p = c[this.expando]; if (void 0 !== p) { if (void 0 !== u) for ((f = (u = Array.isArray(u) ? u.map(li) : (u = li(u)) in p ? [u] : u.match(lt) || []).length); f--;)delete p[u[f]]; (void 0 === u || g.isEmptyObject(p)) && (c.nodeType ? c[this.expando] = void 0 : delete c[this.expando]) } }, hasData: function (c) { var u = c[this.expando]; return void 0 !== u && !g.isEmptyObject(u) } }; var ve = new yo, Vn = new yo, Zv = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Jv = /[A-Z]/g; function md(c, u, f) { var p; if (void 0 === f && 1 === c.nodeType) if (p = "data-" + u.replace(Jv, "-$&").toLowerCase(), "string" == typeof (f = c.getAttribute(p))) { try { f = function (c) { return "true" === c || "false" !== c && ("null" === c ? null : c === +c + "" ? +c : Zv.test(c) ? JSON.parse(c) : c) }(f) } catch (_) { } Vn.set(c, u, f) } else f = void 0; return f } g.extend({ hasData: function (c) { return Vn.hasData(c) || ve.hasData(c) }, data: function (c, u, f) { return Vn.access(c, u, f) }, removeData: function (c, u) { Vn.remove(c, u) }, _data: function (c, u, f) { return ve.access(c, u, f) }, _removeData: function (c, u) { ve.remove(c, u) } }), g.fn.extend({ data: function (c, u) { var f, p, _, v = this[0], b = v && v.attributes; if (void 0 === c) { if (this.length && (_ = Vn.get(v), 1 === v.nodeType && !ve.get(v, "hasDataAttrs"))) { for (f = b.length; f--;)b[f] && 0 === (p = b[f].name).indexOf("data-") && (p = li(p.slice(5)), md(v, p, _[p])); ve.set(v, "hasDataAttrs", !0) } return _ } return "object" == typeof c ? this.each(function () { Vn.set(this, c) }) : lr(this, function (S) { var x; if (v && void 0 === S) return void 0 !== (x = Vn.get(v, c)) || void 0 !== (x = md(v, c)) ? x : void 0; this.each(function () { Vn.set(this, c, S) }) }, null, u, arguments.length > 1, null, !0) }, removeData: function (c) { return this.each(function () { Vn.remove(this, c) }) } }), g.extend({ queue: function (c, u, f) { var p; if (c) return p = ve.get(c, u = (u || "fx") + "queue"), f && (!p || Array.isArray(f) ? p = ve.access(c, u, g.makeArray(f)) : p.push(f)), p || [] }, dequeue: function (c, u) { var f = g.queue(c, u = u || "fx"), p = f.length, _ = f.shift(), v = g._queueHooks(c, u); "inprogress" === _ && (_ = f.shift(), p--), _ && ("fx" === u && f.unshift("inprogress"), delete v.stop, _.call(c, function () { g.dequeue(c, u) }, v)), !p && v && v.empty.fire() }, _queueHooks: function (c, u) { var f = u + "queueHooks"; return ve.get(c, f) || ve.access(c, f, { empty: g.Callbacks("once memory").add(function () { ve.remove(c, [u + "queue", f]) }) }) } }), g.fn.extend({ queue: function (c, u) { var f = 2; return "string" != typeof c && (u = c, c = "fx", f--), arguments.length < f ? g.queue(this[0], c) : void 0 === u ? this : this.each(function () { var p = g.queue(this, c, u); g._queueHooks(this, c), "fx" === c && "inprogress" !== p[0] && g.dequeue(this, c) }) }, dequeue: function (c) { return this.each(function () { g.dequeue(this, c) }) }, clearQueue: function (c) { return this.queue(c || "fx", []) }, promise: function (c, u) { var f, p = 1, _ = g.Deferred(), v = this, b = this.length, S = function () { --p || _.resolveWith(v, [v]) }; for ("string" != typeof c && (u = c, c = void 0), c = c || "fx"; b--;)(f = ve.get(v[b], c + "queueHooks")) && f.empty && (p++, f.empty.add(S)); return S(), _.promise(u) } }); var Nf = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Xo = new RegExp("^(?:([+-])=|)(" + Nf + ")([a-z%]*)$", "i"), cr = ["Top", "Right", "Bottom", "Left"], Hr = Ge.documentElement, Zo = function (c) { return g.contains(c.ownerDocument, c) }, ey = { composed: !0 }; Hr.getRootNode && (Zo = function (c) { return g.contains(c.ownerDocument, c) || c.getRootNode(ey) === c.ownerDocument }); var vl = function (c, u) { return "none" === (c = u || c).style.display || "" === c.style.display && Zo(c) && "none" === g.css(c, "display") }; function Lf(c, u, f, p) { var _, v, b = 20, S = p ? function () { return p.cur() } : function () { return g.css(c, u, "") }, x = S(), R = f && f[3] || (g.cssNumber[u] ? "" : "px"), N = c.nodeType && (g.cssNumber[u] || "px" !== R && +x) && Xo.exec(g.css(c, u)); if (N && N[3] !== R) { for (R = R || N[3], N = +(x /= 2) || 1; b--;)g.style(c, u, N + R), (1 - v) * (1 - (v = S() / x || .5)) <= 0 && (b = 0), N /= v; g.style(c, u, (N *= 2) + R), f = f || [] } return f && (N = +N || +x || 0, _ = f[1] ? N + (f[1] + 1) * f[2] : +f[2], p && (p.unit = R, p.start = N, p.end = _)), _ } var Fs = {}; function gd(c) { var u, f = c.ownerDocument, p = c.nodeName, _ = Fs[p]; return _ || (u = f.body.appendChild(f.createElement(p)), _ = g.css(u, "display"), u.parentNode.removeChild(u), "none" === _ && (_ = "block"), Fs[p] = _, _) } function jr(c, u) { for (var f, p, _ = [], v = 0, b = c.length; v < b; v++)(p = c[v]).style && (f = p.style.display, u ? ("none" === f && (_[v] = ve.get(p, "display") || null, _[v] || (p.style.display = "")), "" === p.style.display && vl(p) && (_[v] = gd(p))) : "none" !== f && (_[v] = "none", ve.set(p, "display", f))); for (v = 0; v < b; v++)null != _[v] && (c[v].style.display = _[v]); return c } g.fn.extend({ show: function () { return jr(this, !0) }, hide: function () { return jr(this) }, toggle: function (c) { return "boolean" == typeof c ? c ? this.show() : this.hide() : this.each(function () { vl(this) ? g(this).show() : g(this).hide() }) } }); var u, f, bo = /^(?:checkbox|radio)$/i, yl = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, _d = /^$|^module$|\/(?:java|ecma)script/i; u = Ge.createDocumentFragment().appendChild(Ge.createElement("div")), (f = Ge.createElement("input")).setAttribute("type", "radio"), f.setAttribute("checked", "checked"), f.setAttribute("name", "t"), u.appendChild(f), dt.checkClone = u.cloneNode(!0).cloneNode(!0).lastChild.checked, u.innerHTML = "<textarea>x</textarea>", dt.noCloneChecked = !!u.cloneNode(!0).lastChild.defaultValue, u.innerHTML = "<option></option>", dt.option = !!u.lastChild; var Hn = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function wn(c, u) { var f; return f = void 0 !== c.getElementsByTagName ? c.getElementsByTagName(u || "*") : void 0 !== c.querySelectorAll ? c.querySelectorAll(u || "*") : [], void 0 === u || u && Bn(c, u) ? g.merge([c], f) : f } function Ns(c, u) { for (var f = 0, p = c.length; f < p; f++)ve.set(c[f], "globalEval", !u || ve.get(u[f], "globalEval")) } Hn.tbody = Hn.tfoot = Hn.colgroup = Hn.caption = Hn.thead, Hn.th = Hn.td, dt.option || (Hn.optgroup = Hn.option = [1, "<select multiple='multiple'>", "</select>"]); var vd = /<|&#?\w+;/; function On(c, u, f, p, _) { for (var v, b, S, x, R, N, $ = u.createDocumentFragment(), I = [], B = 0, ce = c.length; B < ce; B++)if ((v = c[B]) || 0 === v) if ("object" === sr(v)) g.merge(I, v.nodeType ? [v] : v); else if (vd.test(v)) { for (b = b || $.appendChild(u.createElement("div")), S = (yl.exec(v) || ["", ""])[1].toLowerCase(), b.innerHTML = (x = Hn[S] || Hn._default)[1] + g.htmlPrefilter(v) + x[2], N = x[0]; N--;)b = b.lastChild; g.merge(I, b.childNodes), (b = $.firstChild).textContent = "" } else I.push(u.createTextNode(v)); for ($.textContent = "", B = 0; v = I[B++];)if (p && g.inArray(v, p) > -1) _ && _.push(v); else if (R = Zo(v), b = wn($.appendChild(v), "script"), R && Ns(b), f) for (N = 0; v = b[N++];)_d.test(v.type || "") && f.push(v); return $ } var yd = /^([^.]*)(?:\.(.+)|)/; function Co() { return !0 } function Do() { return !1 } function Bf(c, u) { return c === function () { try { return Ge.activeElement } catch (c) { } }() == ("focus" === u) } function bl(c, u, f, p, _, v) { var b, S; if ("object" == typeof u) { for (S in "string" != typeof f && (p = p || f, f = void 0), u) bl(c, S, f, p, u[S], v); return c } if (null == p && null == _ ? (_ = f, p = f = void 0) : null == _ && ("string" == typeof f ? (_ = p, p = void 0) : (_ = p, p = f, f = void 0)), !1 === _) _ = Do; else if (!_) return c; return 1 === v && (b = _, _ = function (x) { return g().off(x), b.apply(this, arguments) }, _.guid = b.guid || (b.guid = g.guid++)), c.each(function () { g.event.add(this, u, _, p, f) }) } function Ls(c, u, f) { f ? (ve.set(c, u, !1), g.event.add(c, u, { namespace: !1, handler: function (p) { var _, v, b = ve.get(this, u); if (1 & p.isTrigger && this[u]) { if (b.length) (g.event.special[u] || {}).delegateType && p.stopPropagation(); else if (b = zi.call(arguments), ve.set(this, u, b), _ = f(this, u), this[u](), b !== (v = ve.get(this, u)) || _ ? ve.set(this, u, !1) : v = {}, b !== v) return p.stopImmediatePropagation(), p.preventDefault(), v && v.value } else b.length && (ve.set(this, u, { value: g.event.trigger(g.extend(b[0], g.Event.prototype), b.slice(1), this) }), p.stopImmediatePropagation()) } })) : void 0 === ve.get(c, u) && g.event.add(c, u, Co) } g.event = { global: {}, add: function (c, u, f, p, _) { var v, b, S, x, R, N, $, I, B, ce, Me, de = ve.get(c); if (Ps(c)) for (f.handler && (f = (v = f).handler, _ = v.selector), _ && g.find.matchesSelector(Hr, _), f.guid || (f.guid = g.guid++), (x = de.events) || (x = de.events = Object.create(null)), (b = de.handle) || (b = de.handle = function (gt) { return void 0 !== g && g.event.triggered !== gt.type ? g.event.dispatch.apply(c, arguments) : void 0 }), R = (u = (u || "").match(lt) || [""]).length; R--;)B = Me = (S = yd.exec(u[R]) || [])[1], ce = (S[2] || "").split(".").sort(), B && ($ = g.event.special[B] || {}, $ = g.event.special[B = (_ ? $.delegateType : $.bindType) || B] || {}, N = g.extend({ type: B, origType: Me, data: p, handler: f, guid: f.guid, selector: _, needsContext: _ && g.expr.match.needsContext.test(_), namespace: ce.join(".") }, v), (I = x[B]) || ((I = x[B] = []).delegateCount = 0, (!$.setup || !1 === $.setup.call(c, p, ce, b)) && c.addEventListener && c.addEventListener(B, b)), $.add && ($.add.call(c, N), N.handler.guid || (N.handler.guid = f.guid)), _ ? I.splice(I.delegateCount++, 0, N) : I.push(N), g.event.global[B] = !0) }, remove: function (c, u, f, p, _) { var v, b, S, x, R, N, $, I, B, ce, Me, de = ve.hasData(c) && ve.get(c); if (de && (x = de.events)) { for (R = (u = (u || "").match(lt) || [""]).length; R--;)if (B = Me = (S = yd.exec(u[R]) || [])[1], ce = (S[2] || "").split(".").sort(), B) { for ($ = g.event.special[B] || {}, I = x[B = (p ? $.delegateType : $.bindType) || B] || [], S = S[2] && new RegExp("(^|\\.)" + ce.join("\\.(?:.*\\.|)") + "(\\.|$)"), b = v = I.length; v--;)N = I[v], (_ || Me === N.origType) && (!f || f.guid === N.guid) && (!S || S.test(N.namespace)) && (!p || p === N.selector || "**" === p && N.selector) && (I.splice(v, 1), N.selector && I.delegateCount--, $.remove && $.remove.call(c, N)); b && !I.length && ((!$.teardown || !1 === $.teardown.call(c, ce, de.handle)) && g.removeEvent(c, B, de.handle), delete x[B]) } else for (B in x) g.event.remove(c, B + u[R], f, p, !0); g.isEmptyObject(x) && ve.remove(c, "handle events") } }, dispatch: function (c) { var u, f, p, _, v, b, S = new Array(arguments.length), x = g.event.fix(c), R = (ve.get(this, "events") || Object.create(null))[x.type] || [], N = g.event.special[x.type] || {}; for (S[0] = x, u = 1; u < arguments.length; u++)S[u] = arguments[u]; if (x.delegateTarget = this, !N.preDispatch || !1 !== N.preDispatch.call(this, x)) { for (b = g.event.handlers.call(this, x, R), u = 0; (_ = b[u++]) && !x.isPropagationStopped();)for (x.currentTarget = _.elem, f = 0; (v = _.handlers[f++]) && !x.isImmediatePropagationStopped();)(!x.rnamespace || !1 === v.namespace || x.rnamespace.test(v.namespace)) && (x.handleObj = v, x.data = v.data, void 0 !== (p = ((g.event.special[v.origType] || {}).handle || v.handler).apply(_.elem, S)) && !1 === (x.result = p) && (x.preventDefault(), x.stopPropagation())); return N.postDispatch && N.postDispatch.call(this, x), x.result } }, handlers: function (c, u) { var f, p, _, v, b, S = [], x = u.delegateCount, R = c.target; if (x && R.nodeType && !("click" === c.type && c.button >= 1)) for (; R !== this; R = R.parentNode || this)if (1 === R.nodeType && ("click" !== c.type || !0 !== R.disabled)) { for (v = [], b = {}, f = 0; f < x; f++)void 0 === b[_ = (p = u[f]).selector + " "] && (b[_] = p.needsContext ? g(_, this).index(R) > -1 : g.find(_, this, null, [R]).length), b[_] && v.push(p); v.length && S.push({ elem: R, handlers: v }) } return R = this, x < u.length && S.push({ elem: R, handlers: u.slice(x) }), S }, addProp: function (c, u) { Object.defineProperty(g.Event.prototype, c, { enumerable: !0, configurable: !0, get: Pe(u) ? function () { if (this.originalEvent) return u(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[c] }, set: function (f) { Object.defineProperty(this, c, { enumerable: !0, configurable: !0, writable: !0, value: f }) } }) }, fix: function (c) { return c[g.expando] ? c : new g.Event(c) }, special: { load: { noBubble: !0 }, click: { setup: function (c) { var u = this || c; return bo.test(u.type) && u.click && Bn(u, "input") && Ls(u, "click", Co), !1 }, trigger: function (c) { var u = this || c; return bo.test(u.type) && u.click && Bn(u, "input") && Ls(u, "click"), !0 }, _default: function (c) { var u = c.target; return bo.test(u.type) && u.click && Bn(u, "input") && ve.get(u, "click") || Bn(u, "a") } }, beforeunload: { postDispatch: function (c) { void 0 !== c.result && c.originalEvent && (c.originalEvent.returnValue = c.result) } } } }, g.removeEvent = function (c, u, f) { c.removeEventListener && c.removeEventListener(u, f) }, g.Event = function (c, u) { if (!(this instanceof g.Event)) return new g.Event(c, u); c && c.type ? (this.originalEvent = c, this.type = c.type, this.isDefaultPrevented = c.defaultPrevented || void 0 === c.defaultPrevented && !1 === c.returnValue ? Co : Do, this.target = c.target && 3 === c.target.nodeType ? c.target.parentNode : c.target, this.currentTarget = c.currentTarget, this.relatedTarget = c.relatedTarget) : this.type = c, u && g.extend(this, u), this.timeStamp = c && c.timeStamp || Date.now(), this[g.expando] = !0 }, g.Event.prototype = { constructor: g.Event, isDefaultPrevented: Do, isPropagationStopped: Do, isImmediatePropagationStopped: Do, isSimulated: !1, preventDefault: function () { var c = this.originalEvent; this.isDefaultPrevented = Co, c && !this.isSimulated && c.preventDefault() }, stopPropagation: function () { var c = this.originalEvent; this.isPropagationStopped = Co, c && !this.isSimulated && c.stopPropagation() }, stopImmediatePropagation: function () { var c = this.originalEvent; this.isImmediatePropagationStopped = Co, c && !this.isSimulated && c.stopImmediatePropagation(), this.stopPropagation() } }, g.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, g.event.addProp), g.each({ focus: "focusin", blur: "focusout" }, function (c, u) { g.event.special[c] = { setup: function () { return Ls(this, c, Bf), !1 }, trigger: function () { return Ls(this, c), !0 }, _default: function () { return !0 }, delegateType: u } }), g.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (c, u) { g.event.special[c] = { delegateType: u, bindType: u, handle: function (f) { var p, _ = this, v = f.relatedTarget, b = f.handleObj; return (!v || v !== _ && !g.contains(_, v)) && (f.type = b.origType, p = b.handler.apply(this, arguments), f.type = u), p } } }), g.fn.extend({ on: function (c, u, f, p) { return bl(this, c, u, f, p) }, one: function (c, u, f, p) { return bl(this, c, u, f, p, 1) }, off: function (c, u, f) { var p, _; if (c && c.preventDefault && c.handleObj) return p = c.handleObj, g(c.delegateTarget).off(p.namespace ? p.origType + "." + p.namespace : p.origType, p.selector, p.handler), this; if ("object" == typeof c) { for (_ in c) this.off(_, u, c[_]); return this } return (!1 === u || "function" == typeof u) && (f = u, u = void 0), !1 === f && (f = Do), this.each(function () { g.event.remove(this, c, f, u) }) } }); var Gi = /<script|<style|<link/i, Vf = /checked\s*(?:[^=]|=\s*.checked.)/i, Ft = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function wo(c, u) { return Bn(c, "table") && Bn(11 !== u.nodeType ? u : u.firstChild, "tr") && g(c).children("tbody")[0] || c } function qi(c) { return c.type = (null !== c.getAttribute("type")) + "/" + c.type, c } function ty(c) { return "true/" === (c.type || "").slice(0, 5) ? c.type = c.type.slice(5) : c.removeAttribute("type"), c } function Cd(c, u) { var f, p, _, b, S, x; if (1 === u.nodeType) { if (ve.hasData(c) && (x = ve.get(c).events)) for (_ in ve.remove(u, "handle events"), x) for (f = 0, p = x[_].length; f < p; f++)g.event.add(u, _, x[_][f]); Vn.hasData(c) && (b = Vn.access(c), S = g.extend({}, b), Vn.set(u, S)) } } function Dd(c, u) { var f = u.nodeName.toLowerCase(); "input" === f && bo.test(c.type) ? u.checked = c.checked : ("input" === f || "textarea" === f) && (u.defaultValue = c.defaultValue) } function dr(c, u, f, p) { u = pl(u); var _, v, b, S, x, R, N = 0, $ = c.length, I = $ - 1, B = u[0], ce = Pe(B); if (ce || $ > 1 && "string" == typeof B && !dt.checkClone && Vf.test(B)) return c.each(function (Me) { var de = c.eq(Me); ce && (u[0] = B.call(this, Me, de.html())), dr(de, u, f, p) }); if ($ && (v = (_ = On(u, c[0].ownerDocument, !1, c, p)).firstChild, 1 === _.childNodes.length && (_ = v), v || p)) { for (S = (b = g.map(wn(_, "script"), qi)).length; N < $; N++)x = _, N !== I && (x = g.clone(x, !0, !0), S && g.merge(b, wn(x, "script"))), f.call(c[N], x, N); if (S) for (R = b[b.length - 1].ownerDocument, g.map(b, ty), N = 0; N < S; N++)_d.test((x = b[N]).type || "") && !ve.access(x, "globalEval") && g.contains(R, x) && (x.src && "module" !== (x.type || "").toLowerCase() ? g._evalUrl && !x.noModule && g._evalUrl(x.src, { nonce: x.nonce || x.getAttribute("nonce") }, R) : Is(x.textContent.replace(Ft, ""), x, R)) } return c } function Cl(c, u, f) { for (var p, _ = u ? g.filter(u, c) : c, v = 0; null != (p = _[v]); v++)!f && 1 === p.nodeType && g.cleanData(wn(p)), p.parentNode && (f && Zo(p) && Ns(wn(p, "script")), p.parentNode.removeChild(p)); return c } g.extend({ htmlPrefilter: function (c) { return c }, clone: function (c, u, f) { var p, _, v, b, S = c.cloneNode(!0), x = Zo(c); if (!(dt.noCloneChecked || 1 !== c.nodeType && 11 !== c.nodeType || g.isXMLDoc(c))) for (b = wn(S), p = 0, _ = (v = wn(c)).length; p < _; p++)Dd(v[p], b[p]); if (u) if (f) for (v = v || wn(c), b = b || wn(S), p = 0, _ = v.length; p < _; p++)Cd(v[p], b[p]); else Cd(c, S); return (b = wn(S, "script")).length > 0 && Ns(b, !x && wn(c, "script")), S }, cleanData: function (c) { for (var u, f, p, _ = g.event.special, v = 0; void 0 !== (f = c[v]); v++)if (Ps(f)) { if (u = f[ve.expando]) { if (u.events) for (p in u.events) _[p] ? g.event.remove(f, p) : g.removeEvent(f, p, u.handle); f[ve.expando] = void 0 } f[Vn.expando] && (f[Vn.expando] = void 0) } } }), g.fn.extend({ detach: function (c) { return Cl(this, c, !0) }, remove: function (c) { return Cl(this, c) }, text: function (c) { return lr(this, function (u) { return void 0 === u ? g.text(this) : this.empty().each(function () { (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = u) }) }, null, c, arguments.length) }, append: function () { return dr(this, arguments, function (c) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || wo(this, c).appendChild(c) }) }, prepend: function () { return dr(this, arguments, function (c) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var u = wo(this, c); u.insertBefore(c, u.firstChild) } }) }, before: function () { return dr(this, arguments, function (c) { this.parentNode && this.parentNode.insertBefore(c, this) }) }, after: function () { return dr(this, arguments, function (c) { this.parentNode && this.parentNode.insertBefore(c, this.nextSibling) }) }, empty: function () { for (var c, u = 0; null != (c = this[u]); u++)1 === c.nodeType && (g.cleanData(wn(c, !1)), c.textContent = ""); return this }, clone: function (c, u) { return c = null != c && c, u = null == u ? c : u, this.map(function () { return g.clone(this, c, u) }) }, html: function (c) { return lr(this, function (u) { var f = this[0] || {}, p = 0, _ = this.length; if (void 0 === u && 1 === f.nodeType) return f.innerHTML; if ("string" == typeof u && !Gi.test(u) && !Hn[(yl.exec(u) || ["", ""])[1].toLowerCase()]) { u = g.htmlPrefilter(u); try { for (; p < _; p++)1 === (f = this[p] || {}).nodeType && (g.cleanData(wn(f, !1)), f.innerHTML = u); f = 0 } catch (v) { } } f && this.empty().append(u) }, null, c, arguments.length) }, replaceWith: function () { var c = []; return dr(this, arguments, function (u) { var f = this.parentNode; g.inArray(this, c) < 0 && (g.cleanData(wn(this)), f && f.replaceChild(u, this)) }, c) } }), g.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (c, u) { g.fn[c] = function (f) { for (var p, _ = [], v = g(f), b = v.length - 1, S = 0; S <= b; S++)p = S === b ? this : this.clone(!0), g(v[S])[u](p), As.apply(_, p.get()); return this.pushStack(_) } }); var zr = new RegExp("^(" + Nf + ")(?!px)[a-z%]+$", "i"), Bs = function (c) { var u = c.ownerDocument.defaultView; return (!u || !u.opener) && (u = Ee), u.getComputedStyle(c) }, Dl = function (c, u, f) { var p, _, v = {}; for (_ in u) v[_] = c.style[_], c.style[_] = u[_]; for (_ in p = f.call(c), u) c.style[_] = v[_]; return p }, wd = new RegExp(cr.join("|"), "i"); function Jo(c, u, f) { var p, _, v, b, S = c.style; return (f = f || Bs(c)) && ("" === (b = f.getPropertyValue(u) || f[u]) && !Zo(c) && (b = g.style(c, u)), !dt.pixelBoxStyles() && zr.test(b) && wd.test(u) && (p = S.width, _ = S.minWidth, v = S.maxWidth, S.minWidth = S.maxWidth = S.width = b, b = f.width, S.width = p, S.minWidth = _, S.maxWidth = v)), void 0 !== b ? b + "" : b } function xd(c, u) { return { get: function () { if (!c()) return (this.get = u).apply(this, arguments); delete this.get } } } !function () { function c() { if (R) { x.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", R.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", Hr.appendChild(x).appendChild(R); var N = Ee.getComputedStyle(R); f = "1%" !== N.top, S = 12 === u(N.marginLeft), R.style.right = "60%", v = 36 === u(N.right), p = 36 === u(N.width), R.style.position = "absolute", _ = 12 === u(R.offsetWidth / 3), Hr.removeChild(x), R = null } } function u(N) { return Math.round(parseFloat(N)) } var f, p, _, v, b, S, x = Ge.createElement("div"), R = Ge.createElement("div"); !R.style || (R.style.backgroundClip = "content-box", R.cloneNode(!0).style.backgroundClip = "", dt.clearCloneStyle = "content-box" === R.style.backgroundClip, g.extend(dt, { boxSizingReliable: function () { return c(), p }, pixelBoxStyles: function () { return c(), v }, pixelPosition: function () { return c(), f }, reliableMarginLeft: function () { return c(), S }, scrollboxSize: function () { return c(), _ }, reliableTrDimensions: function () { var N, $, I, B; return null == b && (N = Ge.createElement("table"), $ = Ge.createElement("tr"), I = Ge.createElement("div"), N.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", $.style.cssText = "border:1px solid", $.style.height = "1px", I.style.height = "9px", I.style.display = "block", Hr.appendChild(N).appendChild($).appendChild(I), B = Ee.getComputedStyle($), b = parseInt(B.height, 10) + parseInt(B.borderTopWidth, 10) + parseInt(B.borderBottomWidth, 10) === $.offsetHeight, Hr.removeChild(N)), b } })) }(); var Md = ["Webkit", "Moz", "ms"], Ed = Ge.createElement("div").style, wl = {}; function xl(c) { return g.cssProps[c] || wl[c] || (c in Ed ? c : wl[c] = function (c) { for (var u = c[0].toUpperCase() + c.slice(1), f = Md.length; f--;)if ((c = Md[f] + u) in Ed) return c }(c) || c) } var Ut = /^(none|table(?!-c[ea]).+)/, ei = /^--/, pn = { position: "absolute", visibility: "hidden", display: "block" }, Ml = { letterSpacing: "0", fontWeight: "400" }; function Vs(c, u, f) { var p = Xo.exec(u); return p ? Math.max(0, p[2] - (f || 0)) + (p[3] || "px") : u } function ht(c, u, f, p, _, v) { var b = "width" === u ? 1 : 0, S = 0, x = 0; if (f === (p ? "border" : "content")) return 0; for (; b < 4; b += 2)"margin" === f && (x += g.css(c, f + cr[b], !0, _)), p ? ("content" === f && (x -= g.css(c, "padding" + cr[b], !0, _)), "margin" !== f && (x -= g.css(c, "border" + cr[b] + "Width", !0, _))) : (x += g.css(c, "padding" + cr[b], !0, _), "padding" !== f ? x += g.css(c, "border" + cr[b] + "Width", !0, _) : S += g.css(c, "border" + cr[b] + "Width", !0, _)); return !p && v >= 0 && (x += Math.max(0, Math.ceil(c["offset" + u[0].toUpperCase() + u.slice(1)] - v - x - S - .5)) || 0), x } function Hs(c, u, f) { var p = Bs(c), v = (!dt.boxSizingReliable() || f) && "border-box" === g.css(c, "boxSizing", !1, p), b = v, S = Jo(c, u, p), x = "offset" + u[0].toUpperCase() + u.slice(1); if (zr.test(S)) { if (!f) return S; S = "auto" } return (!dt.boxSizingReliable() && v || !dt.reliableTrDimensions() && Bn(c, "tr") || "auto" === S || !parseFloat(S) && "inline" === g.css(c, "display", !1, p)) && c.getClientRects().length && (v = "border-box" === g.css(c, "boxSizing", !1, p), (b = x in c) && (S = c[x])), (S = parseFloat(S) || 0) + ht(c, u, f || (v ? "border" : "content"), b, p, S) + "px" } function De(c, u, f, p, _) { return new De.prototype.init(c, u, f, p, _) } g.extend({ cssHooks: { opacity: { get: function (c, u) { if (u) { var f = Jo(c, "opacity"); return "" === f ? "1" : f } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (c, u, f, p) { if (c && 3 !== c.nodeType && 8 !== c.nodeType && c.style) { var _, v, b, S = li(u), x = ei.test(u), R = c.style; if (x || (u = xl(S)), b = g.cssHooks[u] || g.cssHooks[S], void 0 === f) return b && "get" in b && void 0 !== (_ = b.get(c, !1, p)) ? _ : R[u]; if ("string" == (v = typeof f) && (_ = Xo.exec(f)) && _[1] && (f = Lf(c, u, _), v = "number"), null == f || f != f) return; "number" === v && !x && (f += _ && _[3] || (g.cssNumber[S] ? "" : "px")), !dt.clearCloneStyle && "" === f && 0 === u.indexOf("background") && (R[u] = "inherit"), (!b || !("set" in b) || void 0 !== (f = b.set(c, f, p))) && (x ? R.setProperty(u, f) : R[u] = f) } }, css: function (c, u, f, p) { var _, v, b, S = li(u); return ei.test(u) || (u = xl(S)), (b = g.cssHooks[u] || g.cssHooks[S]) && "get" in b && (_ = b.get(c, !0, f)), void 0 === _ && (_ = Jo(c, u, p)), "normal" === _ && u in Ml && (_ = Ml[u]), "" === f || f ? (v = parseFloat(_), !0 === f || isFinite(v) ? v || 0 : _) : _ } }), g.each(["height", "width"], function (c, u) { g.cssHooks[u] = { get: function (f, p, _) { if (p) return !Ut.test(g.css(f, "display")) || f.getClientRects().length && f.getBoundingClientRect().width ? Hs(f, u, _) : Dl(f, pn, function () { return Hs(f, u, _) }) }, set: function (f, p, _) { var v, b = Bs(f), S = !dt.scrollboxSize() && "absolute" === b.position, R = (S || _) && "border-box" === g.css(f, "boxSizing", !1, b), N = _ ? ht(f, u, _, R, b) : 0; return R && S && (N -= Math.ceil(f["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(b[u]) - ht(f, u, "border", !1, b) - .5)), N && (v = Xo.exec(p)) && "px" !== (v[3] || "px") && (f.style[u] = p, p = g.css(f, u)), Vs(0, p, N) } } }), g.cssHooks.marginLeft = xd(dt.reliableMarginLeft, function (c, u) { if (u) return (parseFloat(Jo(c, "marginLeft")) || c.getBoundingClientRect().left - Dl(c, { marginLeft: 0 }, function () { return c.getBoundingClientRect().left })) + "px" }), g.each({ margin: "", padding: "", border: "Width" }, function (c, u) { g.cssHooks[c + u] = { expand: function (f) { for (var p = 0, _ = {}, v = "string" == typeof f ? f.split(" ") : [f]; p < 4; p++)_[c + cr[p] + u] = v[p] || v[p - 2] || v[0]; return _ } }, "margin" !== c && (g.cssHooks[c + u].set = Vs) }), g.fn.extend({ css: function (c, u) { return lr(this, function (f, p, _) { var v, b, S = {}, x = 0; if (Array.isArray(p)) { for (v = Bs(f), b = p.length; x < b; x++)S[p[x]] = g.css(f, p[x], !1, v); return S } return void 0 !== _ ? g.style(f, p, _) : g.css(f, p) }, c, u, arguments.length > 1) } }), g.Tween = De, (De.prototype = { constructor: De, init: function (c, u, f, p, _, v) { this.elem = c, this.prop = f, this.easing = _ || g.easing._default, this.options = u, this.start = this.now = this.cur(), this.end = p, this.unit = v || (g.cssNumber[f] ? "" : "px") }, cur: function () { var c = De.propHooks[this.prop]; return c && c.get ? c.get(this) : De.propHooks._default.get(this) }, run: function (c) { var u, f = De.propHooks[this.prop]; return this.pos = u = this.options.duration ? g.easing[this.easing](c, this.options.duration * c, 0, 1, this.options.duration) : c, this.now = (this.end - this.start) * u + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), f && f.set ? f.set(this) : De.propHooks._default.set(this), this } }).init.prototype = De.prototype, (De.propHooks = { _default: { get: function (c) { var u; return 1 !== c.elem.nodeType || null != c.elem[c.prop] && null == c.elem.style[c.prop] ? c.elem[c.prop] : (u = g.css(c.elem, c.prop, "")) && "auto" !== u ? u : 0 }, set: function (c) { g.fx.step[c.prop] ? g.fx.step[c.prop](c) : 1 !== c.elem.nodeType || !g.cssHooks[c.prop] && null == c.elem.style[xl(c.prop)] ? c.elem[c.prop] = c.now : g.style(c.elem, c.prop, c.now + c.unit) } } }).scrollTop = De.propHooks.scrollLeft = { set: function (c) { c.elem.nodeType && c.elem.parentNode && (c.elem[c.prop] = c.now) } }, g.easing = { linear: function (c) { return c }, swing: function (c) { return .5 - Math.cos(c * Math.PI) / 2 }, _default: "swing" }, g.fx = De.prototype.init, g.fx.step = {}; var ur, js, We = /^(?:toggle|show|hide)$/, He = /queueHooks$/; function zs() { js && (!1 === Ge.hidden && Ee.requestAnimationFrame ? Ee.requestAnimationFrame(zs) : Ee.setTimeout(zs, g.fx.interval), g.fx.tick()) } function jf() { return Ee.setTimeout(function () { ur = void 0 }), ur = Date.now() } function mn(c, u) { var f, p = 0, _ = { height: c }; for (u = u ? 1 : 0; p < 4; p += 2 - u)_["margin" + (f = cr[p])] = _["padding" + f] = c; return u && (_.opacity = _.width = c), _ } function zf(c, u, f) { for (var p, _ = (yt.tweeners[u] || []).concat(yt.tweeners["*"]), v = 0, b = _.length; v < b; v++)if (p = _[v].call(f, u, c)) return p } function yt(c, u, f) { var p, _, v = 0, b = yt.prefilters.length, S = g.Deferred().always(function () { delete x.elem }), x = function () { if (_) return !1; for (var $ = ur || jf(), I = Math.max(0, R.startTime + R.duration - $), ce = 1 - (I / R.duration || 0), Me = 0, de = R.tweens.length; Me < de; Me++)R.tweens[Me].run(ce); return S.notifyWith(c, [R, ce, I]), ce < 1 && de ? I : (de || S.notifyWith(c, [R, 1, 0]), S.resolveWith(c, [R]), !1) }, R = S.promise({ elem: c, props: g.extend({}, u), opts: g.extend(!0, { specialEasing: {}, easing: g.easing._default }, f), originalProperties: u, originalOptions: f, startTime: ur || jf(), duration: f.duration, tweens: [], createTween: function ($, I) { var B = g.Tween(c, R.opts, $, I, R.opts.specialEasing[$] || R.opts.easing); return R.tweens.push(B), B }, stop: function ($) { var I = 0, B = $ ? R.tweens.length : 0; if (_) return this; for (_ = !0; I < B; I++)R.tweens[I].run(1); return $ ? (S.notifyWith(c, [R, 1, 0]), S.resolveWith(c, [R, $])) : S.rejectWith(c, [R, $]), this } }), N = R.props; for (function (c, u) { var f, p, _, v, b; for (f in c) if (_ = u[p = li(f)], v = c[f], Array.isArray(v) && (_ = v[1], v = c[f] = v[0]), f !== p && (c[p] = v, delete c[f]), (b = g.cssHooks[p]) && "expand" in b) for (f in v = b.expand(v), delete c[p], v) f in c || (c[f] = v[f], u[f] = _); else u[p] = _ }(N, R.opts.specialEasing); v < b; v++)if (p = yt.prefilters[v].call(R, c, N, R.opts)) return Pe(p.stop) && (g._queueHooks(R.elem, R.opts.queue).stop = p.stop.bind(p)), p; return g.map(N, zf, R), Pe(R.opts.start) && R.opts.start.call(c, R), R.progress(R.opts.progress).done(R.opts.done, R.opts.complete).fail(R.opts.fail).always(R.opts.always), g.fx.timer(g.extend(x, { elem: c, anim: R, queue: R.opts.queue })), R } g.Animation = g.extend(yt, { tweeners: { "*": [function (c, u) { var f = this.createTween(c, u); return Lf(f.elem, c, Xo.exec(u), f), f }] }, tweener: function (c, u) { Pe(c) ? (u = c, c = ["*"]) : c = c.match(lt); for (var f, p = 0, _ = c.length; p < _; p++)(yt.tweeners[f = c[p]] = yt.tweeners[f] || []).unshift(u) }, prefilters: [function (c, u, f) { var p, _, v, b, S, x, R, N, $ = "width" in u || "height" in u, I = this, B = {}, ce = c.style, Me = c.nodeType && vl(c), de = ve.get(c, "fxshow"); for (p in f.queue || (null == (b = g._queueHooks(c, "fx")).unqueued && (b.unqueued = 0, S = b.empty.fire, b.empty.fire = function () { b.unqueued || S() }), b.unqueued++, I.always(function () { I.always(function () { b.unqueued--, g.queue(c, "fx").length || b.empty.fire() }) })), u) if (We.test(_ = u[p])) { if (delete u[p], v = v || "toggle" === _, _ === (Me ? "hide" : "show")) { if ("show" !== _ || !de || void 0 === de[p]) continue; Me = !0 } B[p] = de && de[p] || g.style(c, p) } if ((x = !g.isEmptyObject(u)) || !g.isEmptyObject(B)) for (p in $ && 1 === c.nodeType && (f.overflow = [ce.overflow, ce.overflowX, ce.overflowY], null == (R = de && de.display) && (R = ve.get(c, "display")), "none" === (N = g.css(c, "display")) && (R ? N = R : (jr([c], !0), R = c.style.display || R, N = g.css(c, "display"), jr([c]))), ("inline" === N || "inline-block" === N && null != R) && "none" === g.css(c, "float") && (x || (I.done(function () { ce.display = R }), null == R && (R = "none" === (N = ce.display) ? "" : N)), ce.display = "inline-block")), f.overflow && (ce.overflow = "hidden", I.always(function () { ce.overflow = f.overflow[0], ce.overflowX = f.overflow[1], ce.overflowY = f.overflow[2] })), x = !1, B) x || (de ? "hidden" in de && (Me = de.hidden) : de = ve.access(c, "fxshow", { display: R }), v && (de.hidden = !Me), Me && jr([c], !0), I.done(function () { for (p in Me || jr([c]), ve.remove(c, "fxshow"), B) g.style(c, p, B[p]) })), x = zf(Me ? de[p] : 0, p, I), p in de || (de[p] = x.start, Me && (x.end = x.start, x.start = 0)) }], prefilter: function (c, u) { u ? yt.prefilters.unshift(c) : yt.prefilters.push(c) } }), g.speed = function (c, u, f) { var p = c && "object" == typeof c ? g.extend({}, c) : { complete: f || !f && u || Pe(c) && c, duration: c, easing: f && u || u && !Pe(u) && u }; return g.fx.off ? p.duration = 0 : "number" != typeof p.duration && (p.duration = p.duration in g.fx.speeds ? g.fx.speeds[p.duration] : g.fx.speeds._default), (null == p.queue || !0 === p.queue) && (p.queue = "fx"), p.old = p.complete, p.complete = function () { Pe(p.old) && p.old.call(this), p.queue && g.dequeue(this, p.queue) }, p }, g.fn.extend({ fadeTo: function (c, u, f, p) { return this.filter(vl).css("opacity", 0).show().end().animate({ opacity: u }, c, f, p) }, animate: function (c, u, f, p) { var _ = g.isEmptyObject(c), v = g.speed(u, f, p), b = function () { var S = yt(this, g.extend({}, c), v); (_ || ve.get(this, "finish")) && S.stop(!0) }; return b.finish = b, _ || !1 === v.queue ? this.each(b) : this.queue(v.queue, b) }, stop: function (c, u, f) { var p = function (_) { var v = _.stop; delete _.stop, v(f) }; return "string" != typeof c && (f = u, u = c, c = void 0), u && this.queue(c || "fx", []), this.each(function () { var _ = !0, v = null != c && c + "queueHooks", b = g.timers, S = ve.get(this); if (v) S[v] && S[v].stop && p(S[v]); else for (v in S) S[v] && S[v].stop && He.test(v) && p(S[v]); for (v = b.length; v--;)b[v].elem === this && (null == c || b[v].queue === c) && (b[v].anim.stop(f), _ = !1, b.splice(v, 1)); (_ || !f) && g.dequeue(this, c) }) }, finish: function (c) { return !1 !== c && (c = c || "fx"), this.each(function () { var u, f = ve.get(this), p = f[c + "queue"], _ = f[c + "queueHooks"], v = g.timers, b = p ? p.length : 0; for (f.finish = !0, g.queue(this, c, []), _ && _.stop && _.stop.call(this, !0), u = v.length; u--;)v[u].elem === this && v[u].queue === c && (v[u].anim.stop(!0), v.splice(u, 1)); for (u = 0; u < b; u++)p[u] && p[u].finish && p[u].finish.call(this); delete f.finish }) } }), g.each(["toggle", "show", "hide"], function (c, u) { var f = g.fn[u]; g.fn[u] = function (p, _, v) { return null == p || "boolean" == typeof p ? f.apply(this, arguments) : this.animate(mn(u, !0), p, _, v) } }), g.each({ slideDown: mn("show"), slideUp: mn("hide"), slideToggle: mn("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (c, u) { g.fn[c] = function (f, p, _) { return this.animate(u, f, p, _) } }), g.timers = [], g.fx.tick = function () { var c, u = 0, f = g.timers; for (ur = Date.now(); u < f.length; u++)!(c = f[u])() && f[u] === c && f.splice(u--, 1); f.length || g.fx.stop(), ur = void 0 }, g.fx.timer = function (c) { g.timers.push(c), g.fx.start() }, g.fx.interval = 13, g.fx.start = function () { js || (js = !0, zs()) }, g.fx.stop = function () { js = null }, g.fx.speeds = { slow: 600, fast: 200, _default: 400 }, g.fn.delay = function (c, u) { return c = g.fx && g.fx.speeds[c] || c, this.queue(u = u || "fx", function (f, p) { var _ = Ee.setTimeout(f, c); p.stop = function () { Ee.clearTimeout(_) } }) }, function () { var c = Ge.createElement("input"), f = Ge.createElement("select").appendChild(Ge.createElement("option")); c.type = "checkbox", dt.checkOn = "" !== c.value, dt.optSelected = f.selected, (c = Ge.createElement("input")).value = "t", c.type = "radio", dt.radioValue = "t" === c.value }(); var Sd, Us = g.expr.attrHandle; g.fn.extend({ attr: function (c, u) { return lr(this, g.attr, c, u, arguments.length > 1) }, removeAttr: function (c) { return this.each(function () { g.removeAttr(this, c) }) } }), g.extend({ attr: function (c, u, f) { var p, _, v = c.nodeType; if (3 !== v && 8 !== v && 2 !== v) return void 0 === c.getAttribute ? g.prop(c, u, f) : ((1 !== v || !g.isXMLDoc(c)) && (_ = g.attrHooks[u.toLowerCase()] || (g.expr.match.bool.test(u) ? Sd : void 0)), void 0 !== f ? null === f ? void g.removeAttr(c, u) : _ && "set" in _ && void 0 !== (p = _.set(c, f, u)) ? p : (c.setAttribute(u, f + ""), f) : _ && "get" in _ && null !== (p = _.get(c, u)) ? p : null == (p = g.find.attr(c, u)) ? void 0 : p) }, attrHooks: { type: { set: function (c, u) { if (!dt.radioValue && "radio" === u && Bn(c, "input")) { var f = c.value; return c.setAttribute("type", u), f && (c.value = f), u } } } }, removeAttr: function (c, u) { var f, p = 0, _ = u && u.match(lt); if (_ && 1 === c.nodeType) for (; f = _[p++];)c.removeAttribute(f) } }), Sd = { set: function (c, u, f) { return !1 === u ? g.removeAttr(c, f) : c.setAttribute(f, f), f } }, g.each(g.expr.match.bool.source.match(/\w+/g), function (c, u) { var f = Us[u] || g.find.attr; Us[u] = function (p, _, v) { var b, S, x = _.toLowerCase(); return v || (S = Us[x], Us[x] = b, b = null != f(p, _, v) ? x : null, Us[x] = S), b } }); var ny = /^(?:input|select|textarea|button)$/i, $s = /^(?:a|area)$/i; function $t(c) { return (c.match(lt) || []).join(" ") } function xo(c) { return c.getAttribute && c.getAttribute("class") || "" } function Sl(c) { return Array.isArray(c) ? c : "string" == typeof c && c.match(lt) || [] } g.fn.extend({ prop: function (c, u) { return lr(this, g.prop, c, u, arguments.length > 1) }, removeProp: function (c) { return this.each(function () { delete this[g.propFix[c] || c] }) } }), g.extend({ prop: function (c, u, f) { var p, _, v = c.nodeType; if (3 !== v && 8 !== v && 2 !== v) return (1 !== v || !g.isXMLDoc(c)) && (_ = g.propHooks[u = g.propFix[u] || u]), void 0 !== f ? _ && "set" in _ && void 0 !== (p = _.set(c, f, u)) ? p : c[u] = f : _ && "get" in _ && null !== (p = _.get(c, u)) ? p : c[u] }, propHooks: { tabIndex: { get: function (c) { var u = g.find.attr(c, "tabindex"); return u ? parseInt(u, 10) : ny.test(c.nodeName) || $s.test(c.nodeName) && c.href ? 0 : -1 } } }, propFix: { for: "htmlFor", class: "className" } }), dt.optSelected || (g.propHooks.selected = { get: function (c) { return null }, set: function (c) { } }), g.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { g.propFix[this.toLowerCase()] = this }), g.fn.extend({ addClass: function (c) { var u, f, p, _, v, b, S, x = 0; if (Pe(c)) return this.each(function (R) { g(this).addClass(c.call(this, R, xo(this))) }); if ((u = Sl(c)).length) for (; f = this[x++];)if (_ = xo(f), p = 1 === f.nodeType && " " + $t(_) + " ") { for (b = 0; v = u[b++];)p.indexOf(" " + v + " ") < 0 && (p += v + " "); _ !== (S = $t(p)) && f.setAttribute("class", S) } return this }, removeClass: function (c) { var u, f, p, _, v, b, S, x = 0; if (Pe(c)) return this.each(function (R) { g(this).removeClass(c.call(this, R, xo(this))) }); if (!arguments.length) return this.attr("class", ""); if ((u = Sl(c)).length) for (; f = this[x++];)if (_ = xo(f), p = 1 === f.nodeType && " " + $t(_) + " ") { for (b = 0; v = u[b++];)for (; p.indexOf(" " + v + " ") > -1;)p = p.replace(" " + v + " ", " "); _ !== (S = $t(p)) && f.setAttribute("class", S) } return this }, toggleClass: function (c, u) { var f = typeof c, p = "string" === f || Array.isArray(c); return "boolean" == typeof u && p ? u ? this.addClass(c) : this.removeClass(c) : Pe(c) ? this.each(function (_) { g(this).toggleClass(c.call(this, _, xo(this), u), u) }) : this.each(function () { var _, v, b, S; if (p) for (v = 0, b = g(this), S = Sl(c); _ = S[v++];)b.hasClass(_) ? b.removeClass(_) : b.addClass(_); else (void 0 === c || "boolean" === f) && ((_ = xo(this)) && ve.set(this, "__className__", _), this.setAttribute && this.setAttribute("class", _ || !1 === c ? "" : ve.get(this, "__className__") || "")) }) }, hasClass: function (c) { var u, f, p = 0; for (u = " " + c + " "; f = this[p++];)if (1 === f.nodeType && (" " + $t(xo(f)) + " ").indexOf(u) > -1) return !0; return !1 } }); var iy = /\r/g; g.fn.extend({ val: function (c) { var u, f, p, _ = this[0]; return arguments.length ? (p = Pe(c), this.each(function (v) { var b; 1 === this.nodeType && (null == (b = p ? c.call(this, v, g(this).val()) : c) ? b = "" : "number" == typeof b ? b += "" : Array.isArray(b) && (b = g.map(b, function (S) { return null == S ? "" : S + "" })), (!(u = g.valHooks[this.type] || g.valHooks[this.nodeName.toLowerCase()]) || !("set" in u) || void 0 === u.set(this, b, "value")) && (this.value = b)) })) : _ ? (u = g.valHooks[_.type] || g.valHooks[_.nodeName.toLowerCase()]) && "get" in u && void 0 !== (f = u.get(_, "value")) ? f : "string" == typeof (f = _.value) ? f.replace(iy, "") : null == f ? "" : f : void 0 } }), g.extend({ valHooks: { option: { get: function (c) { var u = g.find.attr(c, "value"); return null != u ? u : $t(g.text(c)) } }, select: { get: function (c) { var u, f, p, _ = c.options, v = c.selectedIndex, b = "select-one" === c.type, S = b ? null : [], x = b ? v + 1 : _.length; for (p = v < 0 ? x : b ? v : 0; p < x; p++)if (((f = _[p]).selected || p === v) && !f.disabled && (!f.parentNode.disabled || !Bn(f.parentNode, "optgroup"))) { if (u = g(f).val(), b) return u; S.push(u) } return S }, set: function (c, u) { for (var f, p, _ = c.options, v = g.makeArray(u), b = _.length; b--;)((p = _[b]).selected = g.inArray(g.valHooks.option.get(p), v) > -1) && (f = !0); return f || (c.selectedIndex = -1), v } } } }), g.each(["radio", "checkbox"], function () { g.valHooks[this] = { set: function (c, u) { if (Array.isArray(u)) return c.checked = g.inArray(g(c).val(), u) > -1 } }, dt.checkOn || (g.valHooks[this].get = function (c) { return null === c.getAttribute("value") ? "on" : c.value }) }), dt.focusin = "onfocusin" in Ee; var Si = /^(?:focusinfocus|focusoutblur)$/, Uf = function (c) { c.stopPropagation() }; g.extend(g.event, { trigger: function (c, u, f, p) { var _, v, b, S, x, R, N, $, I = [f || Ge], B = Ui.call(c, "type") ? c.type : c, ce = Ui.call(c, "namespace") ? c.namespace.split(".") : []; if (v = $ = b = f = f || Ge, 3 !== f.nodeType && 8 !== f.nodeType && !Si.test(B + g.event.triggered) && (B.indexOf(".") > -1 && (ce = B.split("."), B = ce.shift(), ce.sort()), x = B.indexOf(":") < 0 && "on" + B, (c = c[g.expando] ? c : new g.Event(B, "object" == typeof c && c)).isTrigger = p ? 2 : 3, c.namespace = ce.join("."), c.rnamespace = c.namespace ? new RegExp("(^|\\.)" + ce.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, c.result = void 0, c.target || (c.target = f), u = null == u ? [c] : g.makeArray(u, [c]), N = g.event.special[B] || {}, p || !N.trigger || !1 !== N.trigger.apply(f, u))) { if (!p && !N.noBubble && !Jn(f)) { for (Si.test((S = N.delegateType || B) + B) || (v = v.parentNode); v; v = v.parentNode)I.push(v), b = v; b === (f.ownerDocument || Ge) && I.push(b.defaultView || b.parentWindow || Ee) } for (_ = 0; (v = I[_++]) && !c.isPropagationStopped();)$ = v, c.type = _ > 1 ? S : N.bindType || B, (R = (ve.get(v, "events") || Object.create(null))[c.type] && ve.get(v, "handle")) && R.apply(v, u), (R = x && v[x]) && R.apply && Ps(v) && (c.result = R.apply(v, u), !1 === c.result && c.preventDefault()); return c.type = B, !p && !c.isDefaultPrevented() && (!N._default || !1 === N._default.apply(I.pop(), u)) && Ps(f) && x && Pe(f[B]) && !Jn(f) && ((b = f[x]) && (f[x] = null), g.event.triggered = B, c.isPropagationStopped() && $.addEventListener(B, Uf), f[B](), c.isPropagationStopped() && $.removeEventListener(B, Uf), g.event.triggered = void 0, b && (f[x] = b)), c.result } }, simulate: function (c, u, f) { var p = g.extend(new g.Event, f, { type: c, isSimulated: !0 }); g.event.trigger(p, null, u) } }), g.fn.extend({ trigger: function (c, u) { return this.each(function () { g.event.trigger(c, u, this) }) }, triggerHandler: function (c, u) { var f = this[0]; if (f) return g.event.trigger(c, u, f, !0) } }), dt.focusin || g.each({ focus: "focusin", blur: "focusout" }, function (c, u) { var f = function (p) { g.event.simulate(u, p.target, g.event.fix(p)) }; g.event.special[u] = { setup: function () { var p = this.ownerDocument || this.document || this, _ = ve.access(p, u); _ || p.addEventListener(c, f, !0), ve.access(p, u, (_ || 0) + 1) }, teardown: function () { var p = this.ownerDocument || this.document || this, _ = ve.access(p, u) - 1; _ ? ve.access(p, u, _) : (p.removeEventListener(c, f, !0), ve.remove(p, u)) } } }); var Gs = Ee.location, $f = { guid: Date.now() }, Td = /\?/; g.parseXML = function (c) { var u, f; if (!c || "string" != typeof c) return null; try { u = (new Ee.DOMParser).parseFromString(c, "text/xml") } catch (p) { } return f = u && u.getElementsByTagName("parsererror")[0], (!u || f) && g.error("Invalid XML: " + (f ? g.map(f.childNodes, function (p) { return p.textContent }).join("\n") : c)), u }; var Gf = /\[\]$/, qf = /\r?\n/g, Wf = /^(?:submit|button|image|reset|file)$/i, ry = /^(?:input|select|textarea|keygen)/i; function xn(c, u, f, p) { var _; if (Array.isArray(u)) g.each(u, function (v, b) { f || Gf.test(c) ? p(c, b) : xn(c + "[" + ("object" == typeof b && null != b ? v : "") + "]", b, f, p) }); else if (f || "object" !== sr(u)) p(c, u); else for (_ in u) xn(c + "[" + _ + "]", u[_], f, p) } g.param = function (c, u) { var f, p = [], _ = function (v, b) { var S = Pe(b) ? b() : b; p[p.length] = encodeURIComponent(v) + "=" + encodeURIComponent(null == S ? "" : S) }; if (null == c) return ""; if (Array.isArray(c) || c.jquery && !g.isPlainObject(c)) g.each(c, function () { _(this.name, this.value) }); else for (f in c) xn(f, c[f], u, _); return p.join("&") }, g.fn.extend({ serialize: function () { return g.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var c = g.prop(this, "elements"); return c ? g.makeArray(c) : this }).filter(function () { var c = this.type; return this.name && !g(this).is(":disabled") && ry.test(this.nodeName) && !Wf.test(c) && (this.checked || !bo.test(c)) }).map(function (c, u) { var f = g(this).val(); return null == f ? null : Array.isArray(f) ? g.map(f, function (p) { return { name: u.name, value: p.replace(qf, "\r\n") } }) : { name: u.name, value: f.replace(qf, "\r\n") } }).get() } }); var bt = /%20/g, oy = /#.*$/, sy = /([?&])_=[^&]*/, ay = /^(.*?):[ \t]*([^\r\n]*)$/gm, ly = /^(?:GET|HEAD)$/, re = /^\/\//, qs = {}, Ws = {}, kd = "*/".concat("*"), Tl = Ge.createElement("a"); function kl(c) { return function (u, f) { "string" != typeof u && (f = u, u = "*"); var p, _ = 0, v = u.toLowerCase().match(lt) || []; if (Pe(f)) for (; p = v[_++];)"+" === p[0] ? (p = p.slice(1) || "*", (c[p] = c[p] || []).unshift(f)) : (c[p] = c[p] || []).push(f) } } function es(c, u, f, p) { var _ = {}, v = c === Ws; function b(S) { var x; return _[S] = !0, g.each(c[S] || [], function (R, N) { var $ = N(u, f, p); return "string" != typeof $ || v || _[$] ? v ? !(x = $) : void 0 : (u.dataTypes.unshift($), b($), !1) }), x } return b(u.dataTypes[0]) || !_["*"] && b("*") } function ts(c, u) { var f, p, _ = g.ajaxSettings.flatOptions || {}; for (f in u) void 0 !== u[f] && ((_[f] ? c : p || (p = {}))[f] = u[f]); return p && g.extend(!0, c, p), c } Tl.href = Gs.href, g.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Gs.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Gs.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": kd, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": g.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (c, u) { return u ? ts(ts(c, g.ajaxSettings), u) : ts(g.ajaxSettings, c) }, ajaxPrefilter: kl(qs), ajaxTransport: kl(Ws), ajax: function (c, u) { "object" == typeof c && (u = c, c = void 0); var f, p, _, v, b, S, x, R, N, $, I = g.ajaxSetup({}, u = u || {}), B = I.context || I, ce = I.context && (B.nodeType || B.jquery) ? g(B) : g.event, Me = g.Deferred(), de = g.Callbacks("once memory"), gt = I.statusCode || {}, xt = {}, jn = {}, ue = "canceled", Se = { readyState: 0, getResponseHeader: function (tt) { var Mt; if (x) { if (!v) for (v = {}; Mt = ay.exec(_);)v[Mt[1].toLowerCase() + " "] = (v[Mt[1].toLowerCase() + " "] || []).concat(Mt[2]); Mt = v[tt.toLowerCase() + " "] } return null == Mt ? null : Mt.join(", ") }, getAllResponseHeaders: function () { return x ? _ : null }, setRequestHeader: function (tt, Mt) { return null == x && (tt = jn[tt.toLowerCase()] = jn[tt.toLowerCase()] || tt, xt[tt] = Mt), this }, overrideMimeType: function (tt) { return null == x && (I.mimeType = tt), this }, statusCode: function (tt) { var Mt; if (tt) if (x) Se.always(tt[Se.status]); else for (Mt in tt) gt[Mt] = [gt[Mt], tt[Mt]]; return this }, abort: function (tt) { var Mt = tt || ue; return f && f.abort(Mt), Mn(0, Mt), this } }; if (Me.promise(Se), I.url = ((c || I.url || Gs.href) + "").replace(re, Gs.protocol + "//"), I.type = u.method || u.type || I.method || I.type, I.dataTypes = (I.dataType || "*").toLowerCase().match(lt) || [""], null == I.crossDomain) { S = Ge.createElement("a"); try { S.href = I.url, S.href = S.href, I.crossDomain = Tl.protocol + "//" + Tl.host != S.protocol + "//" + S.host } catch (tt) { I.crossDomain = !0 } } if (I.data && I.processData && "string" != typeof I.data && (I.data = g.param(I.data, I.traditional)), es(qs, I, u, Se), x) return Se; for (N in (R = g.event && I.global) && 0 == g.active++ && g.event.trigger("ajaxStart"), I.type = I.type.toUpperCase(), I.hasContent = !ly.test(I.type), p = I.url.replace(oy, ""), I.hasContent ? I.data && I.processData && 0 === (I.contentType || "").indexOf("application/x-www-form-urlencoded") && (I.data = I.data.replace(bt, "+")) : ($ = I.url.slice(p.length), I.data && (I.processData || "string" == typeof I.data) && (p += (Td.test(p) ? "&" : "?") + I.data, delete I.data), !1 === I.cache && (p = p.replace(sy, "$1"), $ = (Td.test(p) ? "&" : "?") + "_=" + $f.guid++ + $), I.url = p + $), I.ifModified && (g.lastModified[p] && Se.setRequestHeader("If-Modified-Since", g.lastModified[p]), g.etag[p] && Se.setRequestHeader("If-None-Match", g.etag[p])), (I.data && I.hasContent && !1 !== I.contentType || u.contentType) && Se.setRequestHeader("Content-Type", I.contentType), Se.setRequestHeader("Accept", I.dataTypes[0] && I.accepts[I.dataTypes[0]] ? I.accepts[I.dataTypes[0]] + ("*" !== I.dataTypes[0] ? ", " + kd + "; q=0.01" : "") : I.accepts["*"]), I.headers) Se.setRequestHeader(N, I.headers[N]); if (I.beforeSend && (!1 === I.beforeSend.call(B, Se, I) || x)) return Se.abort(); if (ue = "abort", de.add(I.complete), Se.done(I.success), Se.fail(I.error), f = es(Ws, I, u, Se)) { if (Se.readyState = 1, R && ce.trigger("ajaxSend", [Se, I]), x) return Se; I.async && I.timeout > 0 && (b = Ee.setTimeout(function () { Se.abort("timeout") }, I.timeout)); try { x = !1, f.send(xt, Mn) } catch (tt) { if (x) throw tt; Mn(-1, tt) } } else Mn(-1, "No Transport"); function Mn(tt, Mt, J, Ys) { var Pn, z, Nt, ft, En, Qt = Mt; x || (x = !0, b && Ee.clearTimeout(b), f = void 0, _ = Ys || "", Se.readyState = tt > 0 ? 4 : 0, Pn = tt >= 200 && tt < 300 || 304 === tt, J && (ft = function (c, u, f) { for (var p, _, v, b, S = c.contents, x = c.dataTypes; "*" === x[0];)x.shift(), void 0 === p && (p = c.mimeType || u.getResponseHeader("Content-Type")); if (p) for (_ in S) if (S[_] && S[_].test(p)) { x.unshift(_); break } if (x[0] in f) v = x[0]; else { for (_ in f) { if (!x[0] || c.converters[_ + " " + x[0]]) { v = _; break } b || (b = _) } v = v || b } if (v) return v !== x[0] && x.unshift(v), f[v] }(I, Se, J)), !Pn && g.inArray("script", I.dataTypes) > -1 && g.inArray("json", I.dataTypes) < 0 && (I.converters["text script"] = function () { }), ft = function (c, u, f, p) { var _, v, b, S, x, R = {}, N = c.dataTypes.slice(); if (N[1]) for (b in c.converters) R[b.toLowerCase()] = c.converters[b]; for (v = N.shift(); v;)if (c.responseFields[v] && (f[c.responseFields[v]] = u), !x && p && c.dataFilter && (u = c.dataFilter(u, c.dataType)), x = v, v = N.shift()) if ("*" === v) v = x; else if ("*" !== x && x !== v) { if (!(b = R[x + " " + v] || R["* " + v])) for (_ in R) if ((S = _.split(" "))[1] === v && (b = R[x + " " + S[0]] || R["* " + S[0]])) { !0 === b ? b = R[_] : !0 !== R[_] && (v = S[0], N.unshift(S[1])); break } if (!0 !== b) if (b && c.throws) u = b(u); else try { u = b(u) } catch ($) { return { state: "parsererror", error: b ? $ : "No conversion from " + x + " to " + v } } } return { state: "success", data: u } }(I, ft, Se, Pn), Pn ? (I.ifModified && ((En = Se.getResponseHeader("Last-Modified")) && (g.lastModified[p] = En), (En = Se.getResponseHeader("etag")) && (g.etag[p] = En)), 204 === tt || "HEAD" === I.type ? Qt = "nocontent" : 304 === tt ? Qt = "notmodified" : (Qt = ft.state, z = ft.data, Pn = !(Nt = ft.error))) : (Nt = Qt, (tt || !Qt) && (Qt = "error", tt < 0 && (tt = 0))), Se.status = tt, Se.statusText = (Mt || Qt) + "", Pn ? Me.resolveWith(B, [z, Qt, Se]) : Me.rejectWith(B, [Se, Qt, Nt]), Se.statusCode(gt), gt = void 0, R && ce.trigger(Pn ? "ajaxSuccess" : "ajaxError", [Se, I, Pn ? z : Nt]), de.fireWith(B, [Se, Qt]), R && (ce.trigger("ajaxComplete", [Se, I]), --g.active || g.event.trigger("ajaxStop"))) } return Se }, getJSON: function (c, u, f) { return g.get(c, u, f, "json") }, getScript: function (c, u) { return g.get(c, void 0, u, "script") } }), g.each(["get", "post"], function (c, u) { g[u] = function (f, p, _, v) { return Pe(p) && (v = v || _, _ = p, p = void 0), g.ajax(g.extend({ url: f, type: u, dataType: v, data: p, success: _ }, g.isPlainObject(f) && f)) } }), g.ajaxPrefilter(function (c) { var u; for (u in c.headers) "content-type" === u.toLowerCase() && (c.contentType = c.headers[u] || "") }), g._evalUrl = function (c, u, f) { return g.ajax({ url: c, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (p) { g.globalEval(p, u, f) } }) }, g.fn.extend({ wrapAll: function (c) { var u; return this[0] && (Pe(c) && (c = c.call(this[0])), u = g(c, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && u.insertBefore(this[0]), u.map(function () { for (var f = this; f.firstElementChild;)f = f.firstElementChild; return f }).append(this)), this }, wrapInner: function (c) { return Pe(c) ? this.each(function (u) { g(this).wrapInner(c.call(this, u)) }) : this.each(function () { var u = g(this), f = u.contents(); f.length ? f.wrapAll(c) : u.append(c) }) }, wrap: function (c) { var u = Pe(c); return this.each(function (f) { g(this).wrapAll(u ? c.call(this, f) : c) }) }, unwrap: function (c) { return this.parent(c).not("body").each(function () { g(this).replaceWith(this.childNodes) }), this } }), g.expr.pseudos.hidden = function (c) { return !g.expr.pseudos.visible(c) }, g.expr.pseudos.visible = function (c) { return !!(c.offsetWidth || c.offsetHeight || c.getClientRects().length) }, g.ajaxSettings.xhr = function () { try { return new Ee.XMLHttpRequest } catch (c) { } }; var Ie = { 0: 200, 1223: 204 }, Ur = g.ajaxSettings.xhr(); dt.cors = !!Ur && "withCredentials" in Ur, dt.ajax = Ur = !!Ur, g.ajaxTransport(function (c) { var u, f; if (dt.cors || Ur && !c.crossDomain) return { send: function (p, _) { var v, b = c.xhr(); if (b.open(c.type, c.url, c.async, c.username, c.password), c.xhrFields) for (v in c.xhrFields) b[v] = c.xhrFields[v]; for (v in c.mimeType && b.overrideMimeType && b.overrideMimeType(c.mimeType), !c.crossDomain && !p["X-Requested-With"] && (p["X-Requested-With"] = "XMLHttpRequest"), p) b.setRequestHeader(v, p[v]); u = function (S) { return function () { u && (u = f = b.onload = b.onerror = b.onabort = b.ontimeout = b.onreadystatechange = null, "abort" === S ? b.abort() : "error" === S ? "number" != typeof b.status ? _(0, "error") : _(b.status, b.statusText) : _(Ie[b.status] || b.status, b.statusText, "text" !== (b.responseType || "text") || "string" != typeof b.responseText ? { binary: b.response } : { text: b.responseText }, b.getAllResponseHeaders())) } }, b.onload = u(), f = b.onerror = b.ontimeout = u("error"), void 0 !== b.onabort ? b.onabort = f : b.onreadystatechange = function () { 4 === b.readyState && Ee.setTimeout(function () { u && f() }) }, u = u("abort"); try { b.send(c.hasContent && c.data || null) } catch (S) { if (u) throw S } }, abort: function () { u && u() } } }), g.ajaxPrefilter(function (c) { c.crossDomain && (c.contents.script = !1) }), g.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (c) { return g.globalEval(c), c } } }), g.ajaxPrefilter("script", function (c) { void 0 === c.cache && (c.cache = !1), c.crossDomain && (c.type = "GET") }), g.ajaxTransport("script", function (c) { var u, f; if (c.crossDomain || c.scriptAttrs) return { send: function (p, _) { u = g("<script>").attr(c.scriptAttrs || {}).prop({ charset: c.scriptCharset, src: c.url }).on("load error", f = function (v) { u.remove(), f = null, v && _("error" === v.type ? 404 : 200, v.type) }), Ge.head.appendChild(u[0]) }, abort: function () { f && f() } } }); var c, Id = [], Ti = /(=)\?(?=&|$)|\?\?/; g.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var c = Id.pop() || g.expando + "_" + $f.guid++; return this[c] = !0, c } }), g.ajaxPrefilter("json jsonp", function (c, u, f) { var p, _, v, b = !1 !== c.jsonp && (Ti.test(c.url) ? "url" : "string" == typeof c.data && 0 === (c.contentType || "").indexOf("application/x-www-form-urlencoded") && Ti.test(c.data) && "data"); if (b || "jsonp" === c.dataTypes[0]) return p = c.jsonpCallback = Pe(c.jsonpCallback) ? c.jsonpCallback() : c.jsonpCallback, b ? c[b] = c[b].replace(Ti, "$1" + p) : !1 !== c.jsonp && (c.url += (Td.test(c.url) ? "&" : "?") + c.jsonp + "=" + p), c.converters["script json"] = function () { return v || g.error(p + " was not called"), v[0] }, c.dataTypes[0] = "json", _ = Ee[p], Ee[p] = function () { v = arguments }, f.always(function () { void 0 === _ ? g(Ee).removeProp(p) : Ee[p] = _, c[p] && (c.jsonpCallback = u.jsonpCallback, Id.push(p)), v && Pe(_) && _(v[0]), v = _ = void 0 }), "script" }), dt.createHTMLDocument = ((c = Ge.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === c.childNodes.length), g.parseHTML = function (c, u, f) { return "string" != typeof c ? [] : ("boolean" == typeof u && (f = u, u = !1), u || (dt.createHTMLDocument ? ((p = (u = Ge.implementation.createHTMLDocument("")).createElement("base")).href = Ge.location.href, u.head.appendChild(p)) : u = Ge), v = !f && [], (_ = at.exec(c)) ? [u.createElement(_[1])] : (_ = On([c], u, v), v && v.length && g(v).remove(), g.merge([], _.childNodes))); var p, _, v }, g.fn.load = function (c, u, f) { var p, _, v, b = this, S = c.indexOf(" "); return S > -1 && (p = $t(c.slice(S)), c = c.slice(0, S)), Pe(u) ? (f = u, u = void 0) : u && "object" == typeof u && (_ = "POST"), b.length > 0 && g.ajax({ url: c, type: _ || "GET", dataType: "html", data: u }).done(function (x) { v = arguments, b.html(p ? g("<div>").append(g.parseHTML(x)).find(p) : x) }).always(f && function (x, R) { b.each(function () { f.apply(this, v || [x.responseText, R, x]) }) }), this }, g.expr.pseudos.animated = function (c) { return g.grep(g.timers, function (u) { return c === u.elem }).length }, g.offset = { setOffset: function (c, u, f) { var p, _, v, b, S, x, N = g.css(c, "position"), $ = g(c), I = {}; "static" === N && (c.style.position = "relative"), S = $.offset(), v = g.css(c, "top"), x = g.css(c, "left"), ("absolute" === N || "fixed" === N) && (v + x).indexOf("auto") > -1 ? (b = (p = $.position()).top, _ = p.left) : (b = parseFloat(v) || 0, _ = parseFloat(x) || 0), Pe(u) && (u = u.call(c, f, g.extend({}, S))), null != u.top && (I.top = u.top - S.top + b), null != u.left && (I.left = u.left - S.left + _), "using" in u ? u.using.call(c, I) : $.css(I) } }, g.fn.extend({ offset: function (c) { if (arguments.length) return void 0 === c ? this : this.each(function (_) { g.offset.setOffset(this, c, _) }); var u, f, p = this[0]; return p ? p.getClientRects().length ? { top: (u = p.getBoundingClientRect()).top + (f = p.ownerDocument.defaultView).pageYOffset, left: u.left + f.pageXOffset } : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var c, u, f, p = this[0], _ = { top: 0, left: 0 }; if ("fixed" === g.css(p, "position")) u = p.getBoundingClientRect(); else { for (u = this.offset(), f = p.ownerDocument, c = p.offsetParent || f.documentElement; c && (c === f.body || c === f.documentElement) && "static" === g.css(c, "position");)c = c.parentNode; c && c !== p && 1 === c.nodeType && ((_ = g(c).offset()).top += g.css(c, "borderTopWidth", !0), _.left += g.css(c, "borderLeftWidth", !0)) } return { top: u.top - _.top - g.css(p, "marginTop", !0), left: u.left - _.left - g.css(p, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { for (var c = this.offsetParent; c && "static" === g.css(c, "position");)c = c.offsetParent; return c || Hr }) } }), g.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (c, u) { var f = "pageYOffset" === u; g.fn[c] = function (p) { return lr(this, function (_, v, b) { var S; if (Jn(_) ? S = _ : 9 === _.nodeType && (S = _.defaultView), void 0 === b) return S ? S[u] : _[v]; S ? S.scrollTo(f ? S.pageXOffset : b, f ? b : S.pageYOffset) : _[v] = b }, c, p, arguments.length) } }), g.each(["top", "left"], function (c, u) { g.cssHooks[u] = xd(dt.pixelPosition, function (f, p) { if (p) return p = Jo(f, u), zr.test(p) ? g(f).position()[u] + "px" : p }) }), g.each({ Height: "height", Width: "width" }, function (c, u) { g.each({ padding: "inner" + c, content: u, "": "outer" + c }, function (f, p) { g.fn[p] = function (_, v) { var b = arguments.length && (f || "boolean" != typeof _), S = f || (!0 === _ || !0 === v ? "margin" : "border"); return lr(this, function (x, R, N) { var $; return Jn(x) ? 0 === p.indexOf("outer") ? x["inner" + c] : x.document.documentElement["client" + c] : 9 === x.nodeType ? ($ = x.documentElement, Math.max(x.body["scroll" + c], $["scroll" + c], x.body["offset" + c], $["offset" + c], $["client" + c])) : void 0 === N ? g.css(x, R, S) : g.style(x, R, N, S) }, u, b ? _ : void 0, b) } }) }), g.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (c, u) { g.fn[u] = function (f) { return this.on(u, f) } }), g.fn.extend({ bind: function (c, u, f) { return this.on(c, null, u, f) }, unbind: function (c, u) { return this.off(c, null, u) }, delegate: function (c, u, f, p) { return this.on(u, c, f, p) }, undelegate: function (c, u, f) { return 1 === arguments.length ? this.off(c, "**") : this.off(u, c || "**", f) }, hover: function (c, u) { return this.mouseenter(c).mouseleave(u || c) } }), g.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (c, u) { g.fn[u] = function (f, p) { return arguments.length > 0 ? this.on(u, null, f, p) : this.trigger(u) } }); var Rd = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; g.proxy = function (c, u) { var f, p, _; if ("string" == typeof u && (f = c[u], u = c, c = f), Pe(c)) return p = zi.call(arguments, 2), _ = function () { return c.apply(u || this, p.concat(zi.call(arguments))) }, _.guid = c.guid = c.guid || g.guid++, _ }, g.holdReady = function (c) { c ? g.readyWait++ : g.ready(!0) }, g.isArray = Array.isArray, g.parseJSON = JSON.parse, g.nodeName = Bn, g.isFunction = Pe, g.isWindow = Jn, g.camelCase = li, g.type = sr, g.now = Date.now, g.isNumeric = function (c) { var u = g.type(c); return ("number" === u || "string" === u) && !isNaN(c - parseFloat(c)) }, g.trim = function (c) { return null == c ? "" : (c + "").replace(Rd, "") }, void 0 !== (Qe = function () { return g }.apply(cd, [])) && (Qo.exports = Qe); var cy = Ee.jQuery, hr = Ee.$; return g.noConflict = function (c) { return Ee.$ === g && (Ee.$ = hr), c && Ee.jQuery === g && (Ee.jQuery = cy), g }, void 0 === Nr && (Ee.jQuery = Ee.$ = g), g }) } }, Qo => { Qo(Qo.s = 118) }]);